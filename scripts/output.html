<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><head><style>body{font-size:90%;font-family: Arial, Helvetica, sans-serif;padding:5em;}     #script {font-family:monospace; padding-left:5em;} emph{color:red;}</style></head><body><h1>Instances of TODO</h1><p>Number of lines before : 5</p><p>Number of lines after  : 5</p><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/mesh/AggregateElementSubRegion.hpp</h4><div id=script>125-  virtual void CalculateElementGeometricQuantities( NodeManager const & nodeManager,</br>126-                                                    FaceManager const & faceManager ) override</br>127-  {</br>128-    GEOSX_UNUSED_VAR( nodeManager );</br>129-    GEOSX_UNUSED_VAR( faceManager );</br>130:    //<emph>TODO</emph> ?</br>131-  }</br>132-</br>133-  virtual void setupRelatedObjectsInRelations( MeshLevel const * const mesh ) override</br>134-  {</br>135-    GEOSX_UNUSED_VAR( mesh );</br></br>131-  }</br>132-</br>133-  virtual void setupRelatedObjectsInRelations( MeshLevel const * const mesh ) override</br>134-  {</br>135-    GEOSX_UNUSED_VAR( mesh );</br>136:    //<emph>TODO</emph> ?</br>137-  }</br>138-</br>139-  /**</br>140-   * @name viewKeyStruct</br>141-   */</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/mesh/EdgeManager.hpp</h4><div id=script>339-   */</br>340-  FaceMapType const & faceList() const { return m_toFacesRelation; }</br>341-</br>342-  ///@}</br>343-</br>344:  // <emph>TODO</emph> These should be in their own subset of edges when we add that capability.</br>345-</br>346-  /// map from the edges to the fracture connectors index (edges that are fracture connectors)</br>347-  SortedArray< localIndex > m_recalculateFractureConnectorEdges;</br>348-</br>--</br>345-</br>346-  /// map from the edges to the fracture connectors index (edges that are fracture connectors)</br>347-  SortedArray< localIndex > m_recalculateFractureConnectorEdges;</br>348-</br>349:  /// todo</br>350-  map< localIndex, localIndex > m_edgesToFractureConnectorsEdges;</br>351-</br>--</br>350-  map< localIndex, localIndex > m_edgesToFractureConnectorsEdges;</br>351-</br>352:  /// todo</br>353-  array1d< localIndex > m_fractureConnectorsEdgesToEdges;</br>354-</br>--</br>353-  array1d< localIndex > m_fractureConnectorsEdgesToEdges;</br>354-</br>355:  /// todo</br>356-  ArrayOfArrays< localIndex > m_fractureConnectorEdgesToFaceElements;</br>357-</br>358-</br>359-private:</br>360-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/LvArray/src/CRSMatrixView.hpp</h4><div id=script>292-   * @param row The row to access.</br>293-   * @param cols The columns to add to, must be sorted, unique and of length nCols.</br>294-   * @param vals The values to add, of length nCols.</br>295-   * @param nCols The number of columns to add to.</br>296-   * @pre The range [ @p cols, @p cols + @p ncols ) must be sorted and contain no duplicates.</br>297:   * <emph>TODO</emph>: Use benchmarks of addToRowBinarySearch and addToRowLinearSearch</br>298-   *   to develop a better heuristic.</br>299-   */</br>300-  template< typename AtomicPolicy ></br>301-  LVARRAY_HOST_DEVICE inline</br>302-  void addToRow( INDEX_TYPE const row,</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/LvArray/src/ArrayOfSets.hpp</h4><div id=script>122-</br>123-  /**</br>124-   * @brief Steal the resources from an ArrayOfArrays and convert it to an ArrayOfSets.</br>125-   * @param src the ArrayOfArrays to convert.</br>126-   * @param desc describes the type of data in the source.</br>127:   * <emph>TODO</emph>: Add a RAJA policy template parameter.</br>128-   */</br>129-  inline</br>130-  void assimilate( ArrayOfArrays< T, INDEX_TYPE, BUFFER_TYPE > && src,</br>131-                   sortedArrayManipulation::Description const desc ) LVARRAY_RESTRICT_THIS</br>132-  {</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/LvArray/src/MallocBuffer.hpp</h4><div id=script>112-   * @param size The number of values that are initialized in the buffer.</br>113-   * @param newCapacity The new capacity of the buffer.</br>114-   */</br>115-  void reallocate( std::ptrdiff_t const size, std::ptrdiff_t const newCapacity )</br>116-  {</br>117:    // <emph>TODO</emph>: If std::is_trivially_copyable_v< T > then we could use std::realloc.</br>118-    T * const newPtr = reinterpret_cast< T * >( std::malloc( newCapacity * sizeof( T ) ) );</br>119-</br>120-    std::ptrdiff_t const overlapAmount = std::min( newCapacity, size );</br>121-    arrayManipulation::uninitializedMove( newPtr, overlapAmount, m_data );</br>122-    arrayManipulation::destroy( m_data, size );</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/LvArray/src/genericTensorOps.hpp</h4><div id=script>158-</br>159-/**</br>160- * @brief Verify at compile time that the size of the R1Tensor is as expected.</br>161- * @tparam PROVIDED_SIZE The size the R1Tensor should be.</br>162- * @tparam INFERRED_SIZE The size of the R1Tensor.</br>163: * <emph>TODO</emph>: Remove this.</br>164- */</br>165-template< std::ptrdiff_t PROVIDED_SIZE, int INFERRED_SIZE ></br>166-LVARRAY_HOST_DEVICE inline constexpr</br>167-void checkSizes( R1TensorT< INFERRED_SIZE > const & )</br>168-{</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/dataRepository/MappedVector.hpp</h4><div id=script>473-  // if the key was not found, make DataObject<T> and insert</br>474-  if( iterKeyLookup == m_keyLookup.end() )</br>475-  {</br>476-    value_type newEntry = std::make_pair( keyName, std::move( source ) );</br>477-    m_values.push_back( std::move( newEntry ) );</br>478:    //<emph>TODO</emph> this needs to be a safe conversion</br>479-    index = static_cast< INDEX_TYPE >(m_values.size()) - 1;</br>480-    m_ownsValues.resize( index + 1 );</br>481-    if( takeOwnership )</br>482-    {</br>483-      m_ownsValues[index] = true;</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/dataRepository/wrapperHelpers.hpp</h4><div id=script>445-void pullDataFromConduitNode( InterObjectRelation< T > & var,</br>446-                              conduit::Node const & node )</br>447-{ return pullDataFromConduitNode( var.Base(), node ); }</br>448-</br>449-</br>450:/// <emph>TODO</emph>: Remove this function once https://github.com/visit-dav/visit/issues/4637 is fixed and released.</br>451-template< typename T, int NDIM, int USD ></br>452-std::enable_if_t< std::is_arithmetic< T >::value || traits::is_tensorT< T > ></br>453-addBlueprintField( ArrayView< T const, NDIM, USD > const & var,</br>454-                   conduit::Node & fields,</br>455-                   std::string const & fieldName,</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/fileIO/silo/SiloFile.hpp</h4><div id=script>169-                        int const * const shapesize,</br>170-                        int const cycleNumber,</br>171-                        real64 const problemTime );</br>172-</br>173-  /**</br>174:   * @todo Verify: documentation missing / incomplete. The TPL version of doxygen on Travis cannot parse</br>175-   * unnamed parameters, @p dummy parameter introduced to remove warning</br>176-   *</br>177-   * @param meshName name of the mesh in the silo db</br>178-   * @param nnodes number of nodes</br>179-   * @param coords array[3] of pointers to x, y, and z.</br></br>215-                             int const cycleNum,</br>216-                             real64 const problemTime,</br>217-                             bool const isRestart );</br>218-</br>219-  /**</br>220:   * @todo Verify: documentation missing / incomplete.</br>221-   *</br>222-   * @param elementRegion the element region that holds the data to be written to the silo file</br>223-   * @param nodeManager the NodeManager containing the nodes of the domain to be output</br>224-   * @param meshName name of the mesh to write</br>225-   * @param nnodes number of nodes</br></br>423-                       int const cycleNumber,</br>424-                       real64 const problemTime,</br>425-                       string const & multiRoot );</br>426-</br>427-  /**</br>428:   * @todo Verify: documentation missing / incomplete</br>429-   * @param meshName the name of the mesh attach this write to</br>430-   * @param fieldName name of the field to write</br>431-   * @param field field data</br>432-   * @param siloTensorRank <B>****** UNUSED IN THE IMPLEMENTATION ****** </B></br>433-   * @param centering the silo centering to use for this operation (DB_NODECENT, DB_ZONECENT)</br></br>444-                       int const cycleNumber,</br>445-                       real64 const problemTime,</br>446-                       string const & multiRoot );</br>447-</br>448-  /**</br>449:   * @todo Verify: documentation missing / incomplete</br>450-   * @param meshName the name of the mesh attach this write to</br>451-   * @param fieldName name of the field to write</br>452-   * @param field field data</br>453-   * @param elemRegion the element region that holds the data to be written to the silo file</br>454-   * @param centering the silo centering to use for this operation (DB_NODECENT, DB_ZONECENT)</br></br>467-                               real64 const problemTime,</br>468-                               string const & multiRoot,</br>469-                               string_array const & materialNames );</br>470-</br>471-  /**</br>472:   * @todo Verify: documentation missing / incomplete</br>473-   * @param meshName the name of the mesh attach this write to</br>474-   * @param fieldName name of the field to write</br>475-   * @param elemRegion the element region that holds the data to be written to the silo file</br>476-   * @param centering the silo centering to use for this operation (DB_NODECENT, DB_ZONECENT)</br>477-   * @param cycleNumber the current cycle number</br></br>488-                                 real64 const problemTime,</br>489-                                 string const & multiRoot,</br>490-                                 string_array const & materialNames );</br>491-</br>492-  /**</br>493:   * @todo Verify: documentation missing / incomplete</br>494-   * @param meshName the name of the mesh attach this write to</br>495-   * @param fieldName name of the field to write</br>496-   * @param elemRegion the element region that holds the data to be written to the silo file</br>497-   * @param centering the silo centering to use for this operation (DB_NODECENT, DB_ZONECENT)</br>498-   * @param cycleNumber the current cycle number</br></br>509-                                 real64 const problemTime,</br>510-                                 string const & multiRoot,</br>511-                                 string_array const & materialNames );</br>512-</br>513-  /**</br>514:   * @todo Verify: documentation missing / incomplete</br>515-   * @param meshName the name of the mesh attach this write to</br>516-   * @param fieldName name of the field to write</br>517-   * @param elemRegion the element region that holds the data to be written to the silo file</br>518-   * @param centering the silo centering to use for this operation (DB_NODECENT, DB_ZONECENT)</br>519-   * @param cycleNumber the current cycle number</br></br>530-                                 real64 const problemTime,</br>531-                                 string const & multiRoot,</br>532-                                 string_array const & materialNames );</br>533-</br>534-  /**</br>535:   * @todo Verify: documentation missing / incomplete</br>536-   * @param subDir</br>537-   * @param matDir</br>538-   * @param matIndex</br>539-   * @param fieldName</br>540-   */</br></br>542-                                   string const & matDir,</br>543-                                   localIndex const matIndex,</br>544-                                   string const & fieldName );</br>545-</br>546-  /**</br>547:   * @todo Verify: documentation missing / incomplete</br>548-   * @param MatDir</br>549-   */</br>550-  void WriteStressVarDefinition( string const & MatDir );</br>551-</br>552-  /**</br></br>548-   * @param MatDir</br>549-   */</br>550-  void WriteStressVarDefinition( string const & MatDir );</br>551-</br>552-  /**</br>553:   * @todo Verify: documentation missing / incomplete</br>554-   * @param fieldName vector field name</br>555-   * @param subDirectory</br>556-   */</br>557-  void WriteVectorVarDefinition( string const & fieldName,</br>558-                                 string const & subDirectory );</br></br>746-{</br>747-  return field.Data()[i];</br>748-}</br>749-</br>750-/**</br>751: * @todo Verify: the TPL version of doxygen on Travis cannot parse unnamed parameters, @p dummy</br>752- *       parameter introduced to remove warning</br>753- * @param field the value to cast</br>754- * @param dummy unused parameter</br>755- * @return the casted value</br>756- */</br></br>759-  GEOSX_UNUSED_VAR( dummy );</br>760-  return field;</br>761-}</br>762-</br>763-/**</br>764: * @todo Verify: the TPL version of doxygen on Travis cannot parse unnamed parameters, @p dummy</br>765- *       parameter introduced to remove warning</br>766- * @param field the value to cast</br>767- * @param dummy unused parameter</br>768- * @return the casted value</br>769- */</br></br>772-  GEOSX_UNUSED_VAR( dummy );</br>773-  return field;</br>774-}</br>775-</br>776-/**</br>777: * @todo Verify: the TPL version of doxygen on Travis cannot parse unnamed parameters, @p dummy</br>778- *       parameter introduced to remove warning</br>779- * @param field the value to cast</br>780- * @param dummy unused parameter</br>781- * @return the casted value</br>782- */</br></br>785-  GEOSX_UNUSED_VAR( dummy );</br>786-  return LvArray::integerConversion< int >( field );</br>787-}</br>788-</br>789-/**</br>790: * @todo Verify: the TPL version of doxygen on Travis cannot parse unnamed parameters, @p dummy</br>791- *       parameter introduced to remove warning</br>792- * @param field the value to cast</br>793- * @param dummy unused parameter</br>794- * @return the casted value</br>795- */</br></br>798-  GEOSX_UNUSED_VAR( dummy );</br>799-  return field;</br>800-}</br>801-</br>802-/**</br>803: * @todo Verify: the TPL version of doxygen on Travis cannot parse unnamed parameters, @p dummy</br>804- *       parameter introduced to remove warning</br>805- * @param field the value to cast</br>806- * @param dummy unused parameter</br>807- * @return the casted value</br>808- */</br></br>811-  GEOSX_UNUSED_VAR( dummy );</br>812-  return LvArray::integerConversion< int >( field );</br>813-}</br>814-</br>815-/**</br>816: * @todo Verify: the TPL version of doxygen on Travis cannot parse unnamed parameters, @p dummy</br>817- *       parameter introduced to remove warning</br>818- * @param field the value to cast</br>819- * @param dummy unused parameter</br>820- * @return the casted value</br>821- */</br></br>824-  GEOSX_UNUSED_VAR( dummy );</br>825-  return field;</br>826-}</br>827-</br>828-/**</br>829: * @todo Verify: the TPL version of doxygen on Travis cannot parse unnamed parameters, @p dummy</br>830- *       parameter introduced to remove warning</br>831- * @param field the value to cast</br>832- * @param dummy unused parameter</br>833- * @return the casted value</br>834- */</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/managers/ObjectManagerBase.hpp</h4><div id=script>275-  localIndex PackParentChildMapsPrivate( buffer_unit_type * & buffer,</br>276-                                         arrayView1d< localIndex const > const & packList ) const;</br>277-</br>278-  //**********************************************************************************************************************</br>279-  // functions for compatibility with old data structure</br>280:  // <emph>TODO</emph> Deprecate or modernize all these suckers</br>281-</br>282-public:</br>283-</br>284-  /**</br>285-   * @brief Manually move all sets to a memory space.</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/managers/FieldSpecification/FieldSpecificationManager.hpp</h4><div id=script>294-                               ) const</br>295-  {</br>296-    if( ( target->getParent()->getName() == ElementRegionBase::viewKeyStruct::elementSubRegions</br>297-          || target->getName() == "nodeManager"</br>298-          || target->getName() == "FaceManager"</br>299:          || target->getName() == "edgeManager" ) // <emph>TODO</emph> these 3 strings are harcoded because for the moment, there are</br>300-                                                  // inconsistencies with the name of the Managers...</br>301-        && target->getName() != ObjectManagerBase::groupKeyStruct::setsString</br>302-        && target->getName() != ObjectManagerBase::groupKeyStruct::neighborDataString )</br>303-    {</br>304-      dataRepository::Group const * setGroup = target->GetGroup( ObjectManagerBase::groupKeyStruct::setsString );</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/managers/Functions/FunctionBase.hpp</h4><div id=script>185-        input[c] = input_ptrs[a][(index*varSize[a]+b)*timeVar[a]];</br>186-        ++c;</br>187-      }</br>188-    }</br>189-</br>190:    // <emph>TODO</emph>: Check this line to make sure it is correct</br>191-    result[count] = static_cast< LEAF const * >(this)->Evaluate( input );</br>192-    ++count;</br>193-  } );</br>194-</br>195-}</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/fluidFlow/SinglePhaseBaseKernels.hpp</h4><div id=script>210-           real64 & localAccum,</br>211-           real64 & localAccumJacobian )</br>212-  {</br>213-    real64 const volNew = volume + dVol;</br>214-</br>215:    // <emph>TODO</emph> porosity update needs to be elsewhere...</br>216-    real64 dPoro_dPres;</br>217-    AssembleAccumulationTermsHelper< COUPLED >::porosityUpdate( poroNew,</br>218-                                                                dPoro_dPres,</br>219-                                                                biotCoefficient,</br>220-                                                                poroOld,</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/fluidFlow/wells/SinglePhaseWellKernels.hpp</h4><div id=script>342-        // compute momentum flux and derivatives</br>343-        real64 const localPresRel = ( pressureNext - pressureCurrent - avgDensity * gravD ) * normalizer;</br>344-        localPresRelJacobian[SinglePhaseWell::ElemTag::NEXT] = ( 1 - dAvgDensity_dPresNext * gravD ) * normalizer;</br>345-        localPresRelJacobian[SinglePhaseWell::ElemTag::CURRENT] = ( -1 - dAvgDensity_dPresCurrent * gravD ) * normalizer;</br>346-</br>347:        // <emph>TODO</emph>: add friction and acceleration terms</br>348-</br>349-        // jacobian indices</br>350-        globalIndex const offsetNext = wellElemDofNumber[iwelemNext];</br>351-        globalIndex const offsetCurrent = wellElemDofNumber[iwelem];</br>352-        globalIndex const eqnRowIndex = offsetCurrent + SinglePhaseWell::RowOffset::CONTROL - rankOffset;</br></br>425-</br>426-      // get reservoir variables</br>427-      pressure[SinglePhaseWell::SubRegionTag::RES] = resPressure[er][esr][ei] + dResPressure[er][esr][ei];</br>428-      dPressure_dP[SinglePhaseWell::SubRegionTag::RES] = 1;</br>429-</br>430:      // <emph>TODO</emph>: add a buoyancy term for the reservoir side here</br>431-</br>432-      // multiplier for reservoir side in the flux</br>433-      multiplier[SinglePhaseWell::SubRegionTag::RES] = 1;</br>434-</br>435-      // 2) Well side</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/fluidFlow/wells/CompositionalMultiphaseWellKernels.hpp</h4><div id=script>48-          real64 const & dWellElemPressure,</br>49-          real64 const & connRate,</br>50-          real64 const & dConnRate,</br>51-          WellControls::Control & newControl )</br>52-  {</br>53:    // <emph>TODO</emph>: check all inactive constraints (possibly more than one) and switch the one which is most violated</br>54:    // <emph>TODO</emph>: for the rate, use surface conditions (flash for compositional, easier for BO)</br>55-</br>56-    // if isViable is true at the end of the following checks, no need to switch</br>57-    bool controlIsViable = false;</br>58-</br>59-    real64 const refRate = connRate + dConnRate;</br></br>547-</br>548-          localPresRelJacobian[localDofIndexCompNext] = -dAvgDensity_dCompNext[ic] * gravD * normalizer;</br>549-          localPresRelJacobian[localDofIndexCompCurrent] = -dAvgDensity_dCompCurrent[ic] * gravD * normalizer;</br>550-        }</br>551-</br>552:        // <emph>TODO</emph>: add friction and acceleration terms</br>553-</br>554-        if( eqnRowIndex >= 0 && eqnRowIndex < localMatrix.numRows() )</br>555-        {</br>556-          localMatrix.addToRowBinarySearchUnsorted< parallelDeviceAtomic >( eqnRowIndex,</br>557-                                                                            dofColIndices.data(),</br></br>681-      localIndex const iwelem = perfWellElemIndex[iperf];</br>682-</br>683-      pressure[CompositionalMultiphaseWell::SubRegionTag::RES] = resPressure[er][esr][ei] + dResPressure[er][esr][ei];</br>684-      dPressure_dP[CompositionalMultiphaseWell::SubRegionTag::RES] = 1.0;</br>685-</br>686:      // <emph>TODO</emph>: add a buoyancy term for the reservoir side here</br>687-</br>688-      multiplier[CompositionalMultiphaseWell::SubRegionTag::RES] = 1.0;</br>689-</br>690-      // b) get well variables</br>691-</br></br>1043-        sumTotalDensity += resCompDens[er][esr][ei][ic];</br>1044-      }</br>1045-    } );</br>1046-</br>1047-</br>1048:    // <emph>TODO</emph>: there must a better way to do what is below</br>1049-    // I would like to define an array of RAJA::ReduceSum to be able to do sum[ic] += ...</br>1050-    // and put back what is below in the previous kernel.</br>1051-    stackArray1d< real64, maxNumComp > sumCompFrac( NC );</br>1052-    for( localIndex ic = 0; ic < NC; ++ic )</br>1053-    {</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/surfaceGeneration/SurfaceGenerator.hpp</h4><div id=script>513-    constexpr static auto tipFacesString = "tipFaces";</br>514-    constexpr static auto trailingFacesString = "trailingFaces";</br>515-    constexpr static auto fractureRegionNameString = "fractureRegion";</br>516-    constexpr static auto mpiCommOrderString = "mpiCommOrder";</br>517-</br>518:    //<emph>TODO</emph>: rock toughness should be a material parameter, and we need to make rock toughness to KIC a constitutive</br>519-    // relation.</br>520-    constexpr static auto rockToughnessString = "rockToughness";</br>521-</br>--</br>519-    // relation.</br>520-    constexpr static auto rockToughnessString = "rockToughness";</br>521-</br>522://    //<emph>TODO</emph>: Once the node-based SIF criterion becomes mature and robust, remove the edge-based criterion.</br>523-    constexpr static auto nodeBasedSIFString = "nodeBasedSIF";</br>524-</br>525-  }; //SurfaceGenViewKeys;</br>526-</br>527-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/surfaceGeneration/EmbeddedSurfaceGenerator.hpp</h4><div id=script>118-   */</br>119-  struct viewKeyStruct : SolverBase::viewKeyStruct</br>120-  {</br>121-    constexpr static auto solidMaterialNameString = "solidMaterialNames";</br>122-    constexpr static auto fractureRegionNameString = "fractureRegion";</br>123:    //<emph>TODO</emph>: rock toughness should be a material parameter, and we need to make rock toughness to KIC a constitutive</br>124-    // relation.</br>125-    constexpr static auto rockToughnessString = "rockToughness";</br>126-  }; //SurfaceGenViewKeys;</br>127-</br>128-private:</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/finiteVolume/FluxApproximationBase.hpp</h4><div id=script>273-}</br>274-</br>275-template< typename LAMBDA ></br>276-void FluxApproximationBase::forAllStencils( MeshLevel const & mesh, LAMBDA && lambda ) const</br>277-{</br>278:  //<emph>TODO</emph> remove dependence on CellElementStencilTPFA and FaceElementStencil</br>279-  forStencils< CellElementStencilTPFA, FaceElementStencil >( mesh, std::forward< LAMBDA >( lambda ) );</br>280-}</br>281-</br>282-template< typename TYPE, typename ... TYPES, typename LAMBDA ></br>283-void FluxApproximationBase::forStencils( MeshLevel const & mesh, LAMBDA && lambda ) const</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/finiteVolume/FaceElementStencil.hpp</h4><div id=script>23-</br>24-namespace geosx</br>25-{</br>26-</br>27-/// @cond DO_NOT_DOCUMENT</br>28:// <emph>TODO</emph> remove! This option allows for the creation of new mass inside a newly</br>29-// created FaceElement. The new mass will be equal to:</br>30-// creationMass = defaultDensity * defaultAperture * faceArea.</br>31-// If 0, then the beginning of step density is artificially set to zero...which</br>32-// may cause some newton convergence problems.</br>33-#define ALLOW_CREATION_MASS 1</br></br>31-// If 0, then the beginning of step density is artificially set to zero...which</br>32-// may cause some newton convergence problems.</br>33-#define ALLOW_CREATION_MASS 1</br>34-</br>35-</br>36:// <emph>TODO</emph> remove! This option sets the pressure in a newly created FaceElement to</br>37-// be the lowest value of all attached non-new FaceElements.</br>38-#define SET_CREATION_PRESSURE 1</br>39-</br>--</br>37-// be the lowest value of all attached non-new FaceElements.</br>38-#define SET_CREATION_PRESSURE 1</br>39-</br>40:// <emph>TODO</emph> remove! This option sets the nodal displacements attached a newly</br>41-// created FaceElement to some scalar fraction of the aperture of the</br>42-// lowest attached non-new FaceElements.</br>43-#define SET_CREATION_DISPLACEMENT 0</br>44-/// @endcond</br>45-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/finiteVolume/FluxStencil.hpp</h4><div id=script>174-    executeOnMapValue( m_connectorIndices, connectorIndex, [&]( localIndex const connectionListIndex )</br>175-  {</br>176-    Entry * const entries = m_connections[connectionListIndex];</br>177-    for( localIndex i = 0; i < m_connections.sizeOfArray( connectionListIndex ); ++i )</br>178-    {</br>179:      entries[i].weight = 0; // <emph>TODO</emph> remove entries altogether?</br>180-    }</br>181-//    m_connections.resizeArray( connectionListIndex, 0 );</br>182-  } );</br>183-}</br>184-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/finiteElement/FiniteElementDiscretization.hpp</h4><div id=script>31-</br>32-class NodeManager;</br>33-class CellBlockManager;</br>34-class ElementSubRegionBase;</br>35-</br>36:// <emph>TODO</emph> remove when these quantities are placed inside the FiniteElementBase</br>37-// class.</br>38-namespace dataRepository</br>39-{</br>40-namespace keys</br>41-{</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/finiteElement/elementFormulations/FiniteElementBase.hpp</h4><div id=script>77-           J[1][0] * ( J[0][2]*J[2][1] - J[0][1]*J[2][2] ) +</br>78-           J[2][0] * ( J[0][1]*J[1][2] - J[0][2]*J[1][1] );</br>79-  }</br>80-</br>81-</br>82://<emph>TODO</emph> we want to keep views and provide interfaces to this data here for cases</br>83-//     where we pre-compute the shape function derivatives...maybe...tbd.</br>84-//private:</br>85-//  arrayView4d< real64 const > const m_dNdX;</br>86-//  arrayView2d< real64 const > const m_detJ;</br>87-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/finiteElement/kernelInterface/SparsityKernelBase.hpp</h4><div id=script>174-//*****************************************************************************</br>175-//*****************************************************************************</br>176-/**</br>177- * @brief Fills matrix sparsity.</br>178- * @tparam POLICY The RAJA launch policy to pass to the kernel launch.</br>179: * @tparam REGION_TYPE The type of region to loop over. <emph>TODO</emph> make this a</br>180- *                     parameter pack?</br>181- * @tparam KERNEL_TEMPLATE The type of template for the physics kernel, which</br>182- *                         conforms to the interface specified by KernelBase.</br>183- * @param mesh The MeshLevel object.</br>184- * @param targetRegions The names of the target regions(of type @p REGION_TYPE)</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/finiteElement/kernelInterface/KernelBase.hpp</h4><div id=script>499- *                           This is achieved through a call to the</br>500- *                           ConstitutivePassThru function which</br>501- *                           should have a specialization for CONSTITUTIVE_BASE</br>502- *                           implemented in order to perform the compile time</br>503- *                           dispatch.</br>504: * @tparam REGION_TYPE The type of region to loop over. <emph>TODO</emph> make this a</br>505- *                     parameter pack?</br>506- * @tparam KERNEL_TEMPLATE The type of template for the physics kernel, which</br>507- *                         conforms to the interface specified by KernelBase.</br>508- * @tparam KERNEL_CONSTRUCTOR_PARAMS The template parameter pack to hold the</br>509- *                                   parameter pack (i.e. custom) parameters</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/linearAlgebra/solvers/BlockPreconditioner.hpp</h4><div id=script>28-{</br>29-</br>30-/**</br>31- * @brief Type of Schur complement approximation used</br>32- *</br>33: * @todo Need more descriptive names for options</br>34- */</br>35-enum class SchurComplementOption</br>36-{</br>37-  None,                  //!< No Schur complement - just block-GS/block-Jacobi preconditioner</br>38-  FirstBlockDiagonal,    //!< Approximate first block with its diagonal</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/linearAlgebra/interfaces/MatrixBase.hpp</h4><div id=script>218-   * @brief Create parallel matrix from a local CRS matrix.</br>219-   * @param localMatrix The input local matrix.</br>220-   * @param comm The MPI communicator to use.</br>221-   *</br>222-   * @note Copies values, so that @p localMatrix does not need to retain its values after the call.</br>223:   * @todo Replace generic implementation with more efficient ones in each package.</br>224-   */</br>225-  virtual void create( CRSMatrixView< real64 const, globalIndex const > const & localMatrix,</br>226-                       MPI_Comm const & comm )</br>227-  {</br>228-    localMatrix.move( LvArray::MemorySpace::CPU, false );</br></br>745-  /**</br>746-   * @brief Get row length via local row index.</br>747-   * @param[in] localRowIndex the local row index</br>748-   * @return the number of nonzero entries in the row</br>749-   *</br>750:   * <emph>TODO</emph>: Breaks the goal of hiding local row indexing from user.</br>751-   *       Revise use cases to use ilower() and iupper().</br>752-   */</br>753-  virtual localIndex localRowLength( localIndex localRowIndex ) const = 0;</br>754-</br>755-  /**</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/linearAlgebra/interfaces/hypre/HypreMGRStrategies.hpp</h4><div id=script>25-</br>26-namespace geosx</br>27-{</br>28-</br>29-/**</br>30: * @todo Add a detailed description with an example</br>31- *</br>32- * @brief Compute an array of unique component labels.</br>33- *</br>34- * @details</br>35- *</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/constitutive/fluid/ProppantSlurryFluid.hpp</h4><div id=script>383-    fluidDensity += componentDensity[c] - componentConcentration[c] * baseFluidDensity;</br>384-    dFluidDensity_dPressure += dComponentDensity_dPressure[c] - componentConcentration[c] * dBaseFluidDensity_dPressure;</br>385-    dFluidDensity_dComponentConcentration[c] += dComponentDensity_dComponentConcentration[c][c] - baseFluidDensity;</br>386-  }</br>387-</br>388:  // <emph>TODO</emph>: why? - Sergey</br>389-  for( localIndex c = 0; c < NC; ++c )</br>390-  {</br>391-    dFluidDensity_dComponentConcentration[c] = 0.0;</br>392-  }</br>393-}</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/constitutive/fluid/ParticleFluid.hpp</h4><div id=script>324-    if( m_isCollisionalSlip )</br>325-    {</br>326-      real64 const lambda = m_collisionAlpha - pow( fabs( proppantConcentration - m_slipConcentration ), m_collisionBeta );</br>327-      collisionFactor = (lambda - 1.0) / (1.0 - proppantConcentration);</br>328-</br>329:      // <emph>TODO</emph>: why? - Sergey</br>330-#if 0</br>331-      real64 dLambda_dC = -m_collisionBeta * pow( fabs( proppantConcentration - m_slipConcentration ), m_collisionBeta - 1.0 );</br>332-      if( proppantConcentration < m_slipConcentration )</br>333-      {</br>334-        dLambda_dC = -dLambda_dC;</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/constitutive/fluid/CompressibleSinglePhaseFluid.hpp</h4><div id=script>126-  virtual string GetCatalogName() override { return CatalogName(); }</br>127-</br>128-  virtual void AllocateConstitutiveData( dataRepository::Group * const parent,</br>129-                                         localIndex const numConstitutivePointsPerParentIndex ) override;</br>130-</br>131:  /// Type of kernel wrapper for in-kernel update (<emph>TODO</emph>: support multiple EAT, not just linear)</br>132-  using KernelWrapper = CompressibleSinglePhaseUpdate< ExponentApproximationType::Linear, ExponentApproximationType::Linear >;</br>133-</br>134-  /**</br>135-   * @brief Create an update kernel wrapper.</br>136-   * @return the wrapper</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/constitutive/capillaryPressure/VanGenuchtenCapillaryPressure.hpp</h4><div id=script>165-    }</br>166-  }</br>167-</br>168-  // the VanGenuchten model does not support volFracScaled = 0 and = 1</br>169-  // hence we need an epsilon value to avoid a division by zero</br>170:  // <emph>TODO</emph>: for S < epsilon and S > 1 - epsilon, replace the original unbounded VG curve with a bounded power-law</br>171-  // extension</br>172-  real64 const eps = m_capPressureEpsilon;</br>173-  real64 const volFracScaleInv = 1.0 / m_volFracScale;</br>174-</br>175-  // compute first water-oil capillary pressure as a function of water-phase vol fraction</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/constitutive/capillaryPressure/BrooksCoreyCapillaryPressure.hpp</h4><div id=script>168-</br>169-  real64 const volFracScaleInv = 1.0 / m_volFracScale;</br>170-</br>171-  // the Brooks-Corey model does not support volFracScaled = 0,</br>172-  // hence we need an epsilon value to avoid a division by zero</br>173:  // <emph>TODO</emph>: for S < epsilon, replace the original unbounded BC curve with a bounded power-law extension</br>174-  real64 const eps = m_capPressureEpsilon;</br>175-</br>176-</br>177-  // compute first water-oil capillary pressure as a function of water-phase vol fraction</br>178-  integer const ip_water = m_phaseOrder[CapillaryPressureBase::PhaseType::WATER];</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PVTPackage/PVTPackage/source/MultiphaseSystem/PhaseModel/PhaseProperties.hpp</h4><div id=script>30-    Viscosity(0),</br>31-    MassEnthalpy(0),</br>32-    Compressibility(0)</br>33-  {</br>34-</br>35://    auto df = 2; //<emph>TODO</emph>: don't know why I need this default constructor. Nothing goes through it but compiler crashes</br>36-//    df++;</br>37-  }</br>38-</br>39-  void UpdateDerivative_dP_FiniteDifference(const PhaseProperties& props_eps, double epsilon)</br>40-  {</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PAMELA/examples/executable/command_parser.hpp</h4><div id=script>2568-                        } else if (optionType == OptionType::ShortFlag && allowJoinedShortValue)</br>2569-                        {</br>2570-                            if (chunk.size() > shortprefix.size() + 1)</br>2571-                            {</br>2572-                                auto arg = chunk.at(shortprefix.size());</br>2573:                                //<emph>TODO</emph>: support -abcVALUE where a and b take no value</br>2574-                                if (auto flag = this->Match(arg))</br>2575-                                {</br>2576-                                    for (auto &choice : flag->HelpChoices(helpParams))</br>2577-                                    {</br>2578-                                        AddCompletionReply(chunk, shortprefix + arg + choice);</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PAMELA/PAMELA/source/Parallel/ParallelEnsemble.hpp</h4><div id=script>134-        {</br>135-          owned_vec_temp.push_back(*it);</br>136-        }</br>137-        else</br>138-        {</br>139:          //delete *it;  //<emph>TODO</emph>, need to delete dynamics objects but delete multiple time now. Smart pointer?</br>140-          //*it = nullptr;</br>141-        }</br>142-      }</br>143-</br>144-      //Rebuilt data</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PAMELA/PAMELA/source/Collection/ElementEnsemble.hpp</h4><div id=script>139-				{</br>140-					owned_vec_temp.push_back(*it);</br>141-				}</br>142-				else</br>143-				{</br>144:					//delete *it;  //<emph>TODO</emph>, need to delete dynamics objects but delete multiple time now. Smart pointer?</br>145-					//*it = nullptr;</br>146-				}</br>147-			}</br>148-</br>149-			//Rebuilt data</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PAMELA/PAMELA/source/Collection/Collection.hpp</h4><div id=script>144-				if (lhs_vertex_list[i]->get_localIndex() != rhs_vertex_list[i]->get_localIndex())</br>145-				{</br>146-					return false;</br>147-				}</br>148-			}</br>149:			return true;		//<emph>TODO</emph>:When can it happen?</br>150-		}</br>151-	};</br>152-</br>153-</br>154-	/**</br></br>172-			{</br>173-				addAndCreateGroup(label);</br>174-			}</br>175-			auto grp = m_labelToGroup[label];</br>176-			grp->push_back_unique(cur_element);</br>177:			auto returnedElement = this->push_back_unique(cur_element);//<emph>TODO</emph>:index twice</br>178-			return returnedElement;</br>179-		}</br>180-</br>181-</br>182-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PAMELA/PAMELA/source/Property/Property.hpp</h4><div id=script>44-		}</br>45-</br>46-		void SetProperty(std::string label, std::vector<T2> val)</br>47-		{</br>48-			ASSERT(m_data.count(label) == 1, "Property does not exist");</br>49:			//<emph>TODO</emph>:ASSERT(static_cast<int>(val.size) == m_Owner->size_owned(), "Input vector should be same size as the owner");</br>50-			m_data[label].push_back_owned(val);</br>51-		}</br>52-</br>53-		void GetProperty_owned(std::string& label) { return m_data[label].data(); }</br>54-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PAMELA/PAMELA/source/MeshDataWriters/EnsightGoldWriter.hpp</h4><div id=script>12-#endif</br>13-</br>14-namespace PAMELA</br>15-{</br>16-</br>17:	//<emph>TODO</emph> variables in parallel, vector and tensors data</br>18-</br>19-	enum class ENSIGHT_GOLD_TYPE { UNKNOWN = -1, ESG_POINT = 1, ESG_BAR2 = 2, ESG_TRIA3 = 4, ENS_QUAD4 = 6, ENS_TETRA4 = 8, ENS_PYRAMID5 = 10, ENS_PENTA6 = 12, ENS_HEXA8 = 14 };</br>20-</br>21-	class EnsightGoldWriter : public MeshDataWriter</br>22-	{</br></br>238-				variableFile << partptr->Index << std::endl;</br>239-				variableFile << "coordinates" << std::endl;</br>240-				for (auto it3 = partptr->Points.begin(); it3 != partptr->Points.end(); ++it3)</br>241-				{</br>242-</br>243:					//<emph>TODO</emph> does not work</br>244-					auto collectionIndex = std::distance(partptr->Points.begin(), it3);</br>245-					auto variableData = variableptr->get_data(static_cast<int>(collectionIndex));</br>246-					for (auto it5 = variableData.begin(); it5 != variableData.end(); ++it5)</br>247-					{</br>248-						variableFile << std::setw(12) << (*it5) << std::endl;</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PAMELA/PAMELA/source/MeshDataWriters/MeshDataWriter.hpp</h4><div id=script>160-			//SetElementGlobalIndexOnPart(&m_LineParts);</br>161-			//SetElementGlobalIndexOnPart(&m_PolyhedronParts);</br>162-			//SetElementGlobalIndexOnPart(&m_PolygonParts);</br>163-</br>164-</br>165:			//<emph>TODO</emph>: Need to be fixed as globalIndex cannot be defined on all types of elements</br>166-		}</br>167-</br>168-		virtual void Dump() = 0;</br>169-</br>170-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PAMELA/PAMELA/source/MeshDataWriters/Part.hpp</h4><div id=script>80-		};</br>81-</br>82-		std::vector<VariableDouble*> PerElementVariable;</br>83-		std::vector<VariableDouble*> PerNodeVariable;</br>84-</br>85:	}; //<emph>TODO</emph>: specialize init of numberOfElementsPerSubPart</br>86-</br>87-</br>88-}</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PAMELA/PAMELA/source/Elements/Polyhedron.hpp</h4><div id=script>311-</br>312-  template <></br>313-  inline double ElementSpe<ELEMENTS::FAMILY::POLYHEDRON, ELEMENTS::TYPE::VTK_WEDGE>::get_Volume()</br>314-  {</br>315-    LOGERROR("NOT SUPPORTED YET");</br>316:    return 0;	//<emph>TODO</emph></br>317-  }</br>318-</br>319-</br>320-  /**</br>321-  * \brief</br></br>323-  */</br>324-  template <></br>325-  inline std::vector<double> ElementSpe<ELEMENTS::FAMILY::POLYHEDRON, ELEMENTS::TYPE::VTK_WEDGE>::get_centroidCoordinates()</br>326-  {</br>327-    LOGERROR("NOT SUPPORTED YET");</br>328:    return{ 0,0,0,0,0,0 };  //<emph>TODO</emph></br>329-  }</br>330-</br>331-</br>332-  /**</br>333-  * \brief</br></br>341-  {</br>342-                utils::pamela_unused(xi_1);</br>343-                utils::pamela_unused(xi_2);</br>344-                utils::pamela_unused(xi_3);</br>345-    LOGERROR("NOT SUPPORTED YET");</br>346:    return{ 0,0,0,0,0,0 };  //<emph>TODO</emph></br>347-  }</br>348-</br>349-  /**</br>350-  * \brief</br>351-  * \param xi_1</br></br>360-                utils::pamela_unused(xi_2);</br>361-                utils::pamela_unused(xi_3);</br>362-    std::vector<double> row;</br>363-    std::vector<std::vector<double>> matrix;</br>364-    LOGERROR("NOT SUPPORTED YET");</br>365:    return matrix;			//<emph>TODO</emph></br>366-</br>367-  }</br>368-</br>369-</br>370-  //////// VTK_PYRAMID</br></br>371-</br>372-  template <></br>373-  inline double ElementSpe<ELEMENTS::FAMILY::POLYHEDRON, ELEMENTS::TYPE::VTK_PYRAMID>::get_Volume()</br>374-  {</br>375-    LOGERROR("NOT SUPPORTED YET");</br>376:    return 0;	//<emph>TODO</emph></br>377-  }</br>378-</br>379-</br>380-  /**</br>381-  * \brief</br></br>383-  */</br>384-  template <></br>385-  inline std::vector<double> ElementSpe<ELEMENTS::FAMILY::POLYHEDRON, ELEMENTS::TYPE::VTK_PYRAMID>::get_centroidCoordinates()</br>386-  {</br>387-    LOGERROR("NOT SUPPORTED YET");</br>388:    return{ 0,0,0,0,0 };  //<emph>TODO</emph></br>389-  }</br>390-</br>391-</br>392-  /**</br>393-  * \brief</br></br>401-  {</br>402-                utils::pamela_unused(xi_1);</br>403-                utils::pamela_unused(xi_2);</br>404-                utils::pamela_unused(xi_3);</br>405-    LOGERROR("NOT SUPPORTED YET");</br>406:    return{ 0,0,0,0,0 };  //<emph>TODO</emph></br>407-  }</br>408-</br>409-  /**</br>410-  * \brief</br>411-  * \param xi_1</br></br>420-                utils::pamela_unused(xi_2);</br>421-                utils::pamela_unused(xi_3);</br>422-    std::vector<double> row;</br>423-    std::vector<std::vector<double>> matrix;</br>424-    LOGERROR("NOT SUPPORTED YET");</br>425:    return matrix;			//<emph>TODO</emph></br>426-</br>427-  }</br>428-</br>429-</br>430-  //////// VTK_TETRA</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/mesh/FaceElementRegion.cpp</h4><div id=script>107-</br>108-  // Add the nodes that compose the new FaceElement to the nodeList</br>109-  localIndex const numNodesInFace0 = faceToNodeMap.sizeOfArray( faceIndices[ 0 ] );</br>110-  localIndex const numNodesInFace1 = faceToNodeMap.sizeOfArray( faceIndices[ 1 ] );</br>111-</br>112:  //Temporarily set the map size 8 for both quadrangle and triangle faces. <emph>TODO</emph>: need to fix for arbitrary face sizes.</br>113-  nodeMap[kfe].resize( 8 );</br>114-</br>115-  for( localIndex a = 0; a < numNodesInFace0; ++a )</br>116-  {</br>117-    localIndex const aa = a < 2 ? a : numNodesInFace0 - a + 1;</br></br>115-  for( localIndex a = 0; a < numNodesInFace0; ++a )</br>116-  {</br>117-    localIndex const aa = a < 2 ? a : numNodesInFace0 - a + 1;</br>118-    localIndex const bb = aa == 0 ? aa : numNodesInFace1 - aa;</br>119-</br>120:    // <emph>TODO</emph> HACK need to generalize to something other than quads</br>121-    nodeMap[ kfe ][ a ] = faceToNodeMap( faceIndices[ 0 ], aa );</br>122-    nodeMap[ kfe ][ a + numNodesInFace0 ] = faceToNodeMap( faceIndices[ 1 ], bb );</br>123-  }</br>124-</br>125-  if( numNodesInFace0 == 3 )</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/mesh/CellBlockManager.cpp</h4><div id=script>32-  this->RegisterGroup< Group >( keys::cellBlocks );</br>33-}</br>34-</br>35-CellBlockManager::~CellBlockManager()</br>36-{</br>37:  // <emph>TODO</emph> Auto-generated destructor stub</br>38-}</br>39-</br>40-void CellBlockManager::resize( integer_array const & numElements,</br>41-                               string_array const & regionNames,</br>42-                               string_array const & GEOSX_UNUSED_PARAM( elementTypes ) )</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/mesh/ElementRegionManager.cpp</h4><div id=script>36-  this->RegisterGroup< Group >( ElementRegionManager::groupKeyStruct::elementRegionsGroup );</br>37-}</br>38-</br>39-ElementRegionManager::~ElementRegionManager()</br>40-{</br>41:  // <emph>TODO</emph> Auto-generated destructor stub</br>42-}</br>43-</br>44-localIndex ElementRegionManager::numCellBlocks() const</br>45-{</br>46-  localIndex numCellBlocks = 0;</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/mesh/EmbeddedSurfaceSubRegion.cpp</h4><div id=script>199-void EmbeddedSurfaceSubRegion::CalculateElementGeometricQuantities( array1d< R1Tensor > const intersectionPoints,</br>200-                                                                    localIndex const k )</br>201-{</br>202-  for( localIndex p = 0; p < intersectionPoints.size(); p++ )</br>203-  {</br>204:    // <emph>TODO</emph> change to LvArray::tensorOps::add</br>205-    m_elementCenter( k, 0 ) += intersectionPoints[ p ][ 0 ];</br>206-    m_elementCenter( k, 1 ) += intersectionPoints[ p ][ 1 ];</br>207-    m_elementCenter( k, 2 ) += intersectionPoints[ p ][ 2 ];</br>208-  }</br>209-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/mesh/WellElementSubRegion.cpp</h4><div id=script>379-  SortedArray< globalIndex > & unownedElems = elemSetsByStatus[WellElemStatus::UNOWNED];</br>380-</br>381-  // here we make sure that there are no shared elements</br>382-  // this is enforced in the InternalWellGenerator that currently merges two perforations</br>383-  // if they belong to the same well element. This is a temporary solution.</br>384:  // <emph>TODO</emph>: split the well elements that contain multiple perforations, so that no element is shared</br>385-  GEOSX_ERROR_IF( sharedElems.size() > 0,</br>386-                  "Well " << getName() << " contains shared well elements" );</br>387-</br>388-</br>389-  // In Steps 1 and 2 we determine the local objects on this rank (elems and nodes)</br></br>591-        rankCount++;</br>592-      }</br>593-</br>594-    }</br>595-</br>596:    // <emph>TODO</emph>: check neighbor rank</br>597-  }</br>598-}</br>599-</br>600-void WellElementSubRegion::UpdateNodeManagerSize( MeshLevel & mesh,</br>601-                                                  InternalWellGenerator const & wellGeometry,</br></br>709-      {</br>710-        m_nextWellElementIndex[iwelemLocal] = -2; // remote elem</br>711-      }</br>712-    }</br>713-</br>714:    // <emph>TODO</emph> Change to LvArray::tensorOps::copy</br>715-    m_elementCenter[ iwelemLocal ][ 0 ] = elemCoordsGlobal[ iwelemGlobal ][ 0 ];</br>716-    m_elementCenter[ iwelemLocal ][ 1 ] = elemCoordsGlobal[ iwelemGlobal ][ 1 ];</br>717-    m_elementCenter[ iwelemLocal ][ 2 ] = elemCoordsGlobal[ iwelemGlobal ][ 2 ];</br>718-</br>719-    m_elementVolume[iwelemLocal] = elemVolumeGlobal[iwelemGlobal];</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/mesh/MeshBody.cpp</h4><div id=script>31-  registerWrapper< integer >( viewKeys.meshLevels );</br>32-}</br>33-</br>34-MeshBody::~MeshBody()</br>35-{</br>36:  // <emph>TODO</emph> Auto-generated destructor stub</br>37-}</br>38-</br>39-</br>40-</br>41-MeshLevel * MeshBody::CreateMeshLevel( localIndex const GEOSX_UNUSED_PARAM( newLevel ) )</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/mesh/BufferOps.cpp</h4><div id=script>263-            elemIndex = recvElemIndex;</br>264-            break;</br>265-          }</br>266-          else</br>267-          {</br>268:            //<emph>TODO</emph> need a better criteria and an error check here</br>269-          }</br>270-        }</br>271-      }</br>272-      else if( clearFlag )</br>273-      {</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/mesh/CellElementSubRegion.cpp</h4><div id=script>35-  registerWrapper( viewKeyStruct::detJString, &m_detJ )->setSizedFromParent( 1 )->reference();</br>36-}</br>37-</br>38-CellElementSubRegion::~CellElementSubRegion()</br>39-{</br>40:  // <emph>TODO</emph> Auto-generated destructor stub</br>41-}</br>42-</br>43-void CellElementSubRegion::CopyFromCellBlock( CellBlock * source )</br>44-{</br>45-  this->SetElementType( source->GetElementTypeString());</br></br>64-                                    [&]( auto type, auto GEOSX_UNUSED_PARAM( baseType ) )</br>65-    {</br>66-      using fieldType = decltype(type);</br>67-      dataRepository::Wrapper< fieldType > & field = dataRepository::Wrapper< fieldType >::cast( *wrapper );</br>68-      const fieldType & fieldref = field.reference();</br>69:      this->registerWrapper( wrapper->getName(), &const_cast< fieldType & >( fieldref ) ); //<emph>TODO</emph> remove const_cast</br>70-//      auto const & origFieldRef = field.reference();</br>71-//      fieldType & fieldRef = this->registerWrapper<fieldType>( wrapper->getName() )->reference();</br>72-//      fieldRef.resize( origFieldRef.size() );</br>73-    } );</br>74-  } );</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/mesh/CellElementRegion.cpp</h4><div id=script>162-    for( localIndex cellIndex = 0; cellIndex< elementSubRegion.size(); cellIndex++ )</br>163-    {</br>164-      if( ghostRank[cellIndex] >= 0 )</br>165-        continue;</br>166-</br>167:      // <emph>TODO</emph> Change the rest of this to</br>168-      // LvArray::tensorOps::scaledAdd< 3 >( aggregateBarycenters[ parts[ cellIndex + offsetSubRegions[ subRegionIndex ]</br>169-      // ] ],</br>170-      //                                     elementSubRegion.getElementCenter()[ cellIndex ],</br>171-      //                                     normalizeVolumes[ cellIndex + offsetSubRegions[ subRegionIndex ] ] )</br>172-      real64 const center[ 3 ] =</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/LvArray/cmake/blt/tests/internal/src/combine_static_library_test/Foo3.cpp</h4><div id=script>8-namespace blt_test</br>9-{</br>10-</br>11-Foo3::Foo3()</br>12-{</br>13:  // <emph>TODO</emph> Auto-generated constructor stub</br>14-</br>15-}</br>16-</br>17-Foo3::~Foo3()</br>18-{</br></br>14-</br>15-}</br>16-</br>17-Foo3::~Foo3()</br>18-{</br>19:  // <emph>TODO</emph> Auto-generated destructor stub</br>20-}</br>21-</br>22-std::string Foo3::output()</br>23-{</br>24-  return "I am Foo #3";</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/LvArray/cmake/blt/tests/internal/src/combine_static_library_test/Foo2.cpp</h4><div id=script>8-namespace blt_test</br>9-{</br>10-</br>11-Foo2::Foo2()</br>12-{</br>13:  // <emph>TODO</emph> Auto-generated constructor stub</br>14-</br>15-}</br>16-</br>17-Foo2::~Foo2()</br>18-{</br></br>14-</br>15-}</br>16-</br>17-Foo2::~Foo2()</br>18-{</br>19:  // <emph>TODO</emph> Auto-generated destructor stub</br>20-}</br>21-</br>22-std::string Foo2::output()</br>23-{</br>24-  return "I am Foo #2";</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/LvArray/cmake/blt/tests/internal/src/combine_static_library_test/Foo1.cpp</h4><div id=script>9-namespace blt_test</br>10-{</br>11-</br>12-Foo1::Foo1()</br>13-{</br>14:  // <emph>TODO</emph> Auto-generated constructor stub</br>15-</br>16-}</br>17-</br>18-Foo1::~Foo1()</br>19-{</br></br>15-</br>16-}</br>17-</br>18-Foo1::~Foo1()</br>19-{</br>20:  // <emph>TODO</emph> Auto-generated destructor stub</br>21-}</br>22-</br>23-std::string Foo1::output()</br>24-{</br>25-  return "I am Foo #1";</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/LvArray/unitTests/testBuffers.cpp</h4><div id=script>694-  this->insert( 100 );</br>695-  this->popBack( 100 );</br>696-}</br>697-</br>698-</br>699:// <emph>TODO</emph>:</br>700-// BufferTestNoRealloc on device with StackBuffer + MallocBuffer</br>701-// Move tests with ChaiBuffer</br>702-// Copy-capture tests with ChaiBuffer</br>703-</br>704-} // namespace testing</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/dataRepository/unitTests/testWrapperHelpers.cpp</h4><div id=script>114-  checkSizeMethod( std::array< int, 5 > {} );</br>115-  checkSizeMethod( array1d< int >( 5 ) );</br>116-  checkSizeMethod( array2d< int >( 5, 5 ) );</br>117-}</br>118-</br>119:/// <emph>TODO</emph>: dataPtr</br>120:/// <emph>TODO</emph>: resize</br>121:/// <emph>TODO</emph>: resizeDefault</br>122:/// <emph>TODO</emph>: resizeDimensions</br>123:/// <emph>TODO</emph>: byteSizeOfElement</br>124:/// <emph>TODO</emph>: byteSize</br>125:/// <emph>TODO</emph>: numElementsFromByteSize</br>126:/// <emph>TODO</emph>: reserve</br>127:/// <emph>TODO</emph>: capacity</br>128-</br>129-using ArrayTypes = ::testing::Types<</br>130-  array2d< int, RAJA::PERM_IJ ></br>131-  , array2d< double, RAJA::PERM_JI ></br>132-  , array3d< double, RAJA::PERM_IJK ></br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/fileIO/silo/SiloFile.cpp</h4><div id=script>1412-</br>1413-    elementRegion.forElementSubRegions( [&]( auto const & elementSubRegion )</br>1414-    {</br>1415-      typename TYPEOFREF( elementSubRegion ) ::NodeMapType const & elemsToNodes = elementSubRegion.nodeList();</br>1416-</br>1417:      // <emph>TODO</emph> HACK. this isn't correct for variable relations.</br>1418-      elementToNodeMap[count].resize( elemsToNodes.size( 0 ), elementSubRegion.numNodesPerElement( 0 ) );</br>1419-</br>1420-      arrayView1d< integer const > const & elemGhostRank = elementSubRegion.ghostRank();</br>1421-</br>1422-</br></br>1735-</br>1736-    }</br>1737-    else  //The old way</br>1738-    {</br>1739-      const int numFaceTypes = 1;</br>1740:      int numNodesPerFace = faceToNodeMap.sizeOfArray( 0 ); // <emph>TODO</emph> assumes all faces have same number of nodes</br>1741-      int dbZoneType = DB_ZONETYPE_POLYGON;</br>1742-      if( numNodesPerFace == 3 )</br>1743-      {</br>1744-        dbZoneType = DB_ZONETYPE_TRIANGLE;</br>1745-      }</br></br>2044-      // the field name is the key to the map</br>2045-      string const fieldName = wrapper->getName();</br>2046-</br>2047-      std::type_info const & typeID = wrapper->get_typeid();</br>2048-</br>2049:      // <emph>TODO</emph> This is wrong. problem with uniqueness</br>2050-      if( typeID==typeid(array1d< real64 >) )</br>2051-      {</br>2052-        auto const & wrapperT = dynamic_cast< dataRepository::Wrapper< array1d< real64 > > const & >( *wrapper );</br>2053-        this->WriteDataField< real64 >( meshname.c_str(), fieldName,</br>2054-                                        wrapperT.reference(), centering, cycleNum, problemTime, multiRoot );</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/managers/ProblemManager.cpp</h4><div id=script>528-    partition.setPartitions( xpar, ypar, zpar );</br>529-    int const mpiSize = MpiWrapper::Comm_size( MPI_COMM_GEOSX );</br>530-    // Case : Using MPI domain decomposition and partition are not defined (mainly pamela usage)</br>531-    if( mpiSize > 1 && xpar == 1 && ypar == 1 && zpar == 1 )</br>532-    {</br>533:      //<emph>TODO</emph>  confirm creates no issues with MPI_Cart_Create</br>534-      partition.setPartitions( 1, 1, mpiSize );</br>535-    }</br>536-  }</br>537-}</br>538-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/managers/FieldSpecification/FieldSpecificationManager.cpp</h4><div id=script>34-  return bcman;</br>35-}</br>36-</br>37-FieldSpecificationManager::~FieldSpecificationManager()</br>38-{</br>39:  // <emph>TODO</emph> Auto-generated destructor stub</br>40-}</br>41-</br>42-Group * FieldSpecificationManager::CreateChild( string const & childKey, string const & childName )</br>43-{</br>44-  std::unique_ptr< FieldSpecificationBase > bc = FieldSpecificationBase::CatalogInterface::Factory( childKey, childName, this );</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/managers/FieldSpecification/DirichletBoundaryCondition.cpp</h4><div id=script>23-using namespace dataRepository;</br>24-</br>25-DirichletBoundaryCondition::DirichletBoundaryCondition( string const & name, Group * const parent ):</br>26-  FieldSpecificationBase( name, parent )</br>27-{</br>28:  // <emph>TODO</emph> Auto-generated constructor stub</br>29-</br>30-}</br>31-</br>32-DirichletBoundaryCondition::~DirichletBoundaryCondition()</br>33-{</br></br>29-</br>30-}</br>31-</br>32-DirichletBoundaryCondition::~DirichletBoundaryCondition()</br>33-{</br>34:  // <emph>TODO</emph> Auto-generated destructor stub</br>35-}</br>36-</br>37-</br>38-</br>39-REGISTER_CATALOG_ENTRY( FieldSpecificationBase, DirichletBoundaryCondition, string const &, Group * const )</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/managers/FieldSpecification/SourceFluxBoundaryCondition.cpp</h4><div id=script>29-  m_normalizeBySetSize = true;</br>30-}</br>31-</br>32-SourceFluxBoundaryCondition::~SourceFluxBoundaryCondition()</br>33-{</br>34:  // <emph>TODO</emph> Auto-generated destructor stub</br>35-}</br>36-</br>37-void SourceFluxBoundaryCondition::InitializePreSubGroups( Group * const rootGroup )</br>38-{</br>39-  this->SetFieldName( viewKeyStruct::fluxBoundaryConditionString );</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/managers/Functions/FunctionManager.cpp</h4><div id=script>35-  setInputFlags( InputFlags::OPTIONAL );</br>36-}</br>37-</br>38-FunctionManager::~FunctionManager()</br>39-{</br>40:  // <emph>TODO</emph> Auto-generated destructor stub</br>41-}</br>42-</br>43-</br>44-Group * FunctionManager::CreateChild( string const & functionCatalogKey,</br>45-                                      string const & functionName )</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/managers/Functions/TableFunction.cpp</h4><div id=script>90-  T value;</br>91-</br>92-  GEOSX_ERROR_IF( !inputStream, "Could not read input file: " << filename );</br>93-</br>94-  // Read the file</br>95:  // <emph>TODO</emph>: Update this to handle large parallel jobs</br>96-  while( !inputStream.eof())</br>97-  {</br>98-    std::getline( inputStream, lineString );</br>99-    std::istringstream ss( lineString );</br>100-</br></br>228-        weights[ii][1] = 0;</br>229-      }</br>230-      else</br>231-      {</br>232-        // Find the coordinate index</br>233:        ///<emph>TODO</emph> make this fast</br>234-        // Note: lower_bound uses a binary search...  If we assume coordinates are</br>235-        // evenly spaced, we can speed things up considerably</br>236-        auto lower = std::lower_bound( m_coordinates[ii].begin(), m_coordinates[ii].end(), input[ii] );</br>237-        bounds[ii][1] = LvArray::integerConversion< localIndex >( std::distance( m_coordinates[ii].begin(), lower ));</br>238-        bounds[ii][0] = bounds[ii][1] - 1;</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/managers/Events/HaltEvent.cpp</h4><div id=script>62-  m_externalDt = currentTime - m_externalLastTime;</br>63-  m_externalLastTime = currentTime;</br>64-  integer forecast = static_cast< integer >((m_maxRuntime - (currentTime - m_externalStartTime)) / m_externalDt);</br>65-</br>66-  // The timing for the ranks may differ slightly, so synchronize</br>67:  // <emph>TODO</emph>: Only do the communication when you are close to the end?</br>68-#ifdef GEOSX_USE_MPI</br>69-  integer forecast_global;</br>70-  MPI_Allreduce( &forecast, &forecast_global, 1, MPI_INT, MPI_MIN, MPI_COMM_WORLD );</br>71-  forecast = forecast_global;</br>72-#endif</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/managers/Outputs/BlueprintOutput.cpp</h4><div id=script>168-  /// Create the points topology</br>169-  std::string const coordsetName = coordset.name();</br>170-  conduit::Node & nodeTopology = topologies[ coordsetName ];</br>171-  nodeTopology[ "coordset" ] = coordsetName;</br>172-</br>173:  /// <emph>TODO</emph>: Once VisIT supports the implicit "points" topology we can just do the following.</br>174-  /// See https://github.com/visit-dav/visit/issues/4593</br>175-  // nodeTopology[ "type" ] = "points";</br>176-</br>177-  nodeTopology[ "type" ] = "unstructured";</br>178-  nodeTopology[ "elements/shape" ] = "point";</br></br>249-      // field[ "association" ] = "element";</br>250-      // field[ "volume_dependent" ] = "false";</br>251-      // field[ "topology" ] = topology;</br>252-      // wrapper.populateMCArray( field[ "values" ] );</br>253-</br>254:      /// <emph>TODO</emph>: Replace with code above once https://github.com/visit-dav/visit/issues/4637 is fixed and released.</br>255-      wrapper.addBlueprintField( fields, name, topology );</br>256-    }</br>257-  } );</br>258-}</br>259-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/LinearSolverParameters.cpp</h4><div id=script>120-</br>121-  GEOSX_ERROR_IF_LT_MSG( m_parameters.amg.numSweeps, 0, "Invalid value of " << viewKeyStruct::amgNumSweepsString );</br>122-  GEOSX_ERROR_IF_LT_MSG( m_parameters.amg.threshold, 0.0, "Invalid value of " << viewKeyStruct::amgThresholdString );</br>123-  GEOSX_ERROR_IF_GT_MSG( m_parameters.amg.threshold, 1.0, "Invalid value of " << viewKeyStruct::amgThresholdString );</br>124-</br>125:  // <emph>TODO</emph> input validation for other AMG parameters ?</br>126-}</br>127-</br>128-REGISTER_CATALOG_ENTRY( Group, LinearSolverParametersInput, std::string const &, Group * const )</br>129-</br>130-} // namespace geosx</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/SolverBase.cpp</h4><div id=script>214-                                       real64 const & dt,</br>215-                                       integer const GEOSX_UNUSED_PARAM( cycleNumber ),</br>216-                                       DomainPartition & domain )</br>217-{</br>218-  // call setup for physics solver. Pre step allocations etc.</br>219:  // <emph>TODO</emph>: Nonlinear step does not call its own setup, need to decide on consistent behavior</br>220-  ImplicitStepSetup( time_n, dt, domain );</br>221-</br>222-  // zero out matrix/rhs before assembly</br>223-  m_localMatrix.setValues< parallelDevicePolicy<> >( 0.0 );</br>224-  m_localRhs.setValues< parallelDevicePolicy<> >( 0.0 );</br></br>252-</br>253-  // Output the linear system solution for debugging purposes</br>254-  DebugOutputSolution( 0.0, 0, 0, m_solution );</br>255-</br>256-  // Copy solution from parallel vector back to local</br>257:  // <emph>TODO</emph>: This step will not be needed when we teach LA vectors to wrap our pointers</br>258-  m_solution.extract( m_localSolution );</br>259-</br>260-  // apply the system solution to the fields/variables</br>261-  ApplySystemSolution( m_dofManager, m_localSolution, 1.0, domain );</br>262-</br></br>459-                               domain,</br>460-                               m_dofManager,</br>461-                               m_localMatrix.toViewConstSizes(),</br>462-                               m_localRhs.toView() );</br>463-</br>464:      // <emph>TODO</emph>: maybe add scale function here?</br>465-      // Scale()</br>466-</br>467-      // get residual norm</br>468-      real64 residualNorm = CalculateResidualNorm( domain, m_dofManager, m_localRhs.toViewConst() );</br>469-</br></br>546-</br>547-      // Output the linear system solution for debugging purposes</br>548-      DebugOutputSolution( time_n, cycleNumber, newtonIter, m_solution );</br>549-</br>550-      // Copy solution from parallel vector back to local</br>551:      // <emph>TODO</emph>: This step will not be needed when we teach LA vectors to wrap our pointers</br>552-      m_solution.extract( m_localSolution );</br>553-</br>554-      scaleFactor = ScalingForSystemSolution( domain, m_dofManager, m_localSolution );</br>555-</br>556-      if( !CheckSystemSolution( domain, m_dofManager, m_localSolution, scaleFactor ) )</br></br>553-</br>554-      scaleFactor = ScalingForSystemSolution( domain, m_dofManager, m_localSolution );</br>555-</br>556-      if( !CheckSystemSolution( domain, m_dofManager, m_localSolution, scaleFactor ) )</br>557-      {</br>558:        // <emph>TODO</emph> try chopping (similar to line search)</br>559-        GEOSX_LOG_RANK_0( "    Solution check failed. Newton loop terminated." );</br>560-        break;</br>561-      }</br>562-</br>563-      // apply the system solution to the fields/variables</br></br>777-//  std::cout<<rhs<<std::endl<<std::endl;</br>778-//  }</br>779-</br>780-  LinearSolverParameters const & params = m_linearSolverParameters.get();</br>781-</br>782:  // <emph>TODO</emph>: We probably want to keep an instance of linear solver as a member of physics solver</br>783-  //       so we can have constant access to last solve statistics, convergence history, etc.</br>784-  //       This requires unifying "LAI interface" solvers with "native" Krylov solvers somehow.</br>785-</br>786-  if( params.solverType == "direct" || !m_precond )</br>787-  {</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/fluidFlow/SinglePhaseProppantBase.cpp</h4><div id=script>33-  SinglePhaseBase( name, parent )</br>34-{}</br>35-</br>36-SinglePhaseProppantBase::~SinglePhaseProppantBase()</br>37-{</br>38:  // <emph>TODO</emph> Auto-generated destructor stub</br>39-}</br>40-</br>41-void SinglePhaseProppantBase::ValidateFluidModels( DomainPartition const & domain ) const</br>42-{</br>43-  // Validate fluid models in regions</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/fluidFlow/SinglePhaseFVM.cpp</h4><div id=script>210-                                                CRSMatrixView< real64, globalIndex const > const & localMatrix,</br>211-                                                arrayView1d< real64 > const & localRhs )</br>212-{</br>213-  GEOSX_MARK_FUNCTION;</br>214-</br>215:#if 1 // <emph>TODO</emph> why is this even here???</br>216-  if( !m_derivativeFluxResidual_dAperture )</br>217-  {</br>218-    m_derivativeFluxResidual_dAperture =</br>219-      std::make_unique< CRSMatrix< real64, localIndex > >( localMatrix.numRows(), localMatrix.numColumns() );</br>220-    m_derivativeFluxResidual_dAperture->setName( this->getName() + "/derivativeFluxResidual_dAperture" );</br></br>343-    BoundaryStencil::IndexContainerViewConstType const & seri = stencil.getElementRegionIndices();</br>344-    BoundaryStencil::IndexContainerViewConstType const & sesri = stencil.getElementSubRegionIndices();</br>345-    BoundaryStencil::IndexContainerViewConstType const & sefi = stencil.getElementIndices();</br>346-    BoundaryStencil::WeightContainerViewConstType const & trans = stencil.getWeights();</br>347-</br>348:    // <emph>TODO</emph>: currently we just use model from the first cell in this stencil</br>349-    //       since it's not clear how to create fluid kernel wrappers for arbitrary models.</br>350-    //       Can we just use cell properties for an approximate flux computation?</br>351-    //       Then we can forget about capturing the fluid model.</br>352-    SingleFluidBase & fluidBase = *constitutiveManager.GetConstitutiveRelation< SingleFluidBase >( regionFluidMap[seri( 0, 0 )] );</br>353-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/fluidFlow/FlowSolverBase.cpp</h4><div id=script>198-    arrayView1d< real64 > const & gravityCoef =</br>199-      faceManager.getReference< array1d< real64 > >( viewKeyStruct::gravityCoefString );</br>200-</br>201-    forAll< parallelHostPolicy >( faceManager.size(), [=] ( localIndex const kf )</br>202-    {</br>203:      // <emph>TODO</emph> change to LvArray::tensorOps::AiBi once gravVector is a c-array.</br>204-      gravityCoef[ kf ] = faceCenter[ kf ][ 0 ] * gravVector[ 0 ];</br>205-      gravityCoef[ kf ] += faceCenter[ kf ][ 1 ] * gravVector[ 1 ];</br>206-      gravityCoef[ kf ] += faceCenter[ kf ][ 2 ] * gravVector[ 2 ];</br>207-    } );</br>208-  }</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/fluidFlow/CompositionalMultiphaseFlow.cpp</h4><div id=script>808-   * Here we force the move by launching a dummy kernel.</br>809-   *</br>810-   * This is not a problem in normal solver execution, as these arrays get moved by AccumulationKernel.</br>811-   * But it fails unit tests, which test flux assembly separately.</br>812-   *</br>813:   * <emph>TODO</emph>: See if this can be fixed in NewChaiBuffer (I have not found a way - Sergey).</br>814-   *       Alternatively, stop using ElementViewAccessors altogether and just roll with</br>815-   *       accessors' outer arrays being moved on every jacobian assembly (maybe disable output).</br>816-   *       Or stop testing through the solver interface and test separate kernels instead.</br>817-   *       Finally, the problem should go away when fluid updates are executed on device.</br>818-   */</br></br>1087-                         string const &,</br>1088-                         SortedArrayView< localIndex const > const & targetSet,</br>1089-                         Group * const subRegion,</br>1090-                         string const & )</br>1091-  {</br>1092:    // <emph>TODO</emph>: hack! Find a better way to get the fluid</br>1093-    Group const * const region = subRegion->getParent()->getParent();</br>1094-    string const & fluidName = m_fluidModelNames[ targetRegionIndex( region->getName() ) ];</br>1095-    MultiFluidBase & fluid = GetConstitutiveModel< MultiFluidBase >( *subRegion, fluidName );</br>1096-</br>1097-    arrayView1d< integer const > const ghostRank =</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/fluidFlow/CompositionalMultiphaseFlowKernels.cpp</h4><div id=script>678-    for( localIndex idof = 0; idof < NDOF; ++idof )</br>679-    {</br>680-      dofIndices[idof] = dofNumber[ei] + idof;</br>681-    }</br>682-</br>683:    // <emph>TODO</emph>: apply equation/variable change transformation(s)</br>684-</br>685-    // add contribution to residual and jacobian</br>686-    for( localIndex i = 0; i < NC; ++i )</br>687-    {</br>688-      localRhs[localRow + i] += localAccum[i];</br></br>882-    }</br>883-</br>884-    // *** upwinding ***</br>885-</br>886-    // use PPU currently; advanced stuff like IHU would go here</br>887:    // <emph>TODO</emph> isolate into a kernel?</br>888-</br>889-    // compute phase potential gradient</br>890-    real64 const potGrad = presGrad - gravHead;</br>891-</br>892-    // choose upstream cell</br></br>897-    localIndex ei_up  = sei[k_up];</br>898-</br>899-    real64 const mobility = phaseMob[er_up][esr_up][ei_up][ip];</br>900-</br>901-    // skip the phase flux if phase not present or immobile upstream</br>902:    if( std::fabs( mobility ) < 1e-20 ) // <emph>TODO</emph> better constant</br>903-    {</br>904-      continue;</br>905-    }</br>906-</br>907-    // pressure gradient depends on all points in the stencil</br></br>1043-  localIndex constexpr MAX_STENCIL = STENCIL_TYPE::MAX_STENCIL_SIZE;</br>1044-  localIndex constexpr NDOF = NC + 1;</br>1045-</br>1046-  forAll< parallelDevicePolicy<> >( stencil.size(), [=] GEOSX_HOST_DEVICE ( localIndex const iconn )</br>1047-  {</br>1048:    // <emph>TODO</emph>: hack! for MPFA, etc. must obtain proper size from e.g. seri</br>1049-    localIndex const stencilSize = MAX_STENCIL;</br>1050-</br>1051-    stackArray1d< real64, NUM_ELEMS * NC >                      localFlux( NUM_ELEMS * NC );</br>1052-    stackArray2d< real64, NUM_ELEMS * NC * MAX_STENCIL * NDOF > localFluxJacobian( NUM_ELEMS * NC, stencilSize * NDOF );</br>1053-</br></br>1089-      {</br>1090-        dofColIndices[i * NDOF + jdof] = offset + jdof;</br>1091-      }</br>1092-    }</br>1093-</br>1094:    // <emph>TODO</emph>: apply equation/variable change transformation(s)</br>1095-</br>1096-    // Add to residual/jacobian</br>1097-    for( localIndex i = 0; i < NUM_ELEMS; ++i )</br>1098-    {</br>1099-      if( ghostRank[seri( iconn, i )][sesri( iconn, i )][sei( iconn, i )] < 0 )</br></br>1255-    for( localIndex jdof = 0; jdof < NDOF; ++jdof )</br>1256-    {</br>1257-      dofIndices[jdof] = dofNumber[ei] + jdof;</br>1258-    }</br>1259-</br>1260:    // <emph>TODO</emph>: apply equation/variable change transformation(s)</br>1261-</br>1262-    // add contribution to residual and jacobian</br>1263-    localRhs[localRow] += localVolBalance;</br>1264-    localMatrix.addToRow< serialAtomic >( localRow,</br>1265-                                          dofIndices,</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/fluidFlow/wells/CompositionalMultiphaseWell.cpp</h4><div id=script>497-    // Note: I am leaving that here because I would like to use the perforationRates (computed in UpdateState)</br>498-    //       to better initialize the rates</br>499-    UpdateState( subRegion, targetIndex );</br>500-</br>501-    // 6) Estimate the well rates</br>502:    // <emph>TODO</emph>: initialize rates using perforation rates</br>503-    SinglePhaseWellKernels::RateInitializationKernel::Launch< parallelDevicePolicy<> >( subRegion.size(),</br>504-                                                                                        wellControls,</br>505-                                                                                        connRate );</br>506-</br>507-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/multiphysics/ReservoirSolverBase.cpp</h4><div id=script>122-void ReservoirSolverBase::SetupDofs( DomainPartition const & domain,</br>123-                                     DofManager & dofManager ) const</br>124-{</br>125-  m_flowSolver->SetupDofs( domain, dofManager );</br>126-  m_wellSolver->SetupDofs( domain, dofManager );</br>127:  // <emph>TODO</emph>: add coupling when dofManager can support perforation connectors</br>128-}</br>129-</br>130-void ReservoirSolverBase::AddCouplingNumNonzeros( DomainPartition & domain,</br>131-                                                  DofManager & dofManager,</br>132-                                                  arrayView1d< localIndex > const & rowLengths ) const</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/multiphysics/SinglePhaseReservoir.cpp</h4><div id=script>49-  GEOSX_MARK_FUNCTION;</br>50-</br>51-  MeshLevel const & meshLevel = *domain.getMeshBody( 0 )->getMeshLevel( 0 );</br>52-  ElementRegionManager const & elemManager = *meshLevel.getElemManager();</br>53-</br>54:  // <emph>TODO</emph>: remove this and just call SolverBase::SetupSystem when DofManager can handle the coupling</br>55-</br>56-  // Populate off-diagonal sparsity between well and reservoir</br>57-</br>58-  string const resDofKey  = dofManager.getKey( m_wellSolver->ResElementDofName() );</br>59-  string const wellDofKey = dofManager.getKey( m_wellSolver->WellElementDofName() );</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/multiphysics/CompositionalMultiphaseReservoir.cpp</h4><div id=script>50-  GEOSX_MARK_FUNCTION;</br>51-</br>52-  MeshLevel const & meshLevel = *domain.getMeshBody( 0 )->getMeshLevel( 0 );</br>53-  ElementRegionManager const & elemManager = *meshLevel.getElemManager();</br>54-</br>55:  // <emph>TODO</emph>: remove this and just call SolverBase::SetupSystem when DofManager can handle the coupling</br>56-</br>57-  // Populate off-diagonal sparsity between well and reservoir</br>58-</br>59-  localIndex const resNDOF = m_wellSolver->NumDofPerResElement();</br>60-  localIndex const wellNDOF = m_wellSolver->NumDofPerWellElement();</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/multiphysics/PoroelasticSolver.cpp</h4><div id=script>196-  }</br>197-}</br>198-</br>199-PoroelasticSolver::~PoroelasticSolver()</br>200-{</br>201:  // <emph>TODO</emph> Auto-generated destructor stub</br>202-}</br>203-</br>204-void PoroelasticSolver::ResetStateToBeginningOfStep( DomainPartition & domain )</br>205-{</br>206-  m_flowSolver->ResetStateToBeginningOfStep( domain );</br></br>303-    localIndex const numNodesPerElement = elemsToNodes.size( 1 );</br>304-    finiteElement::FiniteElementBase const &</br>305-    fe = elementSubRegion.getReference< finiteElement::FiniteElementBase >( m_solidSolver->getDiscretizationName() );</br>306-    localIndex const numQuadraturePoints = fe.getNumQuadraturePoints();</br>307-</br>308:    // <emph>TODO</emph>: remove use of R1Tensor and use device policy</br>309-    forAll< parallelDevicePolicy< 32 > >( elementSubRegion.size(), [=] GEOSX_HOST_DEVICE ( localIndex const ei )</br>310-    {</br>311-      real64 effectiveMeanStress = 0.0;</br>312-      for( localIndex q=0; q<numQuadraturePoints; ++q )</br>313-      {</br></br>416-    real64 const biotCoefficient = solid.getReference< real64 >( "BiotCoefficient" );</br>417-</br>418-    arrayView2d< real64 const > const & density = fluid.density();</br>419-</br>420-    int dim = 3;</br>421:    localIndex constexpr maxNumUDof = 24; // <emph>TODO</emph>: assuming linear HEX at most for the moment</br>422:    localIndex constexpr maxNumPDof = 1; // <emph>TODO</emph>: assuming piecewise constant (P0) only for the moment</br>423-    localIndex const nUDof = dim * numNodesPerElement;</br>424-    localIndex const nPDof = m_flowSolver->numDofPerCell();</br>425-    GEOSX_ERROR_IF_GT( nPDof, maxNumPDof );</br>426-</br>--</br>423-    localIndex const nUDof = dim * numNodesPerElement;</br>424-    localIndex const nPDof = m_flowSolver->numDofPerCell();</br>425-    GEOSX_ERROR_IF_GT( nPDof, maxNumPDof );</br>426-</br>427:    // <emph>TODO</emph>: remove use of R1Tensor and use device policy</br>428-    forAll< parallelDevicePolicy< 32 > >( elementSubRegion.size(), [=] GEOSX_HOST_DEVICE ( localIndex const k )</br>429-    {</br>430-      stackArray2d< real64, maxNumUDof * maxNumPDof > dRsdP( nUDof, nPDof );</br>431-      stackArray2d< real64, maxNumUDof * maxNumPDof > dRfdU( nPDof, nUDof );</br>432-      stackArray1d< real64, maxNumPDof > Rf( nPDof );</br></br>557-</br>558-    m_precond = std::move( precond );</br>559-  }</br>560-  else</br>561-  {</br>562:    //<emph>TODO</emph>: Revisit this part such that is coherent across physics solver</br>563-    //m_precond = LAInterface::createPreconditioner( m_linearSolverParameters.get() );</br>564-  }</br>565-}</br>566-</br>567-void PoroelasticSolver::SolveSystem( DofManager const & dofManager,</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/multiphysics/LagrangianContactSolver.cpp</h4><div id=script>231-void LagrangianContactSolver::InitializePostInitialConditions_PreSubGroups( Group * const GEOSX_UNUSED_PARAM( problemManager ) )</br>232-{}</br>233-</br>234-LagrangianContactSolver::~LagrangianContactSolver()</br>235-{</br>236:  // <emph>TODO</emph> Auto-generated destructor stub</br>237-}</br>238-</br>239-void LagrangianContactSolver::ComputeTolerances( DomainPartition & domain ) const</br>240-{</br>241-  GEOSX_MARK_FUNCTION;</br></br>575-                                 domain,</br>576-                                 m_dofManager,</br>577-                                 m_localMatrix.toViewConstSizes(),</br>578-                                 m_localRhs.toView() );</br>579-</br>580:        // <emph>TODO</emph>: maybe add scale function here?</br>581-        // Scale()</br>582-</br>583-        real64 residualNorm;</br>584-        // get residual norm</br>585-        if( computeResidual )</br></br>633-</br>634-        // Output the linear system solution for debugging purposes</br>635-        DebugOutputSolution( time_n, cycleNumber, newtonIter, m_solution );</br>636-</br>637-        // Copy solution from parallel vector back to local</br>638:        // <emph>TODO</emph>: This step will not be needed when we teach LA vectors to wrap our pointers</br>639-        m_solution.extract( m_localSolution );</br>640-</br>641-        scaleFactor = ScalingForSystemSolution( domain, m_dofManager, m_localSolution );</br>642-</br>643-        // do line search in case residual has increased</br></br>678-          computeResidual = true;</br>679-        }</br>680-</br>681-        if( !CheckSystemSolution( domain, m_dofManager, m_localSolution.toViewConst(), scaleFactor ) )</br>682-        {</br>683:          // <emph>TODO</emph> try chopping (similar to line search)</br>684-          GEOSX_LOG_RANK_0( "    Solution check failed. Newton loop terminated." );</br>685-          break;</br>686-        }</br>687-</br>688-        lastResidual = residualNorm;</br></br>839-    lamm = lamc;</br>840-    lamc = localScaleFactor;</br>841-</br>842-    // Keep the books on the function norms</br>843-    // re-assemble system</br>844:    // <emph>TODO</emph>: add a flag to avoid a completely useless Jacobian computation: rhs is enough</br>845-    localMatrix.setValues< parallelHostPolicy >( 0.0 );</br>846-    localRhs.setValues< parallelHostPolicy >( 0.0 );</br>847-    AssembleSystem( time_n, dt, domain, dofManager, localMatrix, localRhs );</br>848-</br>849-    // apply boundary conditions to system</br></br>1442-          // Get fracture, face and region/subregion/element indices (for elements on both sides)</br>1443-          localIndex const fractureIndex = sei[iconn][kf];</br>1444-</br>1445-          localIndex const faceIndexRef = faceMap[fractureIndex][0];</br>1446-          real64 const area = faceArea[faceIndexRef];</br>1447:          // <emph>TODO</emph>: use higher order integration scheme</br>1448-          nodalArea[kf][0] = area / 4.0;</br>1449-          nodalArea[kf][1] = area / 4.0;</br>1450-</br>1451-          real64 invStiffApprox[ 2 ][ 3 ];</br>1452-          for( localIndex i = 0; i < 2; ++i )</br></br>1654-          stackArray2d< real64, 3*3 > const & totalInvStiffApproxDiag = ( kf == 0 ) ? totalInvStiffApprox00 : totalInvStiffApprox11;</br>1655-          stackArray2d< real64, 3*3 > const & totalInvStiffApproxOffDiag = ( kf == 0 ) ? totalInvStiffApprox01 : totalInvStiffApprox10;</br>1656-          stackArray1d< real64, 3 > const & rhs = ( kf == 0 ) ? rhs0 : rhs1;</br>1657-</br>1658-          // Only assemble contribution if "row" fracture element is local</br>1659:          // <emph>TODO</emph>: use parallel atomics</br>1660-          if( localRow >= 0 && localRow < localMatrix.numRows() )</br>1661-          {</br>1662-            for( localIndex idof = 0; idof < nDof[kf]; ++idof )</br>1663-            {</br>1664-              // (i,i)-block</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/multiphysics/HydrofractureSolver.cpp</h4><div id=script>170-void HydrofractureSolver::InitializePostInitialConditions_PreSubGroups( Group * const GEOSX_UNUSED_PARAM( problemManager ) )</br>171-{}</br>172-</br>173-HydrofractureSolver::~HydrofractureSolver()</br>174-{</br>175:  // <emph>TODO</emph> Auto-generated destructor stub</br>176-}</br>177-</br>178-void HydrofractureSolver::ResetStateToBeginningOfStep( DomainPartition & domain )</br>179-{</br>180-  m_flowSolver->ResetStateToBeginningOfStep( domain );</br></br>319-      {</br>320-        LvArray::tensorOps::add< 3 >( temp, u[ faceToNodeMap( kf0, a ) ] );</br>321-        LvArray::tensorOps::subtract< 3 >( temp, u[ faceToNodeMap( kf1, a ) ] );</br>322-      }</br>323-</br>324:      // <emph>TODO</emph> this needs a proper contact based strategy for aperture</br>325-      aperture[kfe] = -LvArray::tensorOps::AiBi< 3 >( temp, faceNormal[ kf0 ] ) / numNodesPerFace;</br>326-</br>327-      effectiveAperture[kfe] = contactRelation->effectiveAperture( aperture[kfe] );</br>328-</br>329-</br></br>1059-            localIndex const localRow = LvArray::integerConversion< localIndex >( rowDOF[3*a] - dispRankOffset );</br>1060-            if( localRow >= 0 && localRow < rhs0.size() )</br>1061-            {</br>1062-              for( int i=0; i<3; ++i )</br>1063-              {</br>1064:                // <emph>TODO</emph>: use parallel atomic when loop is parallel</br>1065-                RAJA::atomicAdd( serialAtomic{}, &rhs0[localRow + i], nodeRHS[3*a+i] );</br>1066-              }</br>1067-            }</br>1068-          }</br>1069-</br></br>1615-    Thyra::SolveStatus< double > status = solver->solve( Thyra::NOTRANS, *rhs, lhs.ptr());</br>1616-</br>1617-    GEOSX_MARK_END( SOLVER );</br>1618-    double solveTime = clock.stop();</br>1619-</br>1620:    /* <emph>TODO</emph>: replace with SolverBase status output */</br>1621-</br>1622-    integer numKrylovIter = status.extraParameters->get< int >( "Iteration Count" );</br>1623-    if( getLogLevel()>=2 )</br>1624-    {</br>1625-      GEOSX_LOG_RANK_0( "\t\tLinear Solver | Iter = " << numKrylovIter <<</br></br>1634-    p_rhs[1]->Scale( 1/(m_pressureScaling*m_densityScaling));</br>1635-  }</br>1636-</br>1637-  delete schurApproxPP;</br>1638-</br>1639:  //<emph>TODO</emph>: remove all this once everything is working</br>1640-  if( getLogLevel() == 2 )</br>1641-  {</br>1642-    /*</br>1643-       ParallelVector permutedSol;</br>1644-       ParallelVector const & solution = m_solidSolver->getSystemSolution();</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/surfaceGeneration/SurfaceGenerator.cpp</h4><div id=script>220-</br>221-}</br>222-</br>223-SurfaceGenerator::~SurfaceGenerator()</br>224-{</br>225:  // <emph>TODO</emph> Auto-generated destructor stub</br>226-}</br>227-</br>228-void SurfaceGenerator::RegisterDataOnMesh( Group * const MeshBodies )</br>229-{</br>230-  for( auto & mesh : MeshBodies->GetSubGroups() )</br></br>337-    MeshLevel * meshLevel = Group::group_cast< MeshBody * >( mesh.second )->getMeshLevel( 0 );</br>338-    FaceManager * const faceManager = meshLevel->getFaceManager();</br>339-    ElementRegionManager * const elementManager = meshLevel->getElemManager();</br>340-    arrayView2d< real64 const > const & faceNormals = faceManager->faceNormal();</br>341-</br>342:    //<emph>TODO</emph>: roughness to KIC should be made a material constitutive relationship.</br>343-    arrayView1d< R1Tensor > const & KIC = faceManager->getReference< r1_array >( "K_IC" );</br>344-</br>345-    for( localIndex kf=0; kf<faceManager->size(); ++kf )</br>346-    {</br>347-      if( m_rockToughness >= 0 )</br></br>663-        for( localIndex a = 0; a < numNodesInFace; ++a )</br>664-        {</br>665-          localIndex const aa = a < 2 ? a : numNodesInFace - a + 1;</br>666-          localIndex const bb = aa == 0 ? aa : numNodesInFace - aa;</br>667-</br>668:          // <emph>TODO</emph> HACK need to generalize to something other than quads</br>669-          //wu40: I temporarily make it work for tet mesh. Need further check with Randy.</br>670-          nodeMap[ kfe ][ a ]   = faceToNodeMap( faceMap[ kfe ][ 0 ], aa );</br>671-          nodeMap[ kfe ][ a + numNodesInFace ] = faceToNodeMap( faceMap[ kfe ][ 1 ], bb );</br>672-        }</br>673-</br></br>1684-  m_tipNodes.remove( nodeID );</br>1685-  nodeDegreeFromCrackTip( nodeID ) = 1;</br>1686-  nodeRuptureTime( nodeID ) = time_np1;</br>1687-  nodeRuptureTime( newNodeIndex ) = time_np1;</br>1688-</br>1689:  //<emph>TODO</emph> HACK...should recalculate mass</br>1690-//  const real64 newMass = 0.5 * (*nodeManager.m_mass)[nodeID];</br>1691-//  (*nodeManager.m_mass)[nodeID] = newMass;</br>1692-//  (*nodeManager.m_mass)[newNodeIndex] = newMass;</br>1693-</br>--</br>1690-//  const real64 newMass = 0.5 * (*nodeManager.m_mass)[nodeID];</br>1691-//  (*nodeManager.m_mass)[nodeID] = newMass;</br>1692-//  (*nodeManager.m_mass)[newNodeIndex] = newMass;</br>1693-</br>1694:  //<emph>TODO</emph> Either change m_usedFacesForNode to array<std::set> or add insert with iterator to SortedArray</br>1695-  for( auto const val : separationPathFaces )</br>1696-  {</br>1697-    m_usedFacesForNode[nodeID].insert( val );</br>1698-    m_usedFacesForNode[newNodeIndex].insert( val );</br>1699-  }</br></br>2565-    {</br>2566-</br>2567-      std::vector< std::pair< CellElementSubRegion const *, localIndex > > faceToElements;</br>2568-      for( localIndex k=0; k<faceToRegionMap.size( 1 ); ++k )</br>2569-      {</br>2570:        // <emph>TODO</emph> This only works for a single region</br>2571-        if( faceToRegionMap( a, k ) != -1 )</br>2572-        {</br>2573-          faceToElements.emplace_back( elementManager.GetRegion( faceToRegionMap( a, k ) )-></br>2574-                                         GetSubRegion< CellElementSubRegion >( faceToSubRegionMap( a, k ) ),</br>2575-                                       faceToElementMap( a, k ) );</br></br>2624-realT SurfaceGenerator::CalculateKinkAngle ( const localIndex edgeID,</br>2625-                                             const NodeManager & GEOSX_UNUSED_PARAM( nodeManager ),</br>2626-                                             EdgeManager & edgeManager,</br>2627-                                             FaceManager & faceManager )</br>2628-{</br>2629:  // <emph>TODO</emph>: This method should be re-implemented.</br>2630-  localIndex_array faces;</br>2631-  // realT kinkAngle;</br>2632-</br>2633-  arrayView1d< integer const > const & faceIsExternal = faceManager.isExternal();</br>2634-</br></br>2876-  for( localIndex const trailingFaceIndex : m_trailingFaces )</br>2877-//  RAJA::forall< parallelHostPolicy >( RAJA::TypedRangeSegment< localIndex >( 0, m_trailingFaces.size() ),</br>2878-//                                      [=] GEOSX_HOST_DEVICE ( localIndex const trailingFacesCounter )</br>2879-  {</br>2880-//    localIndex const trailingFaceIndex = m_trailingFaces[ trailingFacesCounter ];</br>2881:    R1Tensor faceNormalVector = faceNormal[trailingFaceIndex];//<emph>TODO</emph>: check if a ghost face still has the correct</br>2882-                                                              // attributes such as normal vector, face center, face</br>2883-                                                              // index.</br>2884-    localIndex_array unpinchedNodeID;</br>2885-    localIndex_array pinchedNodeID;</br>2886-    localIndex_array tipEdgesID;</br></br>2954-                //wu40: the nodal force need to be weighted by Young's modulus and possion's ratio.</br>2955-                temp *= youngsModulus;</br>2956-                temp /= (1 - poissonRatio * poissonRatio);</br>2957-</br>2958-                xEle -= nodePosition;</br>2959:                if( Dot( xEle, faceNormalVector ) > 0 ) //<emph>TODO</emph>: check the sign.</br>2960-                {</br>2961-                  nElemEachSide[0] += 1;</br>2962-                  nodeDisconnectForce += temp;</br>2963-                }</br>2964-                else</br></br>3059-</br>3060-            fExternal[i] = fext[nodeID];</br>3061-            fExternal[i] *= averageYoungsModulus / (1 - averagePoissonRatio * averagePoissonRatio);</br>3062-          }</br>3063-</br>3064:          //<emph>TODO</emph>: The sign of fext here is opposite to the sign of fFaceA in function "CalculateEdgeSIF".</br>3065-          tipNodeForce[0] = nodeDisconnectForce[0] - ( fExternal[0][0] - fExternal[1][0] ) / 2.0;</br>3066-          tipNodeForce[1] = nodeDisconnectForce[1] - ( fExternal[0][1] - fExternal[1][1] ) / 2.0;</br>3067-          tipNodeForce[2] = nodeDisconnectForce[2] - ( fExternal[0][2] - fExternal[1][2] ) / 2.0;</br>3068-</br>3069-//          tipNodeForce[0] = nodeDisconnectForce[0];</br></br>3276-</br>3277-  vecTipNorm = faceNormal[faceA];</br>3278-  vecTipNorm -= faceNormal[faceAp];</br>3279-  vecTipNorm.Normalize();</br>3280-</br>3281:  //<emph>TODO</emph>: wu40: There is a function for EdgeVector in EdgeManager.cpp but has been commented.</br>3282-  R1Tensor vecEdge = edgeManager.calculateLength( edgeID, X );</br>3283-  realT const edgeLength = vecEdge.Normalize();</br>3284-</br>3285-  vecTip.Cross( vecTipNorm, vecEdge );</br>3286-  vecTip.Normalize();</br></br>3492-    localIndex trailingEdge;</br>3493-    trailingEdge = std::numeric_limits< localIndex >::max();</br>3494-</br>3495-    if( trailingNodes.size() == 2 )</br>3496-    {</br>3497:      //wu40: <emph>TODO</emph>: This check is from GEOS. I think this may not be necessary. Check with Randy and PC.</br>3498-      if( trailingNodes[0] != trailingNodes[1] )</br>3499-      {</br>3500-        for( localIndex const iedge : nodeToEdgeMap[ trailingNodes[ 0 ] ] )</br>3501-        {</br>3502-          if( edgeToNodeMap[iedge][0] == trailingNodes[1] || edgeToNodeMap[iedge][1] == trailingNodes[1] )</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/simplePDE/LaplaceFEM.cpp</h4><div id=script>64-}</br>65-//END_SPHINX_INCLUDE_01</br>66-</br>67-LaplaceFEM::~LaplaceFEM()</br>68-{</br>69:  // <emph>TODO</emph> Auto-generated destructor stub</br>70-}</br>71-</br>72-</br>73-//START_SPHINX_INCLUDE_02</br>74-void LaplaceFEM::RegisterDataOnMesh( Group * const MeshBodies )</br></br>281-void LaplaceFEM::SolveSystem( DofManager const & dofManager,</br>282-                              ParallelMatrix & matrix,</br>283-                              ParallelVector & rhs,</br>284-                              ParallelVector & solution )</br>285-{</br>286:  rhs.scale( -1.0 ); // <emph>TODO</emph> decide if we want this here</br>287-  solution.zero();</br>288-</br>289-  SolverBase::SolveSystem( dofManager, matrix, rhs, solution );</br>290-}</br>291-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/solidMechanics/SolidMechanicsEmbeddedFractures.cpp</h4><div id=script>57-</br>58-}</br>59-</br>60-SolidMechanicsEmbeddedFractures::~SolidMechanicsEmbeddedFractures()</br>61-{</br>62:  // <emph>TODO</emph> Auto-generated destructor stub</br>63-}</br>64-</br>65-void SolidMechanicsEmbeddedFractures::RegisterDataOnMesh( dataRepository::Group * const MeshBodies )</br>66-{</br>67-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/solidMechanics/SolidMechanicsLagrangianFEM.cpp</h4><div id=script>148-  linParams.amg.separateComponents = true;</br>149-}</br>150-</br>151-SolidMechanicsLagrangianFEM::~SolidMechanicsLagrangianFEM()</br>152-{</br>153:  // <emph>TODO</emph> Auto-generated destructor stub</br>154-}</br>155-</br>156-</br>157-void SolidMechanicsLagrangianFEM::RegisterDataOnMesh( Group * const MeshBodies )</br>158-{</br></br>846-</br>847-    arrayView3d< real64 const, solid::STRESS_USD > const & stress = constitutiveRelation.getStress();</br>848-</br>849-    array3d< real64, solid::STRESS_PERMUTATION > &</br>850-    stress_n = subRegion.getReference< array3d< real64, solid::STRESS_PERMUTATION > >( viewKeyStruct::stress_n );</br>851:    // <emph>TODO</emph>: eliminate</br>852-    stress_n.resize( stress.size( 0 ), stress.size( 1 ), 6 );</br>853-</br>854-    arrayView3d< real64, solid::STRESS_USD > const & vstress_n = stress_n.toView();</br>855-</br>856-    forAll< parallelDevicePolicy<> >( stress.size( 0 ), [=] GEOSX_HOST_DEVICE ( localIndex const k )</br></br>1066-  {</br>1067-    bc->ApplyBoundaryConditionToSystem< FieldSpecificationAdd,</br>1068-                                        parallelDevicePolicy< 32 > >( targetSet,</br>1069-                                                                      time_n + dt,</br>1070-                                                                      targetGroup,</br>1071:                                                                      keys::TotalDisplacement, // <emph>TODO</emph> fix use of dummy</br>1072-                                                                                               // name</br>1073-                                                                      dofKey,</br>1074-                                                                      dofManager.rankOffset(),</br>1075-                                                                      localMatrix,</br>1076-                                                                      localRhs );</br></br>1209-  NodeManager & nodeManager = *mesh.getNodeManager();</br>1210-</br>1211-  arrayView2d< real64, nodes::INCR_DISPLACEMENT_USD > const & incdisp  = nodeManager.incrementalDisplacement();</br>1212-  arrayView2d< real64, nodes::TOTAL_DISPLACEMENT_USD > const & disp = nodeManager.totalDisplacement();</br>1213-</br>1214:  // <emph>TODO</emph> need to finish this rewind</br>1215-  forAll< parallelDevicePolicy< 32 > >( nodeManager.size(), [=] GEOSX_HOST_DEVICE ( localIndex const a )</br>1216-  {</br>1217-    for( localIndex i = 0; i < 3; ++i )</br>1218-    {</br>1219-      disp( a, i ) -= incdisp( a, i );</br></br>1284-</br>1285-    string const dofKey = dofManager.getKey( keys::TotalDisplacement );</br>1286-    arrayView1d< globalIndex > const & nodeDofNumber = nodeManager->getReference< globalIndex_array >( dofKey );</br>1287-    globalIndex const rankOffset = dofManager.rankOffset();</br>1288-</br>1289:    // <emph>TODO</emph>: this bound may need to change</br>1290-    constexpr localIndex maxNodexPerFace = 4;</br>1291-    constexpr localIndex maxDofPerElem = maxNodexPerFace * 3 * 2;</br>1292-</br>1293-    elemManager->forElementSubRegions< FaceElementSubRegion >( [&]( FaceElementSubRegion & subRegion )</br>1294-    {</br></br>1293-    elemManager->forElementSubRegions< FaceElementSubRegion >( [&]( FaceElementSubRegion & subRegion )</br>1294-    {</br>1295-      arrayView1d< real64 > const & area = subRegion.getElementArea();</br>1296-      arrayView2d< localIndex const > const & elemsToFaces = subRegion.faceList();</br>1297-</br>1298:      // <emph>TODO</emph>: use parallel policy?</br>1299-      forAll< serialPolicy >( subRegion.size(), [=] ( localIndex const kfe )</br>1300-      {</br>1301-        R1Tensor Nbar = faceNormal[elemsToFaces[kfe][0]];</br>1302-        Nbar -= faceNormal[elemsToFaces[kfe][1]];</br>1303-        Nbar.Normalize();</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/physicsSolvers/GEOSX_PTP/ParallelTopologyChange.cpp</h4><div id=script>627-                                             localIndex_array & ghostsToSend,</br>628-                                             localIndex_array & objectsToSend )</br>629-{</br>630-</br>631-  ghostsToSend.move( LvArray::MemorySpace::CPU );</br>632:  //<emph>TODO</emph> this needs to be inverted since the ghostToSend list should be much longer....</br>633-  // and the objectList is a searchable set.</br>634-  for( auto const index : objectList )</br>635-  {</br>636-    localIndex const parentIndex = parentIndices[index];</br>637-    for( localIndex a=0; a<ghostsToSend.size(); ++a )</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/mpiCommunications/CommunicationTools.cpp</h4><div id=script>32-</br>33-using namespace dataRepository;</br>34-</br>35-CommunicationTools::CommunicationTools()</br>36-{</br>37:  // <emph>TODO</emph> Auto-generated constructor stub</br>38-}</br>39-</br>40-CommunicationTools::~CommunicationTools()</br>41-{</br>--</br>38-}</br>39-</br>40-CommunicationTools::~CommunicationTools()</br>41-{</br>42:  // <emph>TODO</emph> Auto-generated destructor stub</br>43-}</br>44-</br>45-</br>46-std::set< int > & CommunicationTools::getFreeCommIDs()</br>47-{</br></br>323-}</br>324-</br>325-void CommunicationTools::AssignNewGlobalIndices( ObjectManagerBase & object,</br>326-                                                 std::set< localIndex > const & indexList )</br>327-{</br>328:  // <emph>TODO</emph>: This should be done with a prefix sum!</br>329-  int const thisRank = MpiWrapper::Comm_rank( MPI_COMM_GEOSX );</br>330-  int const commSize = MpiWrapper::Comm_size( MPI_COMM_GEOSX );</br>331-  localIndex numberOfNewObjectsHere = indexList.size();</br>332-  localIndex_array numberOfNewObjects( commSize );</br>333-  localIndex_array glocalIndexOffset( commSize );</br></br>361-void</br>362-CommunicationTools::</br>363-  AssignNewGlobalIndices( ElementRegionManager & elementManager,</br>364-                          std::map< std::pair< localIndex, localIndex >, std::set< localIndex > > const & newElems )</br>365-{</br>366:  // <emph>TODO</emph>: This should be done with a prefix sum!</br>367-  int const thisRank = MpiWrapper::Comm_rank( MPI_COMM_GEOSX );</br>368-  int const commSize = MpiWrapper::Comm_size( MPI_COMM_GEOSX );</br>369-</br>370-  localIndex numberOfNewObjectsHere = 0;</br>371-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/meshUtilities/InternalMeshGenerator.cpp</h4><div id=script>125-</br>126-}</br>127-</br>128-InternalMeshGenerator::~InternalMeshGenerator()</br>129-{</br>130:  // <emph>TODO</emph> Auto-generated destructor stub</br>131-}</br>132-</br>133-</br>134-/**</br>135- * @param domain</br></br>473-        }</br>474-      }</br>475-    }</br>476-  }</br>477-</br>478:  // <emph>TODO</emph> This needs to be rewritten for dimensions lower than 3.</br>479-  localIndex regionOffset = 0;</br>480-  for( int iblock = 0; iblock < m_nElems[0].size(); ++iblock )</br>481-  {</br>482-    for( int jblock = 0; jblock < m_nElems[1].size(); ++jblock )</br>483-    {</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/meshUtilities/PAMELAMeshGenerator.cpp</h4><div id=script>32-</br>33-namespace geosx</br>34-{</br>35-using namespace dataRepository;</br>36-</br>37:/// <emph>TODO</emph> when we are going to port to c++17, we can remove that</br>38-string const PAMELAMeshGenerator::DecodePAMELALabels::m_separator = "_";</br>39-</br>40-PAMELAMeshGenerator::PAMELAMeshGenerator( string const & name, Group * const parent ):</br>41-  MeshGeneratorBase( name, parent )</br>42-{</br></br>94-  GEOSX_LOG_RANK_0( "Writing into the GEOSX mesh data structure" );</br>95-  domain->getMetisNeighborList() = m_pamelaMesh->getNeighborList();</br>96-  Group * const meshBodies = domain->GetGroup( std::string( "MeshBodies" ));</br>97-  MeshBody * const meshBody = meshBodies->RegisterGroup< MeshBody >( this->getName() );</br>98-</br>99:  //<emph>TODO</emph> for the moment we only consider on mesh level "Level0"</br>100-  MeshLevel * const meshLevel0 = meshBody->RegisterGroup< MeshLevel >( std::string( "Level0" ));</br>101-  NodeManager * nodeManager = meshLevel0->getNodeManager();</br>102-  CellBlockManager * cellBlockManager = domain->GetGroup< CellBlockManager >( keys::cellManager );</br>103-</br>104-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/meshUtilities/VTMMeshGenerator.cpp</h4><div id=script>54-    setDescription( "path to the vtm file" );</br>55-}</br>56-</br>57-VTMMeshGenerator::~VTMMeshGenerator()</br>58-{</br>59:  // <emph>TODO</emph> Auto-generated destructor stub</br>60-}</br>61-</br>62-</br>63-</br>64-//}</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/meshUtilities/InternalWellGenerator.cpp</h4><div id=script>82-</br>83-}</br>84-</br>85-InternalWellGenerator::~InternalWellGenerator()</br>86-{</br>87:  // <emph>TODO</emph> Auto-generated destructor stub</br>88-}</br>89-</br>90-void InternalWellGenerator::PostProcessInput()</br>91-{</br>92-  GEOSX_ERROR_IF( getName().find( "well" ) == std::string::npos,</br></br>121-                        m_inputPolyNodeCoords[inode][1],</br>122-                        m_inputPolyNodeCoords[inode][2] };</br>123-    m_polyNodeCoords[inode] = coords;</br>124-  }</br>125-</br>126:  // <emph>TODO</emph>: add more checks here</br>127:  // <emph>TODO</emph>: check that the connectivity of the well is valid</br>128:  // <emph>TODO</emph>: check that with no branching we can go from top to bottom and touch all the elements</br>129-}</br>130-</br>131-Group * InternalWellGenerator::CreateChild( string const & childKey, string const & childName )</br>132-{</br>133-  if( childKey == keys::perforation )</br></br>184-</br>185-  // map the perforations to the well elements</br>186-  ConnectPerforationsToWellElements();</br>187-</br>188-  // merge perforations to make sure that no well element is shared between two MPI domains</br>189:  // <emph>TODO</emph>: instead of merging perforations, split the well elements and do not change the physical location of the</br>190-  // perforation</br>191-  int const mpiSize = MpiWrapper::Comm_size( MPI_COMM_GEOSX );</br>192-  if( mpiSize > 1 )</br>193-  {</br>194-    MergePerforations();</br></br>294-  // set the location of the first well node and distance from well head</br>295-  m_nodeCoords[0]       = m_polyNodeCoords[ipolyNodeTop];</br>296-  m_nodeDistFromHead[0] = 0.0;</br>297-</br>298-  // note: this part of the code does not support well branching</br>299:  // <emph>TODO</emph>: check that there is only one branch</br>300:  // <emph>TODO</emph>: read wells with branching (already supported elsewhere in the code)</br>301-</br>302-  // go through the well from top to bottom</br>303-  for( globalIndex is = 0; is < m_segmentToPolyNodeMap.size( 0 ); ++is )</br>304-  {</br>305-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/meshUtilities/PerforationData.cpp</h4><div id=script>217-  // loop over all the perforations</br>218-  for( globalIndex iperfGlobal = 0; iperfGlobal < perfCoordsGlobal.size(); ++iperfGlobal )</br>219-  {</br>220-    R1Tensor const & coords = perfCoordsGlobal[iperfGlobal];</br>221-</br>222:    // <emph>TODO</emph> actually trace coords</br>223:    // <emph>TODO</emph> what if a fracture element is located</br>224-</br>225-    // find the closest reservoir element</br>226-    auto ret = minLocOverElemsInMesh( &mesh, [&] ( localIndex const er,</br>227-                                                   localIndex const esr,</br>228-                                                   localIndex const ei ) -> real64</br></br>252-    if( !computationalGeometry::IsPointInsidePolyhedron( nodeManager->referencePosition(), faceNodes, coords ))</br>253-    {</br>254-      continue;</br>255-    }</br>256-</br>257:    // <emph>TODO</emph>: what happens when the boundary is at the boundary of the MPI domain??</br>258-</br>259-    // now construct the local data</br>260-</br>261-    // store the indices of the mesh element</br>262-    m_toMeshElements.m_toElementRegion   [iperfLocal] = er;</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/meshUtilities/MeshUtilities.cpp</h4><div id=script>28-{</br>29-using namespace dataRepository;</br>30-</br>31-MeshUtilities::MeshUtilities()</br>32-{</br>33:  // <emph>TODO</emph> Auto-generated constructor stub</br>34-</br>35-}</br>36-</br>37-MeshUtilities::~MeshUtilities()</br>38-{</br></br>34-</br>35-}</br>36-</br>37-MeshUtilities::~MeshUtilities()</br>38-{</br>39:  // <emph>TODO</emph> Auto-generated destructor stub</br>40-}</br>41-</br>42-</br>43-</br>44-void MeshUtilities::GenerateNodesets( dataRepository::Group const * geometries,</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/meshUtilities/unitTests/testPAMELAImport.cpp</h4><div id=script>73-    {</br>74-      elemSubRegion.CalculateElementGeometricQuantities( nodeManager, faceManager );</br>75-      for( localIndex ei = 0; ei < elemSubRegion.size(); ei++ )</br>76-      {</br>77-        real64 center[ 3 ] = LVARRAY_TENSOROPS_INIT_LOCAL_3( elemSubRegion.getElementCenter()[ ei ] );</br>78:        // <emph>TODO</emph> Remove the INIT_LOCAL once centerProperty isn't an R1Tensor.</br>79-        real64 const centerFromProperty[ 3 ] = LVARRAY_TENSOROPS_INIT_LOCAL_3( centerProperty[er][esr][ei] );</br>80-        LvArray::tensorOps::subtract< 3 >( center, centerFromProperty );</br>81-        GEOSX_ERROR_IF_GT_MSG( LvArray::tensorOps::l2Norm< 3 >( center ), meshBody->getGlobalLengthScale() * 1e-8, "Property import of centers if wrong" );</br>82-      }</br>83-    } );</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/finiteVolume/TwoPointFluxApproximation.cpp</h4><div id=script>84-</br>85-  stencil.reserve( faceManager.size() );</br>86-</br>87-  real64 const lengthTolerance = m_lengthScale * m_areaRelTol;</br>88-  real64 const areaTolerance = lengthTolerance * lengthTolerance;</br>89:  real64 const weightTolerance = 1e-30 * lengthTolerance; // <emph>TODO</emph>: choice of constant based on physics?</br>90-</br>91-  forAll< serialPolicy >( faceManager.size(), [=, &stencil]( localIndex const kf )</br>92-  {</br>93-    // Filter out boundary faces</br>94-    if( elemList[kf][0] < 0 || elemList[kf][1] < 0 )</br></br>238-</br>239-  localIndex constexpr maxElems = FaceElementStencil::MAX_STENCIL_SIZE;</br>240-</br>241-  arrayView1d< integer const > const & edgeGhostRank = edgeManager->ghostRank();</br>242-</br>243:  // <emph>TODO</emph> Note that all of this initialization should be performed elsewhere. This is just here because it was</br>244-  // convenient, but it is not appropriate to have physics based initialization in the flux approximator.</br>245-#if !defined(SET_CREATION_DISPLACEMENT)</br>246-  static_assert( true, "must have SET_CREATION_DISPLACEMENT defined" );</br>247-#endif</br>248-#if SET_CREATION_DISPLACEMENT==1</br></br>351-      for( localIndex kfe=0; kfe<numElems; ++kfe )</br>352-      {</br>353-        localIndex const fractureElementIndex = fractureConnectorsToFaceElements[fci][kfe];</br>354-</br>355-        // use straight difference between the edge center and face center for gradient length...</br>356:        // <emph>TODO</emph>: maybe do something better here??</br>357-        real64 cellCenterToEdgeCenter[ 3 ];</br>358-        LvArray::tensorOps::copy< 3 >( cellCenterToEdgeCenter, edgeCenter );</br>359-        LvArray::tensorOps::subtract< 3 >( cellCenterToEdgeCenter, faceCenter[ faceMap[fractureElementIndex][0] ] );</br>360-</br>361-        // form the CellStencil entry</br></br>640-  stackArray1d< localIndex, numPts > stencilElemOrFaceIndices( numPts );</br>641-  stackArray1d< real64, numPts > stencilWeights( numPts );</br>642-</br>643-  real64 const lengthTolerance = m_lengthScale * m_areaRelTol;</br>644-  real64 const areaTolerance = lengthTolerance * lengthTolerance;</br>645:  real64 const weightTolerance = 1e-30 * lengthTolerance; // <emph>TODO</emph>: choice of constant based on physics?</br>646-</br>647-  // loop over faces and calculate faceArea, faceNormal and faceCenter</br>648-  stencil.reserve( faceSet.size() );</br>649-  for( localIndex kf : faceSet )</br>650-  {</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/finiteVolume/FluxApproximationBase.cpp</h4><div id=script>77-</br>78-      registerCellStencil( stencilGroup );</br>79-      registerFractureStencil( stencilGroup );</br>80-      // For each face-based boundary condition on target field, create a boundary stencil</br>81-      fsManager.Apply( 0.0,</br>82:                       meshBodies->getParent(), // <emph>TODO</emph>: Apply() should take a MeshLevel directly</br>83-                       "faceManager",</br>84-                       m_fieldName,</br>85-                       [&] ( FieldSpecificationBase const *,</br>86-                             string const & setName,</br>87-                             SortedArrayView< localIndex const > const &,</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/finiteElement/FiniteElementDiscretizationManager.cpp</h4><div id=script>30-  setInputFlags( InputFlags::OPTIONAL );</br>31-}</br>32-</br>33-FiniteElementDiscretizationManager::~FiniteElementDiscretizationManager()</br>34-{</br>35:  // <emph>TODO</emph> Auto-generated destructor stub</br>36-}</br>37-</br>38-</br>39-Group * FiniteElementDiscretizationManager::CreateChild( string const & childKey, string const & childName )</br>40-{</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/finiteElement/FiniteElementDiscretization.cpp</h4><div id=script>24-#include "mesh/NodeManager.hpp"</br>25-#include "managers/NumericalMethodsManager.hpp"</br>26-#include "codingUtilities/Utilities.hpp"</br>27-#include "common/TimingMacros.hpp"</br>28-</br>29:// <emph>TODO</emph> make this not dependent on this header...need better key implementation</br>30-</br>31-namespace geosx</br>32-{</br>33-using namespace dataRepository;</br>34-using namespace finiteElement;</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/finiteElement/ElementLibrary_depricated/SpecializedFormulations/UniformStrainHexahedron.cpp</h4><div id=script>61-</br>62-}</br>63-</br>64-UniformStrainHexahedron::~UniformStrainHexahedron()</br>65-{</br>66:  // <emph>TODO</emph> Auto-generated destructor stub</br>67-}</br>68-</br>69-</br>70-/**</br>71- * Reinitialize the finite element basis on a particular element.</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/linearAlgebra/DofManager.cpp</h4><div id=script>70-</br>71-void DofManager::setMesh( DomainPartition & domain,</br>72-                          localIndex const meshLevelIndex,</br>73-                          localIndex const meshBodyIndex )</br>74-{</br>75:  // <emph>TODO</emph>: this should be m_domain != domain</br>76-  if( m_domain != nullptr )</br>77-  {</br>78-    // Domain is changed! Delete old data structure and create new</br>79-    clear();</br>80-  }</br></br>649-  } );</br>650-</br>651-  localIndex maxDofCol = 0;</br>652-  if( colFieldIndex == rowFieldIndex )</br>653-  {</br>654:    connLocCol = connLocRow; // <emph>TODO</emph> avoid copying</br>655-    maxDofCol = maxDofRow;</br>656-  }</br>657-  else</br>658-  {</br>659-    LocationSwitch( colField.location, static_cast< Location >( conn ),</br></br>988-    setSparsityPatternFromStencil( pattern, rowFieldIndex );</br>989-    return;</br>990-  }</br>991-</br>992-  // Special treatment for scalar/vector FEM-style sparsity</br>993:  // <emph>TODO</emph>: separate counting/resizing from filling in order to enable this in coupled patterns</br>994-#if 0 // uncomment to re-enable faster sparsity construction algorithm for FEM single-physics</br>995-  if( m_fields.size() == 1 && rowFieldIndex == colFieldIndex &&</br>996-      rowField.location == Location::Node && conn == Connector::Elem )</br>997-  {</br>998-    switch( rowField.numComponents )</br></br>1029-  } );</br>1030-</br>1031-  localIndex maxDofCol = 0;</br>1032-  if( colFieldIndex == rowFieldIndex )</br>1033-  {</br>1034:    connLocCol = connLocRow; // <emph>TODO</emph> avoid copying</br>1035-    maxDofCol = maxDofRow;</br>1036-  }</br>1037-  else</br>1038-  {</br>1039-    LocationSwitch( colField.location, static_cast< Location >( conn ),</br></br>1176-  } );</br>1177-</br>1178-  localIndex maxDofCol = 0;</br>1179-  if( colFieldIndex == rowFieldIndex )</br>1180-  {</br>1181:    connLocCol = connLocRow; // <emph>TODO</emph> avoid copying</br>1182-    maxDofCol = maxDofRow;</br>1183-  }</br>1184-  else</br>1185-  {</br>1186-    LocationSwitch( colField.location, static_cast< Location >( conn ),</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/linearAlgebra/unitTests/testArrayLAOperations.cpp</h4><div id=script>957-  v_max = std::max_element( vec.begin(), vec.end());</br>958-  v_min = std::min_element( vec.begin(), vec.end());</br>959-  EXPECT_TRUE( -1.0 <= *v_min && *v_max <= 1.0 );</br>960-</br>961-  // --- normal distribution (0,1);</br>962:  // <emph>TODO</emph>: Add normality test</br>963-</br>964-}</br>965-</br>966-template< typename LAI ></br>967-void matrix_rand_test()</br></br>985-  A_max = std::max_element( mat.begin(), mat.end());</br>986-  A_min = std::min_element( mat.begin(), mat.end());</br>987-  EXPECT_TRUE( -1.0 <= *A_min && *A_max <= 1.0 );</br>988-</br>989-  // --- normal distribution (0,1);</br>990:  // <emph>TODO</emph>: Add normality test</br>991-</br>992-}</br>993-</br>994-template< typename LAI ></br>995-void set_get_random_number_generator_seed_test()</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/linearAlgebra/solvers/BlockPreconditioner.cpp</h4><div id=script>114-    case SchurComplementOption::FirstBlockDiagonal:</br>115-    {</br>116-      // In this case, the sparsity pattern of triple product can be denser</br>117-      // than that of (1,1)-block. Therefore, we have to add (1,1)-block to</br>118-      // the triple product result, not the other way around.</br>119:      // <emph>TODO</emph>: This is suboptimal, since we have to create multiple matrix copies.</br>120-      m_matBlocks( 0, 0 ).extractDiagonal( m_rhs( 0 ) );</br>121-      m_rhs( 0 ).reciprocal();</br>122-      Matrix mat01 = m_matBlocks( 0, 1 ); // make a copy in order to scale</br>123-      mat01.leftScale( m_rhs( 0 ) );</br>124-      Matrix mat11 = m_matBlocks( 1, 1 ); // make a copy in order to add later</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/linearAlgebra/solvers/SeparateComponentPreconditioner.cpp</h4><div id=script>43-void SeparateComponentPreconditioner< LAI >::compute( Matrix const & mat,</br>44-                                                      DofManager const & dofManager )</br>45-{</br>46-  Base::compute( mat, dofManager );</br>47-</br>48:  // <emph>TODO</emph>: if matrix structure hasn't changed, can just copy entries into existing m_matSC</br>49-  LAIHelperFunctions::SeparateComponentFilter( mat, m_matSC, m_numComp );</br>50-  m_precond->compute( m_matSC, dofManager );</br>51-}</br>52-</br>53-template< typename LAI ></br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/linearAlgebra/interfaces/trilinos/EpetraMatrix.cpp</h4><div id=script>439-</br>440-void EpetraMatrix::multiplyRAP( EpetraMatrix const & R,</br>441-                                EpetraMatrix const & P,</br>442-                                EpetraMatrix & dst ) const</br>443-{</br>444:  // <emph>TODO</emph>: ML_Epetra_RAP does not work with long long indices, find a workaround?</br>445-#if 0</br>446-  GEOSX_LAI_ASSERT( ready() );</br>447-  GEOSX_LAI_ASSERT( R.ready() );</br>448-  GEOSX_LAI_ASSERT( P.ready() );</br>449-  GEOSX_LAI_ASSERT_EQ( numGlobalRows(), R.numGlobalCols() );</br></br>460-}</br>461-</br>462-void EpetraMatrix::multiplyPtAP( EpetraMatrix const & P,</br>463-                                 EpetraMatrix & dst ) const</br>464-{</br>465:  // <emph>TODO</emph>: ML_Epetra_PtAP does not work with long long indices, find a workaround?</br>466-#if 0</br>467-  GEOSX_LAI_ASSERT( ready() );</br>468-  GEOSX_LAI_ASSERT( P.ready() );</br>469-  GEOSX_LAI_ASSERT_EQ( numGlobalRows(), P.numGlobalRows() );</br>470-  GEOSX_LAI_ASSERT_EQ( numGlobalCols(), P.numGlobalRows() );</br></br>842-  GEOSX_LAI_ASSERT( ready() );</br>843-  GEOSX_LAI_ASSERT( B.ready() );</br>844-</br>845-  C.createWithLocalSize( transA ? numLocalCols() : numLocalRows(),</br>846-                         transB ? B.numLocalRows() : B.numLocalCols(),</br>847:                         1, // <emph>TODO</emph>: estimate entries per row?</br>848-                         getComm() );</br>849-</br>850-  GEOSX_LAI_CHECK_ERROR( EpetraExt::MatrixMatrix::Multiply( unwrapped(),</br>851-                                                            transA,</br>852-                                                            B.unwrapped(),</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/linearAlgebra/interfaces/petsc/PetscPreconditioner.cpp</h4><div id=script>41-{</br>42-  // Default options only for the moment</br>43-  GEOSX_LAI_CHECK_ERROR( PCSetType( precond, PCGAMG ) );</br>44-  GEOSX_UNUSED_VAR( params )</br>45-</br>46:  // <emph>TODO</emph>: need someone familiar with PETSc to take a look at this</br>47-#if 0</br>48-  GEOSX_LAI_CHECK_ERROR( PCSetType( prec, PCHMG ) );</br>49-  GEOSX_LAI_CHECK_ERROR( PCHMGSetInnerPCType( prec, PCGAMG ) );</br>50-</br>51-  // Set maximum number of multigrid levels</br></br>129-      // GEOSX_LAI_CHECK_ERROR( PCSetUpOnBlocks( smootherPC ) );</br>130-    }</br>131-  }</br>132-</br>133-  // Set coarsest level solver</br>134:  // <emph>TODO</emph></br>135-  // m_parameters.amg.coarseType</br>136-</br>137-</br>138-</br>139-  // Set aggretation threshold</br></br>135-  // m_parameters.amg.coarseType</br>136-</br>137-</br>138-</br>139-  // Set aggretation threshold</br>140:  // <emph>TODO</emph></br>141-  // m_parameters.amg.aggregationThreshold</br>142-</br>--</br>141-  // m_parameters.amg.aggregationThreshold</br>142-</br>143:  // <emph>TODO</emph>: add user-defined null space / rigid body mode support</br>144-  // if ( m_parameters.amg.nullSpaceType )</br>145-  // {</br>146-  //   ...</br>147-  // }</br>148-#endif</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/linearAlgebra/interfaces/petsc/PetscMatrix.cpp</h4><div id=script>147-    }</br>148-    GEOSX_LAI_CHECK_ERROR( MatAssemblyBegin( m_mat, MAT_FINAL_ASSEMBLY ) );</br>149-    GEOSX_LAI_CHECK_ERROR( MatAssemblyEnd( m_mat, MAT_FINAL_ASSEMBLY ) );</br>150-  }</br>151-</br>152:  // <emph>TODO</emph>: is there a way to set local rows without global/collective calls?</br>153-  // ensure all ranks call MatAssemblyEnd the same number of times</br>154-  PetscInt const numExtra = maxNumRows - (lastrow - firstrow);</br>155-  for( PetscInt i = 0; i < numExtra; ++i )</br>156-  {</br>157-    GEOSX_LAI_CHECK_ERROR( MatAssemblyBegin( m_mat, MAT_FLUSH_ASSEMBLY ) );</br></br>572-void PetscMatrix::multiplyRAP( PetscMatrix const & R,</br>573-                               PetscMatrix const & P,</br>574-                               PetscMatrix & dst ) const</br>575-{</br>576-  // No builtin RAP function in PETSc, so use double product for now</br>577:  // <emph>TODO</emph>: research this better</br>578-  MatrixBase::multiplyRAP( R, P, dst );</br>579-}</br>580-</br>581-void PetscMatrix::multiplyPtAP( PetscMatrix const & P,</br>582-                                PetscMatrix & dst ) const</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/linearAlgebra/interfaces/hypre/HyprePreconditioner.cpp</h4><div id=script>326-    // 2-level MGR reduction strategy which seems to work well for 2 components</br>327-    // 1st level: eliminate the reservoir density associated with the volume constraint</br>328-    // 2nd level: eliminate the pressure</br>329-    // The coarse grid solved with ILU(0)</br>330-    //</br>331:    // <emph>TODO</emph>:</br>332-    // - Experiment with block Jacobi for F-relaxation/interpolation of the reservoir densities</br>333-    // - Explore ways to reduce onto the pressure variable and use AMG for coarse-grid solve</br>334-    HYPRE_Int numLabels = LvArray::integerConversion< HYPRE_Int >( numComponentsPerField[0] );</br>335-</br>336-    mgr_bsize = numLabels;</br></br>414-    // 1st level: eliminate the reservoir density associated with the volume constraint</br>415-    // 2nd level: eliminate the rest of the reservoir densities</br>416-    // 3rd level: eliminate the pressure</br>417-    // The coarse grid is the well block and solved with ILU(0)</br>418-    //</br>419:    // <emph>TODO</emph>:</br>420-    // - Use block Jacobi for F-relaxation/interpolation of the reservoir densities (2nd level)</br>421-</br>422-    HYPRE_Int numResLabels = LvArray::integerConversion< HYPRE_Int >( numComponentsPerField[0] );</br>423-    HYPRE_Int numWellLabels = LvArray::integerConversion< HYPRE_Int >( numComponentsPerField[1] );</br>424-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/linearAlgebra/interfaces/hypre/HypreSolver.cpp</h4><div id=script>222-</br>223-  // Create the preconditioner, but don't compute (this is done by solver setup)</br>224-  HyprePreconditioner precond( m_parameters, dofManager );</br>225-</br>226-  // Deal with separate component approximation</br>227:  // <emph>TODO</emph>: preliminary version for separate displacement components</br>228-  HypreMatrix separateComponentMatrix;</br>--</br>228-  HypreMatrix separateComponentMatrix;</br>229:  HYPRE_Solver uu_amg_solver = {};//<emph>TODO</emph>: this is a quick and dirty first implementation</br>230-</br>231-  if( m_parameters.amg.separateComponents && m_parameters.preconditionerType != "mgr" )</br>232-  {</br>233-    LAIHelperFunctions::SeparateComponentFilter( mat, separateComponentMatrix, m_parameters.dofsPerNode );</br>234-  }</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/linearAlgebra/interfaces/hypre/HypreMatrix.cpp</h4><div id=script>607-</br>608-void HypreMatrix::multiplyRAP( HypreMatrix const & R,</br>609-                               HypreMatrix const & P,</br>610-                               HypreMatrix & dst ) const</br>611-{</br>612:  // <emph>TODO</emph>: figure out how to make this work</br>613-#if 1</br>614-  GEOSX_LAI_ASSERT( ready() );</br>615-  GEOSX_LAI_ASSERT( R.ready() );</br>616-  GEOSX_LAI_ASSERT( P.ready() );</br>617-  GEOSX_LAI_ASSERT_EQ( numGlobalRows(), R.numGlobalCols() );</br></br>642-}</br>643-</br>644-void HypreMatrix::multiplyPtAP( HypreMatrix const & P,</br>645-                                HypreMatrix & dst ) const</br>646-{</br>647:  // <emph>TODO</emph>: figure out how to make this work</br>648-#if 1</br>649-  GEOSX_LAI_ASSERT( ready() );</br>650-  GEOSX_LAI_ASSERT( P.ready() );</br>651-  GEOSX_LAI_ASSERT_EQ( numGlobalRows(), P.numGlobalRows() );</br>652-  GEOSX_LAI_ASSERT_EQ( numGlobalCols(), P.numGlobalRows() );</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/constitutive/unitTests/testMultiFluid.cpp</h4><div id=script>270-</br>271-MultiFluidBase * makeCompositionalFluid( string const & name, Group & parent )</br>272-{</br>273-  auto fluid = parent.RegisterGroup< CompositionalMultiphaseFluid >( name );</br>274-</br>275:  // <emph>TODO</emph> we should actually create a fake XML node with data, but this seemed easier...</br>276-</br>277-  auto & compNames = fluid->getReference< string_array >( MultiFluidBase::viewKeyStruct::componentNamesString );</br>278-  compNames.resize( 4 );</br>279-  compNames[0] = "N2"; compNames[1] = "C10"; compNames[2] = "C20"; compNames[3] = "H20";</br>280-</br></br>327-</br>328-TEST_F( CompositionalFluidTest, numericalDerivativesMolar )</br>329-{</br>330-  fluid->setMassFlag( false );</br>331-</br>332:  // <emph>TODO</emph> test over a range of values</br>333-  real64 const P = 5e6;</br>334-  real64 const T = 297.15;</br>335-  array1d< real64 > comp( 4 );</br>336-  comp[0] = 0.099; comp[1] = 0.3; comp[2] = 0.6; comp[3] = 0.001;</br>337-</br></br>343-</br>344-TEST_F( CompositionalFluidTest, numericalDerivativesMass )</br>345-{</br>346-  fluid->setMassFlag( true );</br>347-</br>348:  // <emph>TODO</emph> test over a range of values</br>349-  real64 const P = 5e6;</br>350-  real64 const T = 297.15;</br>351-  array1d< real64 > comp( 4 );</br>352-  comp[0] = 0.099; comp[1] = 0.3; comp[2] = 0.6; comp[3] = 0.001;</br>353-</br></br>359-</br>360-MultiFluidBase * makeLiveOilFluid( string const & name, Group * parent )</br>361-{</br>362-  auto fluid = parent->RegisterGroup< BlackOilFluid >( name );</br>363-</br>364:  // <emph>TODO</emph> we should actually create a fake XML node with data, but this seemed easier...</br>365-</br>366-  auto & compNames = fluid->getReference< string_array >( MultiFluidBase::viewKeyStruct::componentNamesString );</br>367-  compNames.resize( 3 );</br>368-  compNames[0] = "oil"; compNames[1] = "gas"; compNames[2] = "water";</br>369-</br></br>392-</br>393-MultiFluidBase * makeDeadOilFluid( string const & name, Group * parent )</br>394-{</br>395-  auto fluid = parent->RegisterGroup< BlackOilFluid >( name );</br>396-</br>397:  // <emph>TODO</emph> we should actually create a fake XML node with data, but this seemed easier...</br>398-</br>399-  auto & compNames = fluid->getReference< string_array >( MultiFluidBase::viewKeyStruct::componentNamesString );</br>400-  compNames.resize( 3 );</br>401-  compNames[0] = "oil"; compNames[1] = "gas"; compNames[2] = "water";</br>402-</br></br>468-</br>469-TEST_F( LiveOilFluidTest, numericalDerivativesMolar )</br>470-{</br>471-  fluid->setMassFlag( false );</br>472-</br>473:  // <emph>TODO</emph> test over a range of values</br>474-  real64 const P = 5e6;</br>475-  real64 const T = 297.15;</br>476-  array1d< real64 > comp( 3 );</br>477-  comp[0] = 0.1; comp[1] = 0.3; comp[2] = 0.6;</br>478-</br></br>484-</br>485-TEST_F( LiveOilFluidTest, numericalDerivativesMass )</br>486-{</br>487-  fluid->setMassFlag( true );</br>488-</br>489:  // <emph>TODO</emph> test over a range of values</br>490-  real64 const P = 5e6;</br>491-  real64 const T = 297.15;</br>492-  array1d< real64 > comp( 3 );</br>493-  comp[0] = 0.1; comp[1] = 0.3; comp[2] = 0.6;</br>494-</br></br>530-</br>531-TEST_F( DeadOilFluidTest, numericalDerivativesMolar )</br>532-{</br>533-  fluid->setMassFlag( false );</br>534-</br>535:  // <emph>TODO</emph> test over a range of values</br>536-  real64 const P = 5e6;</br>537-  real64 const T = 297.15;</br>538-  array1d< real64 > comp( 3 );</br>539-  comp[0] = 0.1; comp[1] = 0.3; comp[2] = 0.6;</br>540-</br></br>546-</br>547-TEST_F( DeadOilFluidTest, numericalDerivativesMass )</br>548-{</br>549-  fluid->setMassFlag( true );</br>550-</br>551:  // <emph>TODO</emph> test over a range of values</br>552-  real64 const P = 5e6;</br>553-  real64 const T = 297.15;</br>554-  array1d< real64 > comp( 3 );</br>555-  comp[0] = 0.1; comp[1] = 0.3; comp[2] = 0.6;</br>556-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/constitutive/unitTests/testRelPerm.cpp</h4><div id=script>239-  RelativePermeabilityBase * relperm = makeBrooksCoreyRelPerm( "relPerm", parent.get() );</br>240-</br>241-  parent->Initialize( parent.get() );</br>242-  parent->InitializePostInitialConditions( parent.get() );</br>243-</br>244:  // <emph>TODO</emph> test over a range of values</br>245-  array1d< real64 > sat( 4 );</br>246-  sat[0] = 0.7; sat[1] = 0.3;</br>247-</br>248-  real64 const eps = std::sqrt( std::numeric_limits< real64 >::epsilon() );</br>249-  real64 const tol = 1e-4;</br></br>262-  parent->InitializePostInitialConditions( parent.get() );</br>263-</br>264-  real64 const eps = std::sqrt( std::numeric_limits< real64 >::epsilon() );</br>265-  real64 const tol = 1e-4;</br>266-</br>267:  // <emph>TODO</emph> test over a range of values</br>268-  real64 const start_sat = 0.3;</br>269-  real64 const end_sat   = 0.7;</br>270-  real64 const dS = 1e-1;</br>271-  real64 const alpha = 0.4;</br>272-  array1d< real64 > sat( 2 );</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/constitutive/fluid/CompositionalMultiphaseFluid.cpp</h4><div id=script>134-    m_componentVolumeShift.resize( NC );</br>135-    m_componentVolumeShift.setValues< serialPolicy >( 0.0 );</br>136-  }</br>137-</br>138-  COMPFLUID_CHECK_INPUT_LENGTH( m_componentVolumeShift, NC, viewKeyStruct::componentVolumeShiftString )</br>139:  //if (m_componentBinaryCoeff.empty()) <emph>TODO</emph> needs reading of 2D arrays</br>140-  {</br>141-    m_componentBinaryCoeff.resize( NC, NC );</br>142-    m_componentBinaryCoeff.setValues< serialPolicy >( 0.0 );</br>143-  }</br>144-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/constitutive/fluid/CompressibleSinglePhaseFluid.cpp</h4><div id=script>126-</br>127-  GEOSX_ERROR_IF( m_viscosityModelType != ExponentApproximationType::Linear,</br>128-                  getName() << ": model type currently not supported: " << m_viscosityModelString );</br>129-</br>130-  // Set default values for derivatives (cannot be done in base class)</br>131:  // <emph>TODO</emph>: reconsider the necessity of this</br>132-</br>133-  real64 dRho_dP;</br>134-  real64 dVisc_dP;</br>135-  createKernelWrapper().Compute( m_referencePressure, m_referenceDensity, dRho_dP, m_referenceViscosity, dVisc_dP );</br>136-  this->getWrapper< array2d< real64 > >( viewKeyStruct::dDens_dPresString )->setDefaultValue( dRho_dP );</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/constitutive/fluid/MultiFluidPVTPackageWrapper.cpp</h4><div id=script>138-    auto const & comp = props.MoleComposition;</br>139-    auto const & dens = m_useMass ? props.MassDensity : props.MoleDensity;</br>140-</br>141-    phaseFrac[ip] = frac.value;</br>142-    phaseDens[ip] = dens.value;</br>143:    phaseVisc[ip] = 1.0; // <emph>TODO</emph></br>144-    for( localIndex jc = 0; jc < NC; ++jc )</br>145-    {</br>146-      phaseCompFrac[ip][jc] = comp.value[jc];</br>147-    }</br>148-  }</br></br>219-                                                 real64 & totalDensity,</br>220-                                                 real64 & dTotalDensity_dPressure,</br>221-                                                 real64 & dTotalDensity_dTemperature,</br>222-                                                 arraySlice1d< real64, 0 > const & dTotalDensity_dGlobalCompFraction ) const</br>223-{</br>224:// 0. make shortcut structs to avoid long names (<emph>TODO</emph> maybe remove)</br>225-  CompositionalVarContainer< 1 > phaseFrac {</br>226-    phaseFraction,</br>227-    dPhaseFraction_dPressure,</br>228-    dPhaseFraction_dTemperature,</br>229-    dPhaseFraction_dGlobalCompFraction</br></br>328-</br>329-    phaseDens.value[ip] = dens.value;</br>330-    phaseDens.dPres[ip] = dens.dP;</br>331-    phaseDens.dTemp[ip] = dens.dT;</br>332-</br>333:    // <emph>TODO</emph></br>334-    phaseVisc.value[ip] = 0.001;</br>335-    phaseVisc.dPres[ip] = 0.0;</br>336-    phaseVisc.dTemp[ip] = 0.0;</br>337-</br>338-    for( localIndex jc = 0; jc < NC; ++jc )</br></br>337-</br>338-    for( localIndex jc = 0; jc < NC; ++jc )</br>339-    {</br>340-      phaseFrac.dComp[ip][jc] = frac.dz[jc];</br>341-      phaseDens.dComp[ip][jc] = dens.dz[jc];</br>342:      phaseVisc.dComp[ip][jc] = 0.0; // <emph>TODO</emph></br>343-</br>344-      phaseCompFrac.value[ip][jc] = comp.value[jc];</br>345-      phaseCompFrac.dPres[ip][jc] = comp.dP[jc];</br>346-      phaseCompFrac.dTemp[ip][jc] = comp.dT[jc];</br>347-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/coreComponents/constitutive/fluid/BlackOilFluid.cpp</h4><div id=script>97-  fluid.createFluid();</br>98-}</br>99-</br>100-void BlackOilFluid::PostProcessInput()</br>101-{</br>102:  // <emph>TODO</emph> maybe use different names?</br>103-  m_componentNames = m_phaseNames;</br>104-</br>105-  MultiFluidPVTPackageWrapper::PostProcessInput();</br>106-</br>107-  localIndex const NP = numFluidPhases();</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/cmake/blt/tests/internal/src/combine_static_library_test/Foo3.cpp</h4><div id=script>8-namespace blt_test</br>9-{</br>10-</br>11-Foo3::Foo3()</br>12-{</br>13:  // <emph>TODO</emph> Auto-generated constructor stub</br>14-</br>15-}</br>16-</br>17-Foo3::~Foo3()</br>18-{</br></br>14-</br>15-}</br>16-</br>17-Foo3::~Foo3()</br>18-{</br>19:  // <emph>TODO</emph> Auto-generated destructor stub</br>20-}</br>21-</br>22-std::string Foo3::output()</br>23-{</br>24-  return "I am Foo #3";</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/cmake/blt/tests/internal/src/combine_static_library_test/Foo2.cpp</h4><div id=script>8-namespace blt_test</br>9-{</br>10-</br>11-Foo2::Foo2()</br>12-{</br>13:  // <emph>TODO</emph> Auto-generated constructor stub</br>14-</br>15-}</br>16-</br>17-Foo2::~Foo2()</br>18-{</br></br>14-</br>15-}</br>16-</br>17-Foo2::~Foo2()</br>18-{</br>19:  // <emph>TODO</emph> Auto-generated destructor stub</br>20-}</br>21-</br>22-std::string Foo2::output()</br>23-{</br>24-  return "I am Foo #2";</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/cmake/blt/tests/internal/src/combine_static_library_test/Foo1.cpp</h4><div id=script>9-namespace blt_test</br>10-{</br>11-</br>12-Foo1::Foo1()</br>13-{</br>14:  // <emph>TODO</emph> Auto-generated constructor stub</br>15-</br>16-}</br>17-</br>18-Foo1::~Foo1()</br>19-{</br></br>15-</br>16-}</br>17-</br>18-Foo1::~Foo1()</br>19-{</br>20:  // <emph>TODO</emph> Auto-generated destructor stub</br>21-}</br>22-</br>23-std::string Foo1::output()</br>24-{</br>25-  return "I am Foo #1";</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PVTPackage/cmake/blt/tests/internal/src/combine_static_library_test/Foo3.cpp</h4><div id=script>8-namespace blt_test</br>9-{</br>10-</br>11-Foo3::Foo3()</br>12-{</br>13:  // <emph>TODO</emph> Auto-generated constructor stub</br>14-</br>15-}</br>16-</br>17-Foo3::~Foo3()</br>18-{</br></br>14-</br>15-}</br>16-</br>17-Foo3::~Foo3()</br>18-{</br>19:  // <emph>TODO</emph> Auto-generated destructor stub</br>20-}</br>21-</br>22-std::string Foo3::output()</br>23-{</br>24-  return "I am Foo #3";</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PVTPackage/cmake/blt/tests/internal/src/combine_static_library_test/Foo2.cpp</h4><div id=script>8-namespace blt_test</br>9-{</br>10-</br>11-Foo2::Foo2()</br>12-{</br>13:  // <emph>TODO</emph> Auto-generated constructor stub</br>14-</br>15-}</br>16-</br>17-Foo2::~Foo2()</br>18-{</br></br>14-</br>15-}</br>16-</br>17-Foo2::~Foo2()</br>18-{</br>19:  // <emph>TODO</emph> Auto-generated destructor stub</br>20-}</br>21-</br>22-std::string Foo2::output()</br>23-{</br>24-  return "I am Foo #2";</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PVTPackage/cmake/blt/tests/internal/src/combine_static_library_test/Foo1.cpp</h4><div id=script>9-namespace blt_test</br>10-{</br>11-</br>12-Foo1::Foo1()</br>13-{</br>14:  // <emph>TODO</emph> Auto-generated constructor stub</br>15-</br>16-}</br>17-</br>18-Foo1::~Foo1()</br>19-{</br></br>15-</br>16-}</br>17-</br>18-Foo1::~Foo1()</br>19-{</br>20:  // <emph>TODO</emph> Auto-generated destructor stub</br>21-}</br>22-</br>23-std::string Foo1::output()</br>24-{</br>25-  return "I am Foo #1";</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PVTPackage/PVTPackage/source/MultiphaseSystem/DeadOilMultiphaseSystem.cpp</h4><div id=script>73-        LOGERROR("Phase type not supported for Black Oil model");</br>74-    }</br>75-  }</br>76-</br>77-  //Check consistency between PVTO and PVTG</br>78:  //<emph>TODO</emph></br>79-</br>80-  //Check if both oil and gas are defined</br>81-  ASSERT((m_MultiphaseProperties.PhaseModels.find(PHASE_TYPE::OIL) != m_MultiphaseProperties.PhaseModels.end())</br>82-         && (m_MultiphaseProperties.PhaseModels.find(PHASE_TYPE::GAS) != m_MultiphaseProperties.PhaseModels.end()),</br>83-         "Both oil and gas phase must be defined for BO model");</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PVTPackage/PVTPackage/source/MultiphaseSystem/BlackOilMultiphaseSystem.cpp</h4><div id=script>73-        LOGERROR("Phase type not supported for Black Oil model");</br>74-    }</br>75-  }</br>76-</br>77-  //Check consistency between PVTO and PVTG</br>78:  //<emph>TODO</emph></br>79-</br>80-  //Check if both oil and gas are defined</br>81-  ASSERT((m_MultiphaseProperties.PhaseModels.find(PHASE_TYPE::OIL) != m_MultiphaseProperties.PhaseModels.end())</br>82-         && (m_MultiphaseProperties.PhaseModels.find(PHASE_TYPE::GAS) != m_MultiphaseProperties.PhaseModels.end()),</br>83-         "Both oil and gas phase must be defined for BO model");</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PVTPackage/PVTPackage/source/MultiphaseSystem/PhaseSplitModel/CompositionalFlash.cpp</h4><div id=script>10-</br>11-double CompositionalFlash::SolveRachfordRiceEquation(const std::vector<double>& Kvalues, const std::vector<double>& feed, const std::list<size_t>& non_zero_index)</br>12-{</br>13-  double gas_phase_mole_fraction=0;</br>14-</br>15:  //Numerical Parameters //<emph>TODO</emph>: move them outside the function</br>16-  double SSI_tolerance=1e-3;</br>17-  int max_SSI_iterations = 200;</br>18-  double Newton_tolerance = 1e-12;</br>19-  int max_Newton_iterations = 30;</br>20-  double epsilon = std::numeric_limits<double>::epsilon();</br></br>27-      max_K = Kvalues[*it];</br>28-    if (Kvalues[*it] < min_K)</br>29-      min_K = Kvalues[*it];</br>30-  }</br>31-</br>32:  //Check for trivial solutions. This corresponds to bad Kvalues //<emph>TODO</emph>:to be fixed</br>33-  if (max_K < 1.0)</br>34-  {</br>35-    return gas_phase_mole_fraction = 0.0;</br>36-  }</br>37-  if (min_K > 1.0)</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PVTPackage/PVTPackage/source/MultiphaseSystem/PhaseSplitModel/FreeWaterFlash.cpp</h4><div id=script>331-																const std::list<size_t>& non_zero_index, double KWater_GasWater,</br>332-																double KWater_OilWater, double water_feed)</br>333-	{</br>334-		double gas_phase_mole_fraction = 0;</br>335-</br>336:		//Numerical Parameters //<emph>TODO</emph>: move them outside the function</br>337-		double SSI_tolerance = 1e-8;</br>338-		int max_SSI_iterations = 200;</br>339-		double Newton_tolerance = 1e-12;</br>340-		int max_Newton_iterations = 30;</br>341-		double epsilon = std::numeric_limits<double>::epsilon();</br></br>351-				if (Kvalues[*it] < min_K)</br>352-					min_K = Kvalues[*it];</br>353-			}</br>354-		}</br>355-</br>356:		//Check for trivial solutions. This corresponds to bad Kvalues //<emph>TODO</emph>:to be fixed</br>357-		if (max_K < (1.0-(KWater_GasWater- KWater_OilWater)/(1.0 - KWater_OilWater)))</br>358-		{</br>359-			return gas_phase_mole_fraction = 0.0;</br>360-		}</br>361-		if (min_K > (1.0 - (KWater_GasWater - KWater_OilWater) / (1.0 - KWater_OilWater)))</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PVTPackage/PVTPackage/source/MultiphaseSystem/PhaseModel/BlackOil/BlackOil_GasModel.cpp</h4><div id=script>296-}</br>297-</br>298-void BlackOil_GasModel::ComputeUndersaturatedBgVisc(double Rv, double P, double& Bg, double& visc)</br>299-{</br>300-  (void) Rv, (void) P, (void) Bg, (void) visc;</br>301:  //<emph>TODO</emph> Put real undersaturated properties</br>302-  //This function cannot be called</br>303-  // LOGERROR("cannot be called");</br>304-</br>305-}</br>306-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PAMELA/cmake/blt/tests/internal/src/combine_static_library_test/Foo3.cpp</h4><div id=script>8-namespace blt_test</br>9-{</br>10-</br>11-Foo3::Foo3()</br>12-{</br>13:  // <emph>TODO</emph> Auto-generated constructor stub</br>14-</br>15-}</br>16-</br>17-Foo3::~Foo3()</br>18-{</br></br>14-</br>15-}</br>16-</br>17-Foo3::~Foo3()</br>18-{</br>19:  // <emph>TODO</emph> Auto-generated destructor stub</br>20-}</br>21-</br>22-std::string Foo3::output()</br>23-{</br>24-  return "I am Foo #3";</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PAMELA/cmake/blt/tests/internal/src/combine_static_library_test/Foo2.cpp</h4><div id=script>8-namespace blt_test</br>9-{</br>10-</br>11-Foo2::Foo2()</br>12-{</br>13:  // <emph>TODO</emph> Auto-generated constructor stub</br>14-</br>15-}</br>16-</br>17-Foo2::~Foo2()</br>18-{</br></br>14-</br>15-}</br>16-</br>17-Foo2::~Foo2()</br>18-{</br>19:  // <emph>TODO</emph> Auto-generated destructor stub</br>20-}</br>21-</br>22-std::string Foo2::output()</br>23-{</br>24-  return "I am Foo #2";</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PAMELA/cmake/blt/tests/internal/src/combine_static_library_test/Foo1.cpp</h4><div id=script>9-namespace blt_test</br>10-{</br>11-</br>12-Foo1::Foo1()</br>13-{</br>14:  // <emph>TODO</emph> Auto-generated constructor stub</br>15-</br>16-}</br>17-</br>18-Foo1::~Foo1()</br>19-{</br></br>15-</br>16-}</br>17-</br>18-Foo1::~Foo1()</br>19-{</br>20:  // <emph>TODO</emph> Auto-generated destructor stub</br>21-}</br>22-</br>23-std::string Foo1::output()</br>24-{</br>25-  return "I am Foo #1";</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PAMELA/PAMELA/source/Mesh/Mesh.cpp</h4><div id=script>226-      }</br>227-    }</br>228-</br>229-    LOGINFO("Ghost elements...");</br>230-</br>231:    ////OWNED AND GHOST POLYGONS   //<emph>TODO</emph> Can be much more efficient as it goes multiple times to the same point right now</br>232-    auto PolygonPolyhedronAdj = getAdjacencySet()->get_TopologicalAdjacency(ELEMENTS::FAMILY::POLYGON, ELEMENTS::FAMILY::POLYHEDRON, ELEMENTS::FAMILY::POLYHEDRON);</br>233-    auto PolyhedronPolygonAdj = getAdjacencySet()->get_TopologicalAdjacency(ELEMENTS::FAMILY::POLYHEDRON, ELEMENTS::FAMILY::POLYGON, ELEMENTS::FAMILY::POLYHEDRON);</br>234-    for (auto it = PolyhedronOwned.begin(); it != PolyhedronOwned.end(); ++it)</br>235-    {</br>236-      auto adj_Polyhedron2Polygon = PolyhedronPolygonAdj->get_SingleElementAdjacency(*it);</br></br>260-</br>261-        }</br>262-      }</br>263-    }</br>264-</br>265:    ////OWNED AND GHOST POINTS   //<emph>TODO</emph> Can be much more efficient as it goes multiple times to the same point right now</br>266-    auto PointPolyhedronAdj = getAdjacencySet()->get_TopologicalAdjacency(ELEMENTS::FAMILY::POINT, ELEMENTS::FAMILY::POLYHEDRON, ELEMENTS::FAMILY::POLYHEDRON);</br>267-    auto PolyhedronPointAdj = getAdjacencySet()->get_TopologicalAdjacency(ELEMENTS::FAMILY::POLYHEDRON, ELEMENTS::FAMILY::POINT, ELEMENTS::FAMILY::POLYHEDRON);</br>268-    for (auto it = PolyhedronOwned.begin(); it != PolyhedronOwned.end(); ++it)</br>269-    {</br>270-      auto adj_Poly2Point = PolyhedronPointAdj->get_SingleElementAdjacency(*it);</br></br>336-    idx_t nconst = 1;</br>337-    idx_t objval = 0;</br>338-    std::vector<idx_t> partitionVector(nnodes);</br>339-</br>340-    idx_t int_partition = static_cast<idx_t>(npartition);</br>341:    //<emph>TODO</emph> This is a copy to have idx_t. It can be memory consuming.</br>342-    std::vector<idx_t> rowPtrMetis(csrMatrix->rowPtr.begin(), csrMatrix->rowPtr.end());</br>343-    std::vector<idx_t> columnIndexMetis(csrMatrix->columnIndex.begin(), csrMatrix->columnIndex.end());</br>344-    METIS_PartGraphRecursive(&nnodes, &nconst, rowPtrMetis.data(), columnIndexMetis.data(),</br>345-        nullptr, nullptr, nullptr, &int_partition, nullptr, nullptr, options, &objval, partitionVector.data());</br>346-</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PAMELA/PAMELA/source/Parallel/Communicator.cpp</h4><div id=script>173-	// Casting unsigned to signed ints used in MPI calls (ugh...)</br>174-		std::vector<int> send_cnt(send_counts.begin(), send_counts.end());</br>175-		std::vector<int> send_disp(send_displs.begin(), send_displs.end());</br>176-		std::vector<int> recv_cnt(recv_counts.begin(), recv_counts.end());</br>177-		std::vector<int> recv_disp(recv_displs.begin(), recv_displs.end());</br>178:                //<emph>TODO</emph> this code seems weird : dataAtTime is not a member function</br>179-                //of std::vector...</br>180-		//int err = MPI_Neighbor_alltoallv(send_buf.data(), send_cnt.dataAtTime(), send_disp.dataAtTime(), MPI_DOUBLE,</br>181-			//recv_buf.data(), recv_cnt.dataAtTime(), recv_disp.dataAtTime(), MPI_DOUBLE, m_comm);</br>182-		//handle_error(err);</br>183-#else</br></br>256-		if (code == MPI_SUCCESS)</br>257-			return;</br>258-		char err_str[MPI_MAX_ERROR_STRING];</br>259-		int len;</br>260-		MPI_Error_string(code, err_str, &len);</br>261:		// <emph>TODO</emph>: proper handling</br>262-		throw std::string(err_str);</br>263-#else</br>264-		(void)code;</br>265-#endif</br>266-	}</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PAMELA/PAMELA/source/Adjacency/AdjacencySet.cpp</h4><div id=script>169-	}</br>170-</br>171-	void AdjacencySet::Add_NonTopologicalAdjacencySum(std::string label, std::vector<Adjacency*> sumAdj)</br>172-	{</br>173-		auto adjacency1 = sumAdj[0];</br>174:		auto adjacency2 = sumAdj[1];  //<emph>TODO</emph>: this is special case</br>175-</br>176-		auto csr1 = adjacency1->get_adjacencySparseMatrix();</br>177-		auto csr2 = adjacency2->get_adjacencySparseMatrix();</br>178-		auto csr_sum = CSRMatrix::sum(csr1, csr2);</br>179-		auto adj1_sourceFamily = adjacency1->get_sourceFamily();</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PAMELA/PAMELA/source/Adjacency/CSRMatrix.cpp</h4><div id=script>38- 					LOGWARNING("The CSR matrix has a column index vector not sorted");  </br>39-					//return false;</br>40-				}</br>41-				if (columnIndex[nnz_index] == columnIndex[nnz_index + 1])</br>42-				{</br>43:					//LOGWARNING("The CSR matrix has a column values equals in same row");  //<emph>TODO</emph>:check this. Seems ok.</br>44-					//return false;</br>45-				}</br>46-			}</br>47-			row_start = row_stop;</br>48-		}</br></div id=script><h4>/Users/j0529096/Documents/code/GEOSX/src/externalComponents/PAMELA/PAMELA/source/Import/Eclipse_mesh.cpp</h4><div id=script>928-	void Eclipse_mesh::ConvertBinaryBlock(std::string keyword, std::vector<double>& data, const std::string& label_suffix)</br>929-	{</br>930-		if (keyword == "COORD")</br>931-		{</br>932-			LOGINFO("     o COORD processed");</br>933:			m_COORD = data;		//<emph>TODO</emph> not efficient</br>934-		}</br>935-		else if (keyword == "ZCORN")</br>936-		{</br>937-			LOGINFO("     o ZCORN processed");</br>938-			m_ZCORN = data;</br></div id=script><strong></br>Found 132 files containing TODO (case insensitive) </strong></body>