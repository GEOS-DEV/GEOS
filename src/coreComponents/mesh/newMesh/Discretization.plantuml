@startuml(id=Discretization)

set separator ::

namespace Discretization {

abstract Class DiscretizationBase<MESHTYPE> {
Contains data/methods to describe the discretization of a **Mesh**.
--
MESHTYPE * m_mesh;
MeshInterface * m_meshInterface;
}

Class DiscretizationFEM<INDEX_TYPE> {
There is one instantiation of DiscretizationFEM every h/p refinement of the **Mesh**
--
array1d< arrayOfArray< FEM_TYPE > > m_femTypes
}
note right of DiscretizationFEM::m_femTypes
indices are:
 ( objectType )( regionIndex, subRegionIndex ) 

FEM_TYPE is ShivaInterface::FEM_INTERFACE...maybe this isn't required.
endnote

class DiscretizationStencil {
    manage/allocate data on GraphNodes and GraphLinks across mesh objects.
    We want a single index space, which means we allocate/store here in a 
    complex data structure mapping to the mesh field objects
    --
    -localIndex m_numGraphNodes
    -localIndex m_numGraphLinks
    --
    scalar fields
    - array1d<arrayOfArrays< > > m_scalar

}
note right of DiscretizationStencil::m_scalar
need new contiguous array type "arrayOfArrayOfArrayOfArray"
  Indices are:
   ( objectType )( regionIndex, subRegionIndex )(index0,...)
  Requirements for new "arrayOfArrayOfArrayOfArray"
  - accessible as single index from POV of stencil since it is contiguous.
  - arrayView of slices to hang stand-alone view/slice in each object
  - lightweight single index arrayView
endnote


class DiscretizationParticle {

}

class ConstitutiveBase {
    - localIndex m_numPoints
    - array1d scalarState (numPoints) 
    - Array2d vectorState (numPoints, numComponents) 
}


class DiscretizationFunctions {

static transferOperator( to, from, fieldPath )
}

namespace MeshInterface {
class MeshBasedFields {

}

class ElementManager {
    +forElementRegion(f)
    +forElementSubRegion(f)
}

class NodeFieldManager {
    holds fields on nodes
}
class EdgeFieldManager {
    holds fields on edges
    +edgeLength()
}
class FaceFieldManager {
    holds fields on faces
    +faceNormal()
}
class ElementManager {
    holds fields conatined in elements
    +elementVolume()
}

class ElementRegionBase {
    -m_scalar
}



class MeshBasedConstitutive {
    - int m_numQuadraturePoints
    - Array2d scalarState (numElems, m_numQuadraturePoints) 
    - Array3d vectorState (numElems, m_numQuadraturePoints, numComponents) 
}


MeshBasedFields "1" *-- "1" ElementManager
MeshBasedFields "1" *-- "1" NodeFieldManager
MeshBasedFields "1" *-- "1" EdgeFieldManager
MeshBasedFields "1" *-- "1" FaceFieldManager

ElementManager "1" *-- "0..n" ElementRegionBase
ElementRegionBase "1" *-- "1..n" ElementSubRegionBase
ElementSubRegionBase "1" *-- "1..n" ConstitutiveBase


} /' namespace MeshInterface '/
 

namespace ConstitutiveModels {
  abstract ConstitutiveBase {
    +localIndex m_numConstitutivePoints;
    +int m_numQuadraturePoints;
  }


}

DiscretizationBase <|-- DiscretizationFEM
DiscretizationBase <|-- DiscretizationStencil

DiscretizationFEM <|-- DiscretizationMPM
DiscretizationParticle <|-- DiscretizationMPM

DiscretizationParticle *-- ConstitutiveBase

DiscretizationBase <-- MeshInterface::MeshBasedFields



} /' namespace Discretization '/





@enduml