@startuml(id=ShivaInterface)

!pragma useNewPackage
set separator .


namespace ShivaInterface {

note as N1
  // launch with single thread per element

  template< typename FE_INTERFACE, CONSTITUTIVE >
  kernel( ...... )
  {
    using INDEX_TYPE = FE_INTERFACE::INDEX_TYPE;
    using TRANSFORMATION = FE_INTERFACE::TRANSFORM;
    using CELLTYPE = FE_INTERFACE::CELL;
    using FE_SPACE = FE_INTERFACE::FE_SPACE;

    kernelLaunch<POLICY>( 0, n, [=]( localIndex const k )
    {
      INDEX_TYPE const index( k );

      // gather coords, DOFs
      CELLTYPE celldata = FE_INTERFACE::DATA::createCell();
      FE_SPACE::LOCAL_DOF_ARRAY_TYPE localDofs;
      FE_SPACE::fillLocalDofsArray( DofArrayView, localDofs );

      for( INDEX_TYPE const q; q<numQuadrature; ++q )
      {
        real64 J[3][3];

        TRANSFORMATION::formJacobian( index, q, celldata, J );
        real64 invJ[3][3];
        REAL_TYPE detJ = inverse(J, invJ)

        gradVar[3][3] = gradient<FE_SPACE>( q, localDofs, invJ );
        
        // constitutive updates
        Dresult = constitutive.operatorD( constitutiveIndex(index, q), gradVar )

        // integration 
        result = plusGradNajAij<FE_SPACE >( q, invJ, Dresult );

      }
    });
  }
endnote



class Transformation {
}

class TransformationIsoparametric {
  +formTransformation( INDEX_TYPE index, COORD coord, real64 (&J)[3][3] )


}

class TransformationAtQuadrature<QUADRATURE> {
  +formTransformation( INDEX_TYPE cellIndex, INDEX_TYPE qi, real64 (&J)[3][3] )
}

class FiniteElementSpace< FUNCSPACE, CELL, BASIS > {
  +value( VAR_TYPE const (&var)[NSP], REAL_TYPE const (&coord)[DIMS] )
  +gradient( VAR_TYPE const (&var)[NSP], real64 (&invJ)[3][3] )
  using LOCAL_DOF_ARRAY_TYPE = m_Dof[NSP][NUM_DOF_PER_SP]
  -LOCAL_DOF_ARRAY_TYPE dofs;
}

class FiniteElementInterface< FESPACE, QUADRATURE >  {
  +value( INDEX_TYPE const q, VAR_TYPE const (&var)[NSP] )
  +gradient( INDEX_TYPE const q, AR_TYPE const (&var)[NSP], real64 const (&invJ)[3][3] )
}


namespace Basis {
class Basis< INDEX_TYPE, REAL_TYPE, ORDER > {
  constexpr REAL_TYPE value( INDEX_TYPE const functionIndex, REAL_TYPE const coord );
  constexpr REAL_TYPE gradient( INDEX_TYPE const functionIndex, REAL_TYPE const coord );
}

class BasisLagrange {

}

class BasisNURBS {
}

Basis <|-- BasisLagrange
Basis <|-- BasisNURBS

}

class Quadrature<INDEX_TYPE, REAL_TYPE> {
+constexpr INDEX_TYPE m_numPoints;
+constexpr getCoord( INDEX_TYPE const qi );
}


namespace Cell {
interface Cell<NUM_DOF_PER_SP> {
  +constexpr INDEX_TYPE numVertices()
  +vertexCoords()=0
}

class CellTetrahedron {
  -REAL_TYPE m_VertexCoords[4][3]
  +vertexCoords()
}

class CellPyramid {
  -REAL_TYPE m_VertexCoords[5][3]
  +vertexCoords()
}

class CellWedge {
  -REAL_TYPE m_VertexCoords[6][3]
  +vertexCoords()
}

class CellHexahedronUnstructured {
  -REAL_TYPE m_VertexCoords[8][3]
  +vertexCoords()
}

class CellHexahedronIJK {
  +vertexCoords()
}




Cell <|-- CellTetrahedron
Cell <|--- CellPyramid
Cell <|---- CellWedge
Cell <|----- CellHexahedronUnstructured
Cell <|------ CellHexahedronIJK
}


FiniteElementInterface <-- FiniteElementSpace
FiniteElementInterface <-- Quadrature
FiniteElementSpace <-- FunctionalSpace
FiniteElementSpace <-- Basis.Basis
FiniteElementSpace <-- Cell.Cell

Transformation <|-- TransformationIsoparametric
TransformationIsoparametric <|-- TransformationAtQuadrature
TransformationIsoparametric <-- Basis.Basis
TransformationIsoparametric <-- Cell.Cell
TransformationAtQuadrature <-- Quadrature

FiniteElementInterface <-- TransformationAtQuadrature

}


@enduml