@startuml(id=ShivaInterface)

!pragma useNewPackage
set separator .


namespace ShivaInterface {


namespace Geometry {
namespace Cell {
interface Cell {
  This family of classes are data/interface
  +constexpr int numVertices()
  +constexpr int numEdges()
  +constexpr int numFaces()
}

class CellTetrahedron_Pyramid_Wedge_Hexahdron {
  -using IndexType = int;
  -REAL_TYPE m_VertexCoords[4/5/6/8][3]
  +inline vertexCoords( IndexType const vindex, int const component ) override final;
}

class CellHexahedronIJK {
  -using IndexType = <int,int,int>};
  +inline vertexCoords( IndexType const vindex, int const component ) override final;
}

class CellPolyhedral {
  -using IndexType = <int,int,int>};
  +inline vertexCoords( IndexType const vindex, int const component ) override final;
}




Cell <|-- CellTetrahedron_Pyramid_Wedge_Hexahdron
Cell <|--- CellHexahedronIJK
Cell <|---- CellPolyhedral
}


entity Mapping {
  +jacobianTransform<CELL,BASIS>( CELL const & cell, REAL_TYPE const &(parentCoord)[3], REAL_TYPE &(J)[3][3] )
}
  note as jacobianTransformNote
  jacobianTransform<CELL,BASIS>( CELL const & cell, REAL_TYPE const &(parentCoord)[3], REAL_TYPE &(J)[3][3] )
  for( int a=0; a<CELL::numVertices(); ++a )
  {
    REAL_TYPE const dNdX[3] = { BASIS::gradient(a,coord) };
    for( int i=0; i<3; ++i )
    {
      for( int j=0; j<3; ++j )
      {
        J[i][j] = J[i][j] + dNdXi[ j ] * cell.vertexCoords(a,i);
      }
    }
  }


  jacobianTransform<CellHexIJK,BASIS>( CellHexIJK const & cell, REAL_TYPE const &(parentCoord)[3], REAL_TYPE &(J)[3][3] )
  for( int ai=0; ai<2; ++ai )
  for( int aj=0; aj<2; ++aj )
  for( int ak=0; ak<2; ++ak )
  {
    REAL_TYPE const dNdX[3] = { BASIS::gradient(ai,aj,ak,coord) };
    for( int i=0; i<3; ++i )
    {
      for( int j=0; j<3; ++j )
      {
        J[i][j] = J[i][j] + dNdXi[ j ] * cell.vertexCoords(ai,aj,ak,i);
      }
    }
  }

  endnote

  Mapping::jacobianTransform -- jacobianTransformNote
}

namespace FiniteElementMethod {

note as N1
  // launch with single thread per element

  template< typename FE_INTERFACE, CONSTITUTIVE >
  kernel( ...... )
  {
    using IndexType = FE_INTERFACE::IndexType;
    using CELLTYPE = FE_INTERFACE::CellType;

    kernelLaunch<POLICY>( 0, n, [=]( localIndex const k )
    {
      IndexType const index( k );

      // gather coords, DOFs
      CELLTYPE celldata = FE_INTERFACE::DATA::createCell();
      FE_SPACE::LOCAL_DOF_ARRAY_TYPE localDofs;
      FE_SPACE::fillLocalDofsArray( DofArrayView, localDofs );

      for( IndexType const q; q<numQuadrature; ++q )
      {
        real64 J[3][3];

        FE_INTERFACE::jacobianTransform( index, q, celldata, J );
        real64 invJ[3][3];
        REAL_TYPE detJ = inverse(J, invJ)

        gradVar[3][3] = gradient<FE_SPACE>( q, localDofs, invJ );
        
        // constitutive updates
        Dresult = constitutive.operatorD( constitutiveIndex(index, q), gradVar )

        // integration 
        result = plusGradNajAij<FE_SPACE >( q, invJ, Dresult );

      }
    });
  }
endnote

class ParentElement< FUNCSPACE, CELL, BASIS > {
  +using FunctionSpaceType = FUNCSPACE;
  +using CellType = CELL;
  +using BasisType = BASIS;
  +using IndexType = CELL::IndexType;
  +constrxpr NSP = f ( BASIS, CELL, FUNC_SPACE )
  +real64 shapeFunctionValue( int const a, REAL_TYPE const (&parentCoord)[DIMS] )
  +shapeFunctionGradient( int const a, REAL_TYPE const (&parentCoord)[DIMS] , real64 &(parentGrad)[3] )
  +VAR_TYPE value<VAR_TYPE>( VAR_TYPE const & var[NSP], REAL_TYPE const (&parentCoord)[DIMS] )
  +parentGradient( VAR_TYPE const (&var)[NSP], REAL_TYPE const (&parentCoord)[DIMS] , real64 &(parentGrad)[3] )
}

class FiniteElementSpace< PARENTELEMENT, MAPPING > {
  +using ParentElementType = PARENTELEMENT;
  +using CellType = PARENTELEMENT::CellType;
  +using BasisType = PARENTELEMENT::BasisType;
  +using MappingType = MAPPING;
  +using IndexType = PARENTELEMENT::IndexType;
  +using PARENTELEMENT::NSP;
  +jacobianTransform( CellType const & cell, REAL_TYPE const &(parentCoord)[3], REAL_TYPE &(J)[3][3] )
  +VAR_TYPE value<VAR_TYPE>( VAR_TYPE const & var[NSP], REAL_TYPE const (&parentCoord)[DIMS] )
  +gradient( VAR_TYPE const (&var)[NSP], REAL_TYPE const (&parentCoord)[DIMS] , REAL_TYPE const &(J)[3][3], real64 &(grad)[3] )

}


class FiniteElementInterface< FESPACE, QUADRATURE >  {

  +using FiniteElementSpaceType = FESPACE;
  +using QuadratureType = QUADRATURE;
  +using CellType = FESPACE::CellType;
  +using IndexType = FESPACE::IndexType;
  +using FESPACE::NSP;
  +using numQP = QUADRATURE::numPoints;
  +using LOCAL_DOF_ARRAY_TYPE<DOF_DIMS> = DofArrayHelper<DOF_DIMS,NSP>::LOCAL_DOF_ARRAY_TYPE;
  +jacobianTransform( int const q, CELL const & cell, REAL_TYPE &(J)[3][3] )
  +jacobianTransform( CELL const & cell, REAL_TYPE &(J)[numQP][3][3] )
  +value( INDEX_TYPE const q, LOCAL_DOF_ARRAY_TYPE const &dofs )
  +gradient( INDEX_TYPE const q, LOCAL_DOF_ARRAY_TYPE const &var , real64 const (&invJ)[3][3], real64 const &(gradVar)[3] )
  +gradient( INDEX_TYPE const q, LOCAL_DOF_ARRAY_TYPE const &var , real64 const (&invJ)[3][3], real64 const &(gradVar)[DOF_DIMS][3] )
}

class DofArrayHelper<NUM_DOF_VALUES_PER_POINT,NSP>{
  specialize on NUM_DOF_VALUES_PER_POINT
  --
  +using NumDofValuesPerPoint = NUM_DOF_VALUES_PER_POINT
  +using LOCAL_DOF_ARRAY_TYPE = real64[NSP]
  +using LOCAL_DOF_ARRAY_TYPE = real64[NSP][NUM_DOF_VALUES_PER_POINT]
}



FiniteElementInterface +-- DofArrayHelper


namespace Basis {
class Basis< INDEX_TYPE, REAL_TYPE > {
  constexpr REAL_TYPE value( INDEX_TYPE const functionIndex, REAL_TYPE const coord );
  constexpr REAL_TYPE[3] gradient( INDEX_TYPE const functionIndex, REAL_TYPE const coord );
}

class BasisLagrange<ORDER> {

}

class BasisNURBS {
}

Basis <|-- BasisLagrange
Basis <|-- BasisNURBS

}

namespace Quadrature {

interface Quadrature{}

class QuadratureGaussLegendre<INDEX_TYPE, REAL_TYPE, NUM_PTS> {
+constexpr int m_numPoints = NUM_PTS;
+constexpr getCoord( INDEX_TYPE const qi );
}

class QuadratureGaussLobatto<INDEX_TYPE, REAL_TYPE, NUM_PTS> {
  +constexpr int m_numPoints = NUM_PTS;
  +constexpr getCoord( INDEX_TYPE const qi );
}

Quadrature <|-- QuadratureGaussLegendre
Quadrature <|--- QuadratureGaussLobatto
}




class FunctionalSpace {
  H1, L2, RT
}

FiniteElementInterface::FiniteElementSpaceType <-- FiniteElementSpace
FiniteElementSpace::ParentElementType <-- ParentElement
FiniteElementInterface::QuadratureType <-- Quadrature.Quadrature
ParentElement::FunctionSpaceType <-- FunctionalSpace
ParentElement::BasisType <-- Basis.Basis


}


FiniteElementMethod.FiniteElementSpace::MappingType <-- Geometry.Mapping
FiniteElementMethod.ParentElement::CellType <-- Geometry.Cell.Cell



}


@enduml