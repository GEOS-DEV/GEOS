<diagram program="umletino" version="15.1"><zoom_level>10</zoom_level><help_text>Space for diagram notes</help_text><element><id>UMLClass</id><coordinates><x>30</x><y>180</y><w>520</w><h>210</h></coordinates><panel_attributes>
template=GEOMETRY, MAPPING
Cell
--
static constexpr space_dim;
static constexpr geometry_dim;
+constexpr auto applyMapping( ReferencePoint&lt;space_dim&gt; const &amp; point );
+constexpr auto getJacobian( ReferencePoint&lt;space_dim&gt; const &amp; point );
+constexpr auto computePhysicalNormal( auto reference_normal );
--

style=autoresize


</panel_attributes><additional_attributes></additional_attributes></element><element><id>UMLClass</id><coordinates><x>830</x><y>10</y><w>260</w><h>150</h></coordinates><panel_attributes>
MeshConnectivity
--
- structured/unstructured connectivity
- conforming/non-conforming connectivity
- static/adaptive
- refinement by superposition/substitution
--
Is this too vague of a concept?
style=autoresize
</panel_attributes><additional_attributes></additional_attributes></element><element><id>UMLClass</id><coordinates><x>580</x><y>390</y><w>360</w><h>460</h></coordinates><panel_attributes>
StaticGeometry (Interface)
--
static constexpr Integer space_dim;
static constexpr Integer geometry_dim;
static constexpr Integer num_faces;
constexpr Integer getNumNFaces&lt; Integer &gt;();
constexpr auto getReferenceNormal( Integer const face_id );
--
Note: this interface seems to break for generic polyhedral.
--
Define the manifold
vertices, edges, faces, volume

0D 
point/vertex

1D
line/segement

2D
triangle
square

3D
tet,
wedge
pyramid
hex

style=autoresize
</panel_attributes><additional_attributes></additional_attributes></element><element><id>UMLClass</id><coordinates><x>0</x><y>420</y><w>570</w><h>290</h></coordinates><panel_attributes>
Mapping (Interface)
--
static constexpr Integer input_dim;
static constexpr Integer output_dim;
+ using physical_coordinates = PhysicalPoint;
+ using jacobian = Matrix&lt; PHYSICAL_DIMENSION, REFERENCE_DIMENSION &gt; / std::tuple&lt; ... &gt; / ??;
+ constexpr physical_coordinates applyReferenceToPhysicalMapping( ReferencePoint )
+ jacobian computeJacobian( ReferencePoint )
--
Transformation Mapping
  - Isoparametric Mapping
  - Rotation
  - Translation
  - Isotropic stretching
  - Anisotropic stretching
  - Physical mapping
  - Tensor mapping, e.g. F(x,y) = { F(x), F(y) }
style=autoresize
</panel_attributes><additional_attributes></additional_attributes></element><element><id>UMLClass</id><coordinates><x>40</x><y>0</y><w>520</w><h>170</h></coordinates><panel_attributes>
template=CELL_TYPES..., CONNECTIVITES...
Mesh : public CONNECTIVITIES...
--
using cell_types = std::tuple&lt; CELL_TYPES... &gt;;
+ Integer getNumberOfCells&lt; CELL_TYPE &gt;();
+ CELL_TYPE getCell&lt; CELL_TYPE &gt;( LocalIndex&lt; CELL_TYPE &gt;  cell_index );
+ std::Variant&lt; CELL_TYPES... &gt; getCell( LocalIndex const cell_index );
--

style=autoresize
  </panel_attributes><additional_attributes></additional_attributes></element><element><id>UMLClass</id><coordinates><x>770</x><y>190</y><w>390</w><h>180</h></coordinates><panel_attributes>
template=MeshConnectivity
ElementConnectivity
--
- structure used in kernels to process element local info
- defines neighbors in some sense (face, edge, vertex)
--
- Face neighbors
- Edge neighbors
- Vertex neighbors
- std::Array&lt; Stencil::size &gt; getNeighbors( ) ? ( refine )
style=autoresize
</panel_attributes><additional_attributes></additional_attributes></element><element><id>UMLClass</id><coordinates><x>950</x><y>390</y><w>360</w><h>350</h></coordinates><panel_attributes>
template=Stored N-faces...
DynamicGeometry (Interface)
--
static Integer space_dim;
static Integer geometry_dim;
static Integer num_faces;
Integer getNumNFaces&lt; Integer &gt;();
auto getReferenceNormal( Integer const face_id );
--

--
Define the manifold
vertices, edges, faces, volume



2D
polygon

3D
polyhedra

style=autoresize
</panel_attributes><additional_attributes></additional_attributes></element></diagram>