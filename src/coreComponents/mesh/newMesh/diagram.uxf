<diagram program="umletino" version="15.1"><zoom_level>10</zoom_level><help_text>Space for diagram notes</help_text><element><id>UMLClass</id><coordinates><x>410</x><y>960</y><w>530</w><h>200</h></coordinates><panel_attributes>template=ReferenceCell, Mapping
MappedCell
--
static constexpr space_dim;
static constexpr geometry_dim;
+constexpr auto applyMapping( ReferencePoint&lt;space_dim&gt; const &amp; point );
+constexpr auto getJacobian( ReferencePoint&lt;space_dim&gt; const &amp; point );
+constexpr auto computePhysicalNormal( auto reference_normal );
--

style=autoresize


</panel_attributes><additional_attributes></additional_attributes></element><element><id>UMLClass</id><coordinates><x>2590</x><y>60</y><w>400</w><h>260</h></coordinates><panel_attributes>
MeshDataStructure ( Interface )
--

--
- GEOS Mesh
- Mesh node coordinates
- Cartesian mesh
- Block structured
- MultiLevel mesh, e.g. Level 0 unstructured, Level 1 static cartesian
- Refinement by superposition? Is this another case of MultiLevel mesh?
- Face-vertex data structure ( refinement unfriendly )
- Half-edge data structure ( refinement friendly )
- AMR oriented?
- Compressed Sparse Row

style=autoresize
</panel_attributes><additional_attributes></additional_attributes></element><element><id>UMLClass</id><coordinates><x>770</x><y>1580</y><w>360</w><h>470</h></coordinates><panel_attributes>Geometry (Interface)
--
static constexpr Integer space_dim;
static constexpr Integer geometry_dim;
static constexpr Integer num_faces;
constexpr Integer getNumNFaces&lt; Integer &gt;();
constexpr auto getReferenceNormal( Integer const face_id );
--
Note: this interface seems to break for generic polyhedral.
--
Define the manifold
vertices, edges, faces, volume

static constexpr mesh?

0D 
point/vertex

1D
line/segement

2D
triangle
square

3D
tet,
wedge
pyramid
hex

style=autoresize
</panel_attributes><additional_attributes></additional_attributes></element><element><id>UMLClass</id><coordinates><x>0</x><y>1350</y><w>570</w><h>290</h></coordinates><panel_attributes>
Mapping (Interface)
--
static constexpr Integer input_dim;
static constexpr Integer output_dim;
+ using physical_coordinates = PhysicalPoint;
+ using jacobian = Matrix&lt; PHYSICAL_DIMENSION, REFERENCE_DIMENSION &gt; / std::tuple&lt; ... &gt; / ??;
+ constexpr physical_coordinates applyReferenceToPhysicalMapping( ReferencePoint )
+ jacobian computeJacobian( ReferencePoint )
--
Transformation Mapping
  - Isoparametric Mapping
  - Rotation
  - Translation
  - Isotropic stretching
  - Anisotropic stretching
  - Physical mapping
  - Tensor mapping, e.g. F(x,y) = { F(x), F(y) }
style=autoresize
</panel_attributes><additional_attributes></additional_attributes></element><element><id>UMLClass</id><coordinates><x>880</x><y>0</y><w>1140</w><h>380</h></coordinates><panel_attributes>
template=CELL_TYPES..., MESH_DATA_STRUCTURES..., CONNECTIVITIES...
Mesh : public MESH_DATA_STRUCTURES..., public CONNECTIVITIES...
--
using cell_types = std::tuple&lt; CELL_TYPES... &gt;;
+ Integer getNumberOfCells&lt; CELL_TYPE &gt;();
+ ConnectedCell&lt; CELL_TYPE, ELEMENT_CONNECTIVITY_TYPE &gt; getCell&lt; ELEMENT_CONNECTIVITY_TYPE, CELL_TYPE &gt;( LocalIndex&lt; CELL_TYPE &gt;  cell_index );
+ std::Variant&lt; CELL_TYPES... &gt; getCell( LocalIndex const cell_index );
+ Differentiate these functions for host_device_data?
--
Should we define host_data, host_device_data, device_data?
Should we use tuples instead to give better inspection features?

struct host_data_struct : public typename Connectivities::host_data_struct...
{ } host_data;

struct host_device_data_struct : public typename Connectivities::host_device_data_struct...
{ } host_device_data;

Meant to be constructed from host_device_data?
struct device_data_struct : public typename Connectivities::device_data_struct...
{ } device_data;


style=autoresize
  </panel_attributes><additional_attributes></additional_attributes></element><element><id>UMLClass</id><coordinates><x>1640</x><y>680</y><w>410</w><h>430</h></coordinates><panel_attributes>ElementConnectivity ( Interface )
--
Typically described adjacency from a single element perspective
--
- overload constructor to support different mesh data structures
- exemple: local to global dof index mapping ( DofMap? DofManager? )
- structure used in kernels to process element local info
- defines neighbors in some sense (face, edge, vertex)
- structured/unstructured connectivity
- conforming/non-conforming connectivity
--
- Face neighbors:
FaceNeighborsIndices getFaceNeighbors( element_index )
{
   return getNFaceNeighbors&lt; geometry_dim -1 &gt;( element_index );
}

- Edge neighbors:
EdgeNeighborsIndices getEdgeNeighbors( element_index )
{ return getNFaceNeighbors&lt; 1 &gt;( element_index ); }

- Vertex neighbors
VertexNeighborsIndices getVertexNeighbors( element_index )
{ return getNFaceNeighbors&lt; 0 &gt;( element_index ); }

- Stencil neighbors:
Stencil::index_type getStencilNeighbors( element_index );

style=autoresize
</panel_attributes><additional_attributes></additional_attributes></element><element><id>UMLClass</id><coordinates><x>1170</x><y>1580</y><w>430</w><h>350</h></coordinates><panel_attributes>DynamicOnlyGeometry (Interface)
--
static constexpr Integer space_dim;
static constexpr Integer geometry_dim;
Integer num_faces;

Returns the number of N-faces, e.g. 0-faces are vertices, 1-faces are edges.
Integer getNumNFaces&lt; Dimension &gt;();

Returns the reference normal in space_dim.
auto getReferenceNormal( Integer const face_id );
--

--
Define the manifold
vertices, edges, faces, volume

2D
polygon

3D
polyhedra

style=autoresize
</panel_attributes><additional_attributes></additional_attributes></element><element><id>UMLClass</id><coordinates><x>620</x><y>1340</y><w>600</w><h>110</h></coordinates><panel_attributes>template=Geometry
ReferenceCell
--
using geometry_type = Geometry;
static constexpr Geometry geometry = makeReferenceGeometry&lt; Geometry &gt;();
--
We can make this work for non constexpr constructible geometries by using functions instead of values.
style=autoresize</panel_attributes><additional_attributes></additional_attributes></element><element><id>Relation</id><coordinates><x>270</x><y>1150</y><w>310</w><h>220</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>290;10;10;200</additional_attributes></element><element><id>Relation</id><coordinates><x>660</x><y>1150</y><w>230</w><h>220</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>10;10;210;200</additional_attributes></element><element><id>Relation</id><coordinates><x>880</x><y>1440</y><w>80</w><h>160</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>10;10;60;140</additional_attributes></element><element><id>Relation</id><coordinates><x>1150</x><y>1110</y><w>240</w><h>490</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>10;10;220;470</additional_attributes></element><element><id>UMLClass</id><coordinates><x>950</x><y>420</y><w>590</w><h>130</h></coordinates><panel_attributes>template=CELL_TYPE, ELEMENT_CONNECTIVITY_TYPE
ConnectedCell
--
Mostly a pair of a Cell with a data structure representing the requested connectivity
--
cell_type cell;
connectivity_type connectivity;
--

style=autoresize</panel_attributes><additional_attributes></additional_attributes></element><element><id>Relation</id><coordinates><x>1260</x><y>540</y><w>600</w><h>160</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>10;10;580;140</additional_attributes></element><element><id>Relation</id><coordinates><x>870</x><y>370</y><w>90</w><h>320</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>70;10;10;300</additional_attributes></element><element><id>Relation</id><coordinates><x>940</x><y>540</y><w>160</w><h>150</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>140;10;10;130</additional_attributes></element><element><id>UMLClass</id><coordinates><x>2000</x><y>140</y><w>400</w><h>370</h></coordinates><panel_attributes>template=Connectivity
StoredConnectivities
--
Find a way to not override when multiple connectivities?

using index_type = typename Connectivity::index_type;

Connectivity getConnectivity&lt; Connectivity &gt;( index_type index );

struct host_data_struct
{
   LvArray&lt; Connectivity &gt; connectivities;
} host_data;

struct host_device_data_struct
{
   LvArrayView&lt; Connectivity &gt; connectivities;
} host_device_data;

style=autoresize




</panel_attributes><additional_attributes></additional_attributes></element><element><id>Relation</id><coordinates><x>1850</x><y>500</y><w>320</w><h>200</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>300;10;10;180</additional_attributes></element><element><id>Relation</id><coordinates><x>1810</x><y>220</y><w>210</w><h>70</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>10;10;190;50</additional_attributes></element><element><id>Relation</id><coordinates><x>1810</x><y>60</y><w>800</w><h>40</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>10;20;780;10</additional_attributes></element><element><id>UMLClass</id><coordinates><x>2080</x><y>680</y><w>380</w><h>160</h></coordinates><panel_attributes>GeometricConnectivity
--
- overload constructor to support different mesh data structures
- edge to vertices
- face to vertices
- edge to edge
- face to edge
- face to vertices
- N-faces to M-faces where M &lt;= N?

style=autoresize</panel_attributes><additional_attributes></additional_attributes></element><element><id>Relation</id><coordinates><x>2260</x><y>500</y><w>30</w><h>200</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>10;10;10;180</additional_attributes></element><element><id>UMLClass</id><coordinates><x>2490</x><y>680</y><w>380</w><h>120</h></coordinates><panel_attributes>MeshConnectivity
--
- overload constructor to support different mesh data structures
- Describe how a mesh is related to another mesh
- Should we use that to describe a body?
- Use this for well and embedded fractures?

style=autoresize</panel_attributes><additional_attributes></additional_attributes></element><element><id>Relation</id><coordinates><x>2290</x><y>500</y><w>380</w><h>200</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>10;10;360;180</additional_attributes></element><element><id>Relation</id><coordinates><x>1180</x><y>370</y><w>80</w><h>80</h></coordinates><panel_attributes>lt=&lt;-
output</panel_attributes><additional_attributes>10;60;60;10</additional_attributes></element><element><id>UMLClass</id><coordinates><x>1060</x><y>950</y><w>230</w><h>170</h></coordinates><panel_attributes>template=Geometry
PhysicalCell
--
static constexpr space_dim;
static constexpr geometry_dim;
Geometry geometry;
//+ auto applyMapping( ReferencePoint&lt;space_dim&gt; const &amp; point );
//+ auto getJacobian( ReferencePoint&lt;space_dim&gt; const &amp; point );
//+ auto computePhysicalNormal( auto reference_normal );
--

style=autoresize


</panel_attributes><additional_attributes></additional_attributes></element><element><id>UMLClass</id><coordinates><x>670</x><y>670</y><w>450</w><h>200</h></coordinates><panel_attributes>
Cell (Interface?)
--
static constexpr space_dim;
static constexpr geometry_dim;
+constexpr auto applyMapping( ReferencePoint&lt;space_dim&gt; const &amp; point );
+constexpr auto getJacobian( ReferencePoint&lt;space_dim&gt; const &amp; point );
+constexpr auto computePhysicalNormal( auto reference_normal );
--

style=autoresize


</panel_attributes><additional_attributes></additional_attributes></element><element><id>Relation</id><coordinates><x>620</x><y>860</y><w>230</w><h>130</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>210;10;10;110</additional_attributes></element><element><id>Relation</id><coordinates><x>940</x><y>860</y><w>240</w><h>120</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>10;10;220;100</additional_attributes></element><element><id>Relation</id><coordinates><x>990</x><y>1110</y><w>150</w><h>490</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>130;10;10;470</additional_attributes></element></diagram>