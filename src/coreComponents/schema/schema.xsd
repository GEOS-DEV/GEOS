<?xml version="1.0"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
	<xsd:annotation>
		<xsd:documentation xml:lang="en">GEOSX Input Schema</xsd:documentation>
	</xsd:annotation>
	<xsd:simpleType name="R1Tensor">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*){2}[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="R1Tensor32">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*){2}[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="R2SymTensor">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*){5}[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geos_dataRepository_PlotLevel">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|[+-]?[\d]+" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="globalIndex">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|[+-]?[\d]+" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="globalIndex_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="globalIndex_array2d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*(\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*,\s*)*\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="globalIndex_array3d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*(\{\s*(\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*,\s*)*\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*\}\s*,\s*)*\{\s*(\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*,\s*)*\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*\}\s*\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="groupName">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|[a-zA-Z0-9.\-_]+" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="groupNameRef">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|[a-zA-Z0-9.\-_/*]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="groupNameRef_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*(([a-zA-Z0-9.\-_/*]*\s*,\s*)*[a-zA-Z0-9.\-_/*]*\s*)?\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="integer">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|[+-]?[\d]+" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="integer_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="integer_array2d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*(\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*,\s*)*\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="integer_array3d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*(\{\s*(\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*,\s*)*\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*\}\s*,\s*)*\{\s*(\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*,\s*)*\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*\}\s*\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="localIndex">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|[+-]?[\d]+" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="localIndex_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="localIndex_array2d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*(\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*,\s*)*\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="localIndex_array3d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*(\{\s*(\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*,\s*)*\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*\}\s*,\s*)*\{\s*(\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*,\s*)*\{\s*(([+-]?[\d]+\s*,\s*)*[+-]?[\d]+\s*)?\}\s*\}\s*\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="mapPair">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|[^,\{\}\s]*\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="path">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|[^*?&lt;>\|:&quot;;,\s]*\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="path_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*(([^*?&lt;>\|:&quot;;,\s]+\s*,\s*)*[^*?&lt;>\|:&quot;;,\s]+\s*)?\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real32">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real32_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real32_array2d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*(\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*,\s*)*\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real32_array3d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*(\{\s*(\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*,\s*)*\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*\}\s*,\s*)*\{\s*(\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*,\s*)*\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*\}\s*\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real64">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real64_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real64_array2d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*(\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*,\s*)*\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real64_array3d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*(\{\s*(\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*,\s*)*\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*\}\s*,\s*)*\{\s*(\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*,\s*)*\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*\}\s*\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real64_array4d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*(\{\s*(\{\s*(\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*,\s*)*\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*\}\s*,\s*)*\{\s*(\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*,\s*)*\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*\}\s*\}\s*,\s*)*\{\s*(\{\s*(\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*,\s*)*\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*\}\s*,\s*)*\{\s*(\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*,\s*)*\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*,\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)\s*)?\}\s*\}\s*\}\s*\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="string">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|[^,\{\}\s]*\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="string_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*\{\s*(([^,\{\}\s]+\s*,\s*)*[^,\{\}\s]+\s*)?\}\s*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:element name="Problem" type="ProblemType" />
	<xsd:complexType name="ProblemType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Events" type="EventsType" minOccurs="1" maxOccurs="1">
				<xsd:unique name="EventsHaltEventUniqueName">
					<xsd:selector xpath="HaltEvent" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="EventsPeriodicEventUniqueName">
					<xsd:selector xpath="PeriodicEvent" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="EventsSoloEventUniqueName">
					<xsd:selector xpath="SoloEvent" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="FieldSpecifications" type="FieldSpecificationsType" maxOccurs="1">
				<xsd:unique name="FieldSpecificationsAquiferUniqueName">
					<xsd:selector xpath="Aquifer" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="FieldSpecificationsDirichletUniqueName">
					<xsd:selector xpath="Dirichlet" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="FieldSpecificationsFieldSpecificationUniqueName">
					<xsd:selector xpath="FieldSpecification" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="FieldSpecificationsHydrostaticEquilibriumUniqueName">
					<xsd:selector xpath="HydrostaticEquilibrium" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="FieldSpecificationsPMLUniqueName">
					<xsd:selector xpath="PML" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="FieldSpecificationsSourceFluxUniqueName">
					<xsd:selector xpath="SourceFlux" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="FieldSpecificationsTractionUniqueName">
					<xsd:selector xpath="Traction" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="Functions" type="FunctionsType" maxOccurs="1">
				<xsd:unique name="FunctionsCompositeFunctionUniqueName">
					<xsd:selector xpath="CompositeFunction" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="FunctionsMultivariableTableFunctionUniqueName">
					<xsd:selector xpath="MultivariableTableFunction" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="FunctionsSymbolicFunctionUniqueName">
					<xsd:selector xpath="SymbolicFunction" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="FunctionsTableFunctionUniqueName">
					<xsd:selector xpath="TableFunction" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="Geometry" type="GeometryType" maxOccurs="1">
				<xsd:unique name="GeometryBoxUniqueName">
					<xsd:selector xpath="Box" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="GeometryCustomPolarObjectUniqueName">
					<xsd:selector xpath="CustomPolarObject" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="GeometryCylinderUniqueName">
					<xsd:selector xpath="Cylinder" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="GeometryDiscUniqueName">
					<xsd:selector xpath="Disc" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="GeometryRectangleUniqueName">
					<xsd:selector xpath="Rectangle" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="GeometryThickPlaneUniqueName">
					<xsd:selector xpath="ThickPlane" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="Mesh" type="MeshType" minOccurs="1" maxOccurs="1">
				<xsd:unique name="MeshInternalMeshUniqueName">
					<xsd:selector xpath="InternalMesh" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="MeshInternalWellboreUniqueName">
					<xsd:selector xpath="InternalWellbore" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="MeshParticleMeshUniqueName">
					<xsd:selector xpath="ParticleMesh" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="MeshVTKMeshUniqueName">
					<xsd:selector xpath="VTKMesh" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="NumericalMethods" type="NumericalMethodsType" maxOccurs="1" />
			<xsd:element name="Outputs" type="OutputsType" minOccurs="1" maxOccurs="1">
				<xsd:unique name="OutputsBlueprintUniqueName">
					<xsd:selector xpath="Blueprint" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="OutputsChomboIOUniqueName">
					<xsd:selector xpath="ChomboIO" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="OutputsPythonUniqueName">
					<xsd:selector xpath="Python" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="OutputsRestartUniqueName">
					<xsd:selector xpath="Restart" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="OutputsSiloUniqueName">
					<xsd:selector xpath="Silo" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="OutputsTimeHistoryUniqueName">
					<xsd:selector xpath="TimeHistory" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="OutputsVTKUniqueName">
					<xsd:selector xpath="VTK" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="Solvers" type="SolversType" minOccurs="1" maxOccurs="1">
				<xsd:unique name="SolversAcousticElasticSEMUniqueName">
					<xsd:selector xpath="AcousticElasticSEM" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversAcousticFirstOrderSEMUniqueName">
					<xsd:selector xpath="AcousticFirstOrderSEM" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversAcousticSEMUniqueName">
					<xsd:selector xpath="AcousticSEM" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversAcousticVTISEMUniqueName">
					<xsd:selector xpath="AcousticVTISEM" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversCompositionalMultiphaseFVMUniqueName">
					<xsd:selector xpath="CompositionalMultiphaseFVM" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversCompositionalMultiphaseHybridFVMUniqueName">
					<xsd:selector xpath="CompositionalMultiphaseHybridFVM" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversCompositionalMultiphaseReservoirUniqueName">
					<xsd:selector xpath="CompositionalMultiphaseReservoir" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversCompositionalMultiphaseReservoirPoromechanicsUniqueName">
					<xsd:selector xpath="CompositionalMultiphaseReservoirPoromechanics" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversCompositionalMultiphaseWellUniqueName">
					<xsd:selector xpath="CompositionalMultiphaseWell" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversElasticFirstOrderSEMUniqueName">
					<xsd:selector xpath="ElasticFirstOrderSEM" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversElasticSEMUniqueName">
					<xsd:selector xpath="ElasticSEM" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversEmbeddedSurfaceGeneratorUniqueName">
					<xsd:selector xpath="EmbeddedSurfaceGenerator" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversFlowProppantTransportUniqueName">
					<xsd:selector xpath="FlowProppantTransport" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversHydrofractureUniqueName">
					<xsd:selector xpath="Hydrofracture" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversLaplaceFEMUniqueName">
					<xsd:selector xpath="LaplaceFEM" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversMultiphasePoromechanicsUniqueName">
					<xsd:selector xpath="MultiphasePoromechanics" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversMultiphasePoromechanicsReservoirUniqueName">
					<xsd:selector xpath="MultiphasePoromechanicsReservoir" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversPhaseFieldDamageFEMUniqueName">
					<xsd:selector xpath="PhaseFieldDamageFEM" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversPhaseFieldFractureUniqueName">
					<xsd:selector xpath="PhaseFieldFracture" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversProppantTransportUniqueName">
					<xsd:selector xpath="ProppantTransport" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversReactiveCompositionalMultiphaseOBLUniqueName">
					<xsd:selector xpath="ReactiveCompositionalMultiphaseOBL" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversSeismicityRateUniqueName">
					<xsd:selector xpath="SeismicityRate" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversSinglePhaseFVMUniqueName">
					<xsd:selector xpath="SinglePhaseFVM" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversSinglePhaseHybridFVMUniqueName">
					<xsd:selector xpath="SinglePhaseHybridFVM" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversSinglePhasePoromechanicsUniqueName">
					<xsd:selector xpath="SinglePhasePoromechanics" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversSinglePhasePoromechanicsConformingFracturesUniqueName">
					<xsd:selector xpath="SinglePhasePoromechanicsConformingFractures" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversSinglePhasePoromechanicsConformingFracturesReservoirUniqueName">
					<xsd:selector xpath="SinglePhasePoromechanicsConformingFracturesReservoir" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversSinglePhasePoromechanicsEmbeddedFracturesUniqueName">
					<xsd:selector xpath="SinglePhasePoromechanicsEmbeddedFractures" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversSinglePhasePoromechanicsReservoirUniqueName">
					<xsd:selector xpath="SinglePhasePoromechanicsReservoir" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversSinglePhaseProppantFVMUniqueName">
					<xsd:selector xpath="SinglePhaseProppantFVM" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversSinglePhaseReservoirUniqueName">
					<xsd:selector xpath="SinglePhaseReservoir" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversSinglePhaseReservoirPoromechanicsUniqueName">
					<xsd:selector xpath="SinglePhaseReservoirPoromechanics" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversSinglePhaseWellUniqueName">
					<xsd:selector xpath="SinglePhaseWell" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversSolidMechanicsAugmentedLagrangianContactUniqueName">
					<xsd:selector xpath="SolidMechanicsAugmentedLagrangianContact" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversSolidMechanicsEmbeddedFracturesUniqueName">
					<xsd:selector xpath="SolidMechanicsEmbeddedFractures" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversSolidMechanicsLagrangeContactUniqueName">
					<xsd:selector xpath="SolidMechanicsLagrangeContact" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversSolidMechanicsLagrangianSSLEUniqueName">
					<xsd:selector xpath="SolidMechanicsLagrangianSSLE" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversSolidMechanics_LagrangianFEMUniqueName">
					<xsd:selector xpath="SolidMechanics_LagrangianFEM" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversSolidMechanics_MPMUniqueName">
					<xsd:selector xpath="SolidMechanics_MPM" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="SolversSurfaceGeneratorUniqueName">
					<xsd:selector xpath="SurfaceGenerator" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="Tasks" type="TasksType" maxOccurs="1">
				<xsd:unique name="TasksCellToCellDataCollectionUniqueName">
					<xsd:selector xpath="CellToCellDataCollection" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="TasksCompositionalMultiphaseReservoirPoromechanicsInitializationUniqueName">
					<xsd:selector xpath="CompositionalMultiphaseReservoirPoromechanicsInitialization" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="TasksCompositionalMultiphaseStatisticsUniqueName">
					<xsd:selector xpath="CompositionalMultiphaseStatistics" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="TasksHydrofractureInitializationUniqueName">
					<xsd:selector xpath="HydrofractureInitialization" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="TasksMultiphasePoromechanicsInitializationUniqueName">
					<xsd:selector xpath="MultiphasePoromechanicsInitialization" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="TasksPVTDriverUniqueName">
					<xsd:selector xpath="PVTDriver" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="TasksPackCollectionUniqueName">
					<xsd:selector xpath="PackCollection" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="TasksReactiveFluidDriverUniqueName">
					<xsd:selector xpath="ReactiveFluidDriver" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="TasksRelpermDriverUniqueName">
					<xsd:selector xpath="RelpermDriver" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="TasksSinglePhasePoromechanicsConformingFracturesInitializationUniqueName">
					<xsd:selector xpath="SinglePhasePoromechanicsConformingFracturesInitialization" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="TasksSinglePhasePoromechanicsEmbeddedFracturesInitializationUniqueName">
					<xsd:selector xpath="SinglePhasePoromechanicsEmbeddedFracturesInitialization" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="TasksSinglePhasePoromechanicsInitializationUniqueName">
					<xsd:selector xpath="SinglePhasePoromechanicsInitialization" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="TasksSinglePhaseReservoirPoromechanicsInitializationUniqueName">
					<xsd:selector xpath="SinglePhaseReservoirPoromechanicsInitialization" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="TasksSinglePhaseStatisticsUniqueName">
					<xsd:selector xpath="SinglePhaseStatistics" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="TasksSolidMechanicsStateResetUniqueName">
					<xsd:selector xpath="SolidMechanicsStateReset" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="TasksSolidMechanicsStatisticsUniqueName">
					<xsd:selector xpath="SolidMechanicsStatistics" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="TasksSourceFluxStatisticsUniqueName">
					<xsd:selector xpath="SourceFluxStatistics" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="TasksTriaxialDriverUniqueName">
					<xsd:selector xpath="TriaxialDriver" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="Constitutive" type="ConstitutiveType" maxOccurs="1">
				<xsd:unique name="domainConstitutiveBiotPorosityUniqueName">
					<xsd:selector xpath="BiotPorosity" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveBlackOilFluidUniqueName">
					<xsd:selector xpath="BlackOilFluid" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveBrooksCoreyBakerRelativePermeabilityUniqueName">
					<xsd:selector xpath="BrooksCoreyBakerRelativePermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveBrooksCoreyCapillaryPressureUniqueName">
					<xsd:selector xpath="BrooksCoreyCapillaryPressure" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveBrooksCoreyRelativePermeabilityUniqueName">
					<xsd:selector xpath="BrooksCoreyRelativePermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveBrooksCoreyStone2RelativePermeabilityUniqueName">
					<xsd:selector xpath="BrooksCoreyStone2RelativePermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveCO2BrineEzrokhiFluidUniqueName">
					<xsd:selector xpath="CO2BrineEzrokhiFluid" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveCO2BrineEzrokhiThermalFluidUniqueName">
					<xsd:selector xpath="CO2BrineEzrokhiThermalFluid" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveCO2BrinePhillipsFluidUniqueName">
					<xsd:selector xpath="CO2BrinePhillipsFluid" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveCO2BrinePhillipsThermalFluidUniqueName">
					<xsd:selector xpath="CO2BrinePhillipsThermalFluid" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveCarmanKozenyPermeabilityUniqueName">
					<xsd:selector xpath="CarmanKozenyPermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveCeramicDamageUniqueName">
					<xsd:selector xpath="CeramicDamage" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveCompositionalMultiphaseFluidUniqueName">
					<xsd:selector xpath="CompositionalMultiphaseFluid" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveCompositionalTwoPhaseFluidUniqueName">
					<xsd:selector xpath="CompositionalTwoPhaseFluid" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveCompositionalTwoPhaseFluidLohrenzBrayClarkUniqueName">
					<xsd:selector xpath="CompositionalTwoPhaseFluidLohrenzBrayClark" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveCompressibleSinglePhaseFluidUniqueName">
					<xsd:selector xpath="CompressibleSinglePhaseFluid" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveCompressibleSolidCarmanKozenyPermeabilityUniqueName">
					<xsd:selector xpath="CompressibleSolidCarmanKozenyPermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveCompressibleSolidConstantPermeabilityUniqueName">
					<xsd:selector xpath="CompressibleSolidConstantPermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveCompressibleSolidExponentialDecayPermeabilityUniqueName">
					<xsd:selector xpath="CompressibleSolidExponentialDecayPermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveCompressibleSolidParallelPlatesPermeabilityUniqueName">
					<xsd:selector xpath="CompressibleSolidParallelPlatesPermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveCompressibleSolidPressurePermeabilityUniqueName">
					<xsd:selector xpath="CompressibleSolidPressurePermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveCompressibleSolidSlipDependentPermeabilityUniqueName">
					<xsd:selector xpath="CompressibleSolidSlipDependentPermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveCompressibleSolidWillisRichardsPermeabilityUniqueName">
					<xsd:selector xpath="CompressibleSolidWillisRichardsPermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveConstantDiffusionUniqueName">
					<xsd:selector xpath="ConstantDiffusion" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveConstantPermeabilityUniqueName">
					<xsd:selector xpath="ConstantPermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveCoulombUniqueName">
					<xsd:selector xpath="Coulomb" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveDamageElasticIsotropicUniqueName">
					<xsd:selector xpath="DamageElasticIsotropic" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveDamageSpectralElasticIsotropicUniqueName">
					<xsd:selector xpath="DamageSpectralElasticIsotropic" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveDamageVolDevElasticIsotropicUniqueName">
					<xsd:selector xpath="DamageVolDevElasticIsotropic" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveDeadOilFluidUniqueName">
					<xsd:selector xpath="DeadOilFluid" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveDelftEggUniqueName">
					<xsd:selector xpath="DelftEgg" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveDruckerPragerUniqueName">
					<xsd:selector xpath="DruckerPrager" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveElasticIsotropicUniqueName">
					<xsd:selector xpath="ElasticIsotropic" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveElasticIsotropicPressureDependentUniqueName">
					<xsd:selector xpath="ElasticIsotropicPressureDependent" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveElasticOrthotropicUniqueName">
					<xsd:selector xpath="ElasticOrthotropic" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveElasticTransverseIsotropicUniqueName">
					<xsd:selector xpath="ElasticTransverseIsotropic" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveExponentialDecayPermeabilityUniqueName">
					<xsd:selector xpath="ExponentialDecayPermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveExtendedDruckerPragerUniqueName">
					<xsd:selector xpath="ExtendedDruckerPrager" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveFrictionlessContactUniqueName">
					<xsd:selector xpath="FrictionlessContact" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveHydraulicApertureTableUniqueName">
					<xsd:selector xpath="HydraulicApertureTable" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveJFunctionCapillaryPressureUniqueName">
					<xsd:selector xpath="JFunctionCapillaryPressure" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveLinearIsotropicDispersionUniqueName">
					<xsd:selector xpath="LinearIsotropicDispersion" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveModifiedCamClayUniqueName">
					<xsd:selector xpath="ModifiedCamClay" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveMultiPhaseConstantThermalConductivityUniqueName">
					<xsd:selector xpath="MultiPhaseConstantThermalConductivity" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveMultiPhaseVolumeWeightedThermalConductivityUniqueName">
					<xsd:selector xpath="MultiPhaseVolumeWeightedThermalConductivity" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveNullModelUniqueName">
					<xsd:selector xpath="NullModel" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveParallelPlatesPermeabilityUniqueName">
					<xsd:selector xpath="ParallelPlatesPermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveParticleFluidUniqueName">
					<xsd:selector xpath="ParticleFluid" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutivePerfectlyPlasticUniqueName">
					<xsd:selector xpath="PerfectlyPlastic" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutivePorousDamageElasticIsotropicUniqueName">
					<xsd:selector xpath="PorousDamageElasticIsotropic" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutivePorousDamageSpectralElasticIsotropicUniqueName">
					<xsd:selector xpath="PorousDamageSpectralElasticIsotropic" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutivePorousDamageVolDevElasticIsotropicUniqueName">
					<xsd:selector xpath="PorousDamageVolDevElasticIsotropic" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutivePorousDelftEggUniqueName">
					<xsd:selector xpath="PorousDelftEgg" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutivePorousDruckerPragerUniqueName">
					<xsd:selector xpath="PorousDruckerPrager" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutivePorousElasticIsotropicUniqueName">
					<xsd:selector xpath="PorousElasticIsotropic" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutivePorousElasticOrthotropicUniqueName">
					<xsd:selector xpath="PorousElasticOrthotropic" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutivePorousElasticTransverseIsotropicUniqueName">
					<xsd:selector xpath="PorousElasticTransverseIsotropic" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutivePorousExtendedDruckerPragerUniqueName">
					<xsd:selector xpath="PorousExtendedDruckerPrager" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutivePorousModifiedCamClayUniqueName">
					<xsd:selector xpath="PorousModifiedCamClay" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutivePorousViscoDruckerPragerUniqueName">
					<xsd:selector xpath="PorousViscoDruckerPrager" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutivePorousViscoExtendedDruckerPragerUniqueName">
					<xsd:selector xpath="PorousViscoExtendedDruckerPrager" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutivePorousViscoModifiedCamClayUniqueName">
					<xsd:selector xpath="PorousViscoModifiedCamClay" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutivePressurePermeabilityUniqueName">
					<xsd:selector xpath="PressurePermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutivePressurePorosityUniqueName">
					<xsd:selector xpath="PressurePorosity" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveProppantPermeabilityUniqueName">
					<xsd:selector xpath="ProppantPermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveProppantPorosityUniqueName">
					<xsd:selector xpath="ProppantPorosity" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveProppantSlurryFluidUniqueName">
					<xsd:selector xpath="ProppantSlurryFluid" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveProppantSolidProppantPermeabilityUniqueName">
					<xsd:selector xpath="ProppantSolidProppantPermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveReactiveBrineUniqueName">
					<xsd:selector xpath="ReactiveBrine" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveReactiveBrineThermalUniqueName">
					<xsd:selector xpath="ReactiveBrineThermal" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveSinglePhaseThermalConductivityUniqueName">
					<xsd:selector xpath="SinglePhaseThermalConductivity" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveSlipDependentPermeabilityUniqueName">
					<xsd:selector xpath="SlipDependentPermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveSolidInternalEnergyUniqueName">
					<xsd:selector xpath="SolidInternalEnergy" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveTableCapillaryPressureUniqueName">
					<xsd:selector xpath="TableCapillaryPressure" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveTableRelativePermeabilityUniqueName">
					<xsd:selector xpath="TableRelativePermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveTableRelativePermeabilityHysteresisUniqueName">
					<xsd:selector xpath="TableRelativePermeabilityHysteresis" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveThermalCompressibleSinglePhaseFluidUniqueName">
					<xsd:selector xpath="ThermalCompressibleSinglePhaseFluid" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveVanGenuchtenBakerRelativePermeabilityUniqueName">
					<xsd:selector xpath="VanGenuchtenBakerRelativePermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveVanGenuchtenCapillaryPressureUniqueName">
					<xsd:selector xpath="VanGenuchtenCapillaryPressure" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveVanGenuchtenStone2RelativePermeabilityUniqueName">
					<xsd:selector xpath="VanGenuchtenStone2RelativePermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveViscoDruckerPragerUniqueName">
					<xsd:selector xpath="ViscoDruckerPrager" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveViscoExtendedDruckerPragerUniqueName">
					<xsd:selector xpath="ViscoExtendedDruckerPrager" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveViscoModifiedCamClayUniqueName">
					<xsd:selector xpath="ViscoModifiedCamClay" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="domainConstitutiveWillisRichardsPermeabilityUniqueName">
					<xsd:selector xpath="WillisRichardsPermeability" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="ElementRegions" type="ElementRegionsType" maxOccurs="1" />
			<xsd:element name="ParticleRegions" type="ParticleRegionsType" maxOccurs="1" />
			<xsd:element name="Included" type="IncludedType" maxOccurs="1">
				<xsd:unique name="IncludedFileUniqueName">
					<xsd:selector xpath="File" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="Parameters" type="ParametersType" maxOccurs="1">
				<xsd:unique name="ParametersParameterUniqueName">
					<xsd:selector xpath="Parameter" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="Benchmarks" type="BenchmarksType" maxOccurs="1" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="EventsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="HaltEvent" type="HaltEventType">
				<xsd:unique name="EventsHaltEventHaltEventUniqueName">
					<xsd:selector xpath="HaltEvent" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="EventsHaltEventPeriodicEventUniqueName">
					<xsd:selector xpath="PeriodicEvent" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="EventsHaltEventSoloEventUniqueName">
					<xsd:selector xpath="SoloEvent" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="PeriodicEvent" type="PeriodicEventType">
				<xsd:unique name="EventsPeriodicEventHaltEventUniqueName">
					<xsd:selector xpath="HaltEvent" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="EventsPeriodicEventPeriodicEventUniqueName">
					<xsd:selector xpath="PeriodicEvent" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="EventsPeriodicEventSoloEventUniqueName">
					<xsd:selector xpath="SoloEvent" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="SoloEvent" type="SoloEventType">
				<xsd:unique name="EventsSoloEventHaltEventUniqueName">
					<xsd:selector xpath="HaltEvent" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="EventsSoloEventPeriodicEventUniqueName">
					<xsd:selector xpath="PeriodicEvent" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="EventsSoloEventSoloEventUniqueName">
					<xsd:selector xpath="SoloEvent" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
		</xsd:choice>
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxCycle => Maximum simulation cycle for the global event loop. Disabled by default.-->
		<xsd:attribute name="maxCycle" type="integer" default="2147483647" />
		<!--maxTime => Maximum simulation time for the global event loop. Disabled by default.-->
		<xsd:attribute name="maxTime" type="real64" default="1.79769e+308" />
		<!--minTime => Start simulation time for the global event loop.-->
		<xsd:attribute name="minTime" type="real64" default="0" />
		<!--timeOutputFormat => Format of the time in the GEOS log.-->
		<xsd:attribute name="timeOutputFormat" type="geos_EventManager_TimeOutputFormat" default="seconds" />
	</xsd:complexType>
	<xsd:complexType name="HaltEventType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="HaltEvent" type="HaltEventType" />
			<xsd:element name="PeriodicEvent" type="PeriodicEventType" />
			<xsd:element name="SoloEvent" type="SoloEventType" />
		</xsd:choice>
		<!--beginTime => Start time of this event.-->
		<xsd:attribute name="beginTime" type="real64" default="0" />
		<!--endTime => End time of this event.-->
		<xsd:attribute name="endTime" type="real64" default="1e+100" />
		<!--finalDtStretch => Allow the final dt request for this event to grow by this percentage to match the endTime exactly.-->
		<xsd:attribute name="finalDtStretch" type="real64" default="0.001" />
		<!--forceDt => While active, this event will request this timestep value (ignoring any children/targets requests).-->
		<xsd:attribute name="forceDt" type="real64" default="-1" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxEventDt => While active, this event will request a timestep <= this value (depending upon any child/target requests).-->
		<xsd:attribute name="maxEventDt" type="real64" default="-1" />
		<!--maxRuntime => The maximum allowable runtime for the job.-->
		<xsd:attribute name="maxRuntime" type="real64" use="required" />
		<!--target => Name of the object to be executed when the event criteria are met.-->
		<xsd:attribute name="target" type="groupNameRef" default="" />
		<!--targetExactStartStop => If this option is set, the event will reduce its timestep requests to match any specified beginTime/endTimes exactly.-->
		<xsd:attribute name="targetExactStartStop" type="integer" default="1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PeriodicEventType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="HaltEvent" type="HaltEventType" />
			<xsd:element name="PeriodicEvent" type="PeriodicEventType" />
			<xsd:element name="SoloEvent" type="SoloEventType" />
		</xsd:choice>
		<!--beginTime => Start time of this event.-->
		<xsd:attribute name="beginTime" type="real64" default="0" />
		<!--cycleFrequency => Event application frequency (cycle, default)-->
		<xsd:attribute name="cycleFrequency" type="integer" default="1" />
		<!--endTime => End time of this event.-->
		<xsd:attribute name="endTime" type="real64" default="1e+100" />
		<!--finalDtStretch => Allow the final dt request for this event to grow by this percentage to match the endTime exactly.-->
		<xsd:attribute name="finalDtStretch" type="real64" default="0.001" />
		<!--forceDt => While active, this event will request this timestep value (ignoring any children/targets requests).-->
		<xsd:attribute name="forceDt" type="real64" default="-1" />
		<!--function => Name of an optional function to evaluate when the time/cycle criteria are met.If the result is greater than the specified eventThreshold, the function will continue to execute.-->
		<xsd:attribute name="function" type="groupNameRef" default="" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxEventDt => While active, this event will request a timestep <= this value (depending upon any child/target requests).-->
		<xsd:attribute name="maxEventDt" type="real64" default="-1" />
		<!--object => If the optional function requires an object as an input, specify its path here.-->
		<xsd:attribute name="object" type="groupNameRef" default="" />
		<!--set => If the optional function is applied to an object, specify the setname to evaluate (default = everything).-->
		<xsd:attribute name="set" type="groupNameRef" default="" />
		<!--stat => If the optional function is applied to an object, specify the statistic to compare to the eventThreshold.The current options include: min, avg, and max.-->
		<xsd:attribute name="stat" type="integer" default="0" />
		<!--target => Name of the object to be executed when the event criteria are met.-->
		<xsd:attribute name="target" type="groupNameRef" default="" />
		<!--targetExactStartStop => If this option is set, the event will reduce its timestep requests to match any specified beginTime/endTimes exactly.-->
		<xsd:attribute name="targetExactStartStop" type="integer" default="1" />
		<!--targetExactTimestep => If this option is set, the event will reduce its timestep requests to match the specified timeFrequency perfectly: dt_request = min(dt_request, t_last + time_frequency - time)).-->
		<xsd:attribute name="targetExactTimestep" type="integer" default="1" />
		<!--threshold => If the optional function is used, the event will execute if the value returned by the function exceeds this threshold.-->
		<xsd:attribute name="threshold" type="real64" default="0" />
		<!--timeFrequency => Event application frequency (time).  Note: if this value is specified, it will override any cycle-based behavior.-->
		<xsd:attribute name="timeFrequency" type="real64" default="-1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SoloEventType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="HaltEvent" type="HaltEventType" />
			<xsd:element name="PeriodicEvent" type="PeriodicEventType" />
			<xsd:element name="SoloEvent" type="SoloEventType" />
		</xsd:choice>
		<!--beginTime => Start time of this event.-->
		<xsd:attribute name="beginTime" type="real64" default="0" />
		<!--endTime => End time of this event.-->
		<xsd:attribute name="endTime" type="real64" default="1e+100" />
		<!--finalDtStretch => Allow the final dt request for this event to grow by this percentage to match the endTime exactly.-->
		<xsd:attribute name="finalDtStretch" type="real64" default="0.001" />
		<!--forceDt => While active, this event will request this timestep value (ignoring any children/targets requests).-->
		<xsd:attribute name="forceDt" type="real64" default="-1" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxEventDt => While active, this event will request a timestep <= this value (depending upon any child/target requests).-->
		<xsd:attribute name="maxEventDt" type="real64" default="-1" />
		<!--target => Name of the object to be executed when the event criteria are met.-->
		<xsd:attribute name="target" type="groupNameRef" default="" />
		<!--targetCycle => Targeted cycle to execute the event.-->
		<xsd:attribute name="targetCycle" type="integer" default="-1" />
		<!--targetExactStartStop => If this option is set, the event will reduce its timestep requests to match any specified beginTime/endTimes exactly.-->
		<xsd:attribute name="targetExactStartStop" type="integer" default="1" />
		<!--targetExactTimestep => If this option is set, the event will reduce its timestep requests to match the specified execution time exactly: dt_request = min(dt_request, t_target - time)).-->
		<xsd:attribute name="targetExactTimestep" type="integer" default="1" />
		<!--targetTime => Targeted time to execute the event.-->
		<xsd:attribute name="targetTime" type="real64" default="-1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_EventManager_TimeOutputFormat">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|seconds|minutes|hours|days|years|full" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="FieldSpecificationsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Aquifer" type="AquiferType" />
			<xsd:element name="Dirichlet" type="DirichletType" />
			<xsd:element name="FieldSpecification" type="FieldSpecificationType" />
			<xsd:element name="HydrostaticEquilibrium" type="HydrostaticEquilibriumType" />
			<xsd:element name="PML" type="PMLType" />
			<xsd:element name="SourceFlux" type="SourceFluxType" />
			<xsd:element name="Traction" type="TractionType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="AquiferType">
		<!--allowAllPhasesIntoAquifer => Flag to allow all phases to flow into the aquifer. 
This flag only matters for the configuration in which flow is from reservoir to aquifer. 
    - If the flag is equal to 1, then all phases, including non-aqueous phases, are allowed to flow into the aquifer. 
     - If the flag is equal to 0, then only the water phase is allowed to flow into the aquifer. 
If you are in a configuration in which flow is from reservoir to aquifer and you expect non-aqueous phases to saturate the reservoir cells next to the aquifer, set this flag to 1. 
This keyword is ignored for single-phase flow simulations-->
		<xsd:attribute name="allowAllPhasesIntoAquifer" type="integer" default="0" />
		<!--aquiferAngle => Angle subtended by the aquifer boundary from the center of the reservoir [degress]-->
		<xsd:attribute name="aquiferAngle" type="real64" use="required" />
		<!--aquiferElevation => Aquifer elevation (positive going upward) [m]-->
		<xsd:attribute name="aquiferElevation" type="real64" use="required" />
		<!--aquiferInitialPressure => Aquifer initial pressure [Pa]-->
		<xsd:attribute name="aquiferInitialPressure" type="real64" use="required" />
		<!--aquiferInnerRadius => Aquifer inner radius [m]-->
		<xsd:attribute name="aquiferInnerRadius" type="real64" use="required" />
		<!--aquiferPermeability => Aquifer permeability [m^2]-->
		<xsd:attribute name="aquiferPermeability" type="real64" use="required" />
		<!--aquiferPorosity => Aquifer porosity-->
		<xsd:attribute name="aquiferPorosity" type="real64" use="required" />
		<!--aquiferThickness => Aquifer thickness [m]-->
		<xsd:attribute name="aquiferThickness" type="real64" use="required" />
		<!--aquiferTotalCompressibility => Aquifer total compressibility (rock and fluid) [Pa^-1]-->
		<xsd:attribute name="aquiferTotalCompressibility" type="real64" use="required" />
		<!--aquiferWaterDensity => Aquifer water density [kg.m^-3]-->
		<xsd:attribute name="aquiferWaterDensity" type="real64" use="required" />
		<!--aquiferWaterPhaseComponentFraction => Aquifer water phase component fraction. This keyword is ignored for single-phase flow simulations.-->
		<xsd:attribute name="aquiferWaterPhaseComponentFraction" type="real64_array" default="{0}" />
		<!--aquiferWaterPhaseComponentNames => Aquifer water phase component names. This keyword is ignored for single-phase flow simulations.-->
		<xsd:attribute name="aquiferWaterPhaseComponentNames" type="string_array" default="{}" />
		<!--aquiferWaterViscosity => Aquifer water viscosity [Pa.s]-->
		<xsd:attribute name="aquiferWaterViscosity" type="real64" use="required" />
		<!--bcApplicationTableName => Name of table that specifies the on/off application of the boundary condition.-->
		<xsd:attribute name="bcApplicationTableName" type="groupNameRef" default="" />
		<!--beginTime => Time at which the boundary condition will start being applied.-->
		<xsd:attribute name="beginTime" type="real64" default="-1e+99" />
		<!--direction => Direction to apply boundary condition to.-->
		<xsd:attribute name="direction" type="R1Tensor" default="{0,0,0}" />
		<!--endTime => Time at which the boundary condition will stop being applied.-->
		<xsd:attribute name="endTime" type="real64" default="1e+99" />
		<!--functionName => Name of function that specifies variation of the boundary condition.-->
		<xsd:attribute name="functionName" type="groupNameRef" default="" />
		<!--initialCondition => Boundary condition is applied as an initial condition.-->
		<xsd:attribute name="initialCondition" type="integer" default="0" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--pressureInfluenceFunctionName => Name of the table describing the pressure influence function
. If not provided, we use a default pressure influence function-->
		<xsd:attribute name="pressureInfluenceFunctionName" type="groupNameRef" default="" />
		<!--scale => Scale factor for value of the boundary condition.-->
		<xsd:attribute name="scale" type="real64" default="0" />
		<!--setNames => Name of sets that boundary condition is applied to.-->
		<xsd:attribute name="setNames" type="groupNameRef_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="DirichletType">
		<!--bcApplicationTableName => Name of table that specifies the on/off application of the boundary condition.-->
		<xsd:attribute name="bcApplicationTableName" type="groupNameRef" default="" />
		<!--beginTime => Time at which the boundary condition will start being applied.-->
		<xsd:attribute name="beginTime" type="real64" default="-1e+99" />
		<!--component => Component of field (if tensor) to apply boundary condition to.-->
		<xsd:attribute name="component" type="integer" default="-1" />
		<!--direction => Direction to apply boundary condition to.-->
		<xsd:attribute name="direction" type="R1Tensor" default="{0,0,0}" />
		<!--endTime => Time at which the boundary condition will stop being applied.-->
		<xsd:attribute name="endTime" type="real64" default="1e+99" />
		<!--fieldName => Name of field that boundary condition is applied to.-->
		<xsd:attribute name="fieldName" type="groupNameRef" default="" />
		<!--functionName => Name of function that specifies variation of the boundary condition.-->
		<xsd:attribute name="functionName" type="groupNameRef" default="" />
		<!--initialCondition => Boundary condition is applied as an initial condition.-->
		<xsd:attribute name="initialCondition" type="integer" default="0" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--objectPath => Path to the target field-->
		<xsd:attribute name="objectPath" type="groupNameRef" default="" />
		<!--scale => Scale factor for value of the boundary condition.-->
		<xsd:attribute name="scale" type="real64" default="0" />
		<!--setNames => Name of sets that boundary condition is applied to.-->
		<xsd:attribute name="setNames" type="groupNameRef_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="FieldSpecificationType">
		<!--bcApplicationTableName => Name of table that specifies the on/off application of the boundary condition.-->
		<xsd:attribute name="bcApplicationTableName" type="groupNameRef" default="" />
		<!--beginTime => Time at which the boundary condition will start being applied.-->
		<xsd:attribute name="beginTime" type="real64" default="-1e+99" />
		<!--component => Component of field (if tensor) to apply boundary condition to.-->
		<xsd:attribute name="component" type="integer" default="-1" />
		<!--direction => Direction to apply boundary condition to.-->
		<xsd:attribute name="direction" type="R1Tensor" default="{0,0,0}" />
		<!--endTime => Time at which the boundary condition will stop being applied.-->
		<xsd:attribute name="endTime" type="real64" default="1e+99" />
		<!--fieldName => Name of field that boundary condition is applied to.-->
		<xsd:attribute name="fieldName" type="groupNameRef" default="" />
		<!--functionName => Name of function that specifies variation of the boundary condition.-->
		<xsd:attribute name="functionName" type="groupNameRef" default="" />
		<!--initialCondition => Boundary condition is applied as an initial condition.-->
		<xsd:attribute name="initialCondition" type="integer" default="0" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--objectPath => Path to the target field-->
		<xsd:attribute name="objectPath" type="groupNameRef" default="" />
		<!--scale => Scale factor for value of the boundary condition.-->
		<xsd:attribute name="scale" type="real64" default="0" />
		<!--setNames => Name of sets that boundary condition is applied to.-->
		<xsd:attribute name="setNames" type="groupNameRef_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="HydrostaticEquilibriumType">
		<!--bcApplicationTableName => Name of table that specifies the on/off application of the boundary condition.-->
		<xsd:attribute name="bcApplicationTableName" type="groupNameRef" default="" />
		<!--beginTime => Time at which the boundary condition will start being applied.-->
		<xsd:attribute name="beginTime" type="real64" default="-1e+99" />
		<!--componentFractionVsElevationTableNames => Names of the tables specifying the (component fraction vs elevation) relationship for each component-->
		<xsd:attribute name="componentFractionVsElevationTableNames" type="groupNameRef_array" default="{}" />
		<!--componentNames => Names of the fluid components-->
		<xsd:attribute name="componentNames" type="string_array" default="{}" />
		<!--datumElevation => Datum elevation [m]-->
		<xsd:attribute name="datumElevation" type="real64" use="required" />
		<!--datumPressure => Datum pressure [Pa]-->
		<xsd:attribute name="datumPressure" type="real64" use="required" />
		<!--direction => Direction to apply boundary condition to.-->
		<xsd:attribute name="direction" type="R1Tensor" default="{0,0,0}" />
		<!--elevationIncrementInHydrostaticPressureTable => Elevation increment [m] in the hydrostatic pressure table constructed internally-->
		<xsd:attribute name="elevationIncrementInHydrostaticPressureTable" type="real64" default="0.6096" />
		<!--endTime => Time at which the boundary condition will stop being applied.-->
		<xsd:attribute name="endTime" type="real64" default="1e+99" />
		<!--equilibrationTolerance => Tolerance in the fixed-point iteration scheme used for hydrostatic initialization-->
		<xsd:attribute name="equilibrationTolerance" type="real64" default="0.001" />
		<!--functionName => Name of function that specifies variation of the boundary condition.-->
		<xsd:attribute name="functionName" type="groupNameRef" default="" />
		<!--initialPhaseName => Name of the phase initially saturating the reservoir-->
		<xsd:attribute name="initialPhaseName" type="groupNameRef" default="" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxNumberOfEquilibrationIterations => Maximum number of equilibration iterations-->
		<xsd:attribute name="maxNumberOfEquilibrationIterations" type="integer" default="5" />
		<!--objectPath => Path to the target field-->
		<xsd:attribute name="objectPath" type="groupNameRef" default="" />
		<!--scale => Scale factor for value of the boundary condition.-->
		<xsd:attribute name="scale" type="real64" default="0" />
		<!--temperatureVsElevationTableName => Name of the table specifying the (temperature [K] vs elevation) relationship-->
		<xsd:attribute name="temperatureVsElevationTableName" type="groupNameRef" default="" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PMLType">
		<!--bcApplicationTableName => Name of table that specifies the on/off application of the boundary condition.-->
		<xsd:attribute name="bcApplicationTableName" type="groupNameRef" default="" />
		<!--beginTime => Time at which the boundary condition will start being applied.-->
		<xsd:attribute name="beginTime" type="real64" default="-1e+99" />
		<!--component => Component of field (if tensor) to apply boundary condition to.-->
		<xsd:attribute name="component" type="integer" default="-1" />
		<!--direction => Direction to apply boundary condition to.-->
		<xsd:attribute name="direction" type="R1Tensor" default="{0,0,0}" />
		<!--endTime => Time at which the boundary condition will stop being applied.-->
		<xsd:attribute name="endTime" type="real64" default="1e+99" />
		<!--functionName => Name of function that specifies variation of the boundary condition.-->
		<xsd:attribute name="functionName" type="groupNameRef" default="" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--objectPath => Path to the target field-->
		<xsd:attribute name="objectPath" type="groupNameRef" default="" />
		<!--reflectivity => Desired reflectivity of the PML region, used to compute the damping profile-->
		<xsd:attribute name="reflectivity" type="real32" default="0.001" />
		<!--scale => Scale factor for value of the boundary condition.-->
		<xsd:attribute name="scale" type="real64" default="0" />
		<!--setNames => Name of sets that boundary condition is applied to.-->
		<xsd:attribute name="setNames" type="groupNameRef_array" use="required" />
		<!--thicknessMaxXYZ => Thickness of the PML region, at right, back, and bottom sides, used to compute the damping profile-->
		<xsd:attribute name="thicknessMaxXYZ" type="R1Tensor32" default="{-1,-1,-1}" />
		<!--thicknessMinXYZ => Thickness of the PML region, at left, front, and top sides, used to compute the damping profile-->
		<xsd:attribute name="thicknessMinXYZ" type="R1Tensor32" default="{-1,-1,-1}" />
		<!--waveSpeedMaxXYZ => Wave speed in the PML, at right, back, and bottom sides, used to compute the damping profile-->
		<xsd:attribute name="waveSpeedMaxXYZ" type="R1Tensor32" default="{-1,-1,-1}" />
		<!--waveSpeedMinXYZ => Wave speed in the PML, at left, front, and top sides, used to compute the damping profile-->
		<xsd:attribute name="waveSpeedMinXYZ" type="R1Tensor32" default="{-1,-1,-1}" />
		<!--xMax => Maximum (x,y,z) coordinates of the inner PML boundaries-->
		<xsd:attribute name="xMax" type="R1Tensor32" default="{3.40282e+38,3.40282e+38,3.40282e+38}" />
		<!--xMin => Minimum (x,y,z) coordinates of the inner PML boundaries-->
		<xsd:attribute name="xMin" type="R1Tensor32" default="{-3.40282e+38,-3.40282e+38,-3.40282e+38}" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SourceFluxType">
		<!--bcApplicationTableName => Name of table that specifies the on/off application of the boundary condition.-->
		<xsd:attribute name="bcApplicationTableName" type="groupNameRef" default="" />
		<!--beginTime => Time at which the boundary condition will start being applied.-->
		<xsd:attribute name="beginTime" type="real64" default="-1e+99" />
		<!--component => Component of field (if tensor) to apply boundary condition to.-->
		<xsd:attribute name="component" type="integer" default="-1" />
		<!--direction => Direction to apply boundary condition to.-->
		<xsd:attribute name="direction" type="R1Tensor" default="{0,0,0}" />
		<!--endTime => Time at which the boundary condition will stop being applied.-->
		<xsd:attribute name="endTime" type="real64" default="1e+99" />
		<!--functionName => Name of a function that specifies the variation of the production rate variations of this SourceFlux.Multiplied by scale. If no function is provided, a constant value of 1 is used.The producted fluid rate unit is in kg by default, or in mole if the flow solver has a useMass of 0.-->
		<xsd:attribute name="functionName" type="groupNameRef" default="" />
		<!--initialCondition => Boundary condition is applied as an initial condition.-->
		<xsd:attribute name="initialCondition" type="integer" default="0" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--objectPath => Path to the target field-->
		<xsd:attribute name="objectPath" type="groupNameRef" default="" />
		<!--scale => Multiplier of the functionName value. If no functionName is provided, this value is used directly.-->
		<xsd:attribute name="scale" type="real64" default="0" />
		<!--setNames => Name of sets that boundary condition is applied to.-->
		<xsd:attribute name="setNames" type="groupNameRef_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="TractionType">
		<!--bcApplicationTableName => Name of table that specifies the on/off application of the boundary condition.-->
		<xsd:attribute name="bcApplicationTableName" type="groupNameRef" default="" />
		<!--beginTime => Time at which the boundary condition will start being applied.-->
		<xsd:attribute name="beginTime" type="real64" default="-1e+99" />
		<!--direction => Direction to apply boundary condition to.-->
		<xsd:attribute name="direction" type="R1Tensor" default="{0,0,0}" />
		<!--endTime => Time at which the boundary condition will stop being applied.-->
		<xsd:attribute name="endTime" type="real64" default="1e+99" />
		<!--functionName => Name of function that specifies variation of the boundary condition.-->
		<xsd:attribute name="functionName" type="groupNameRef" default="" />
		<!--initialCondition => Boundary condition is applied as an initial condition.-->
		<xsd:attribute name="initialCondition" type="integer" default="0" />
		<!--inputStress => Input stress for tractionType = stress-->
		<xsd:attribute name="inputStress" type="R2SymTensor" default="{0,0,0,0,0,0}" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--objectPath => Path to the target field-->
		<xsd:attribute name="objectPath" type="groupNameRef" default="" />
		<!--scale => Scale factor for value of the boundary condition.-->
		<xsd:attribute name="scale" type="real64" default="0" />
		<!--setNames => Name of sets that boundary condition is applied to.-->
		<xsd:attribute name="setNames" type="groupNameRef_array" use="required" />
		<!--tractionType => Type of traction boundary condition. Options are:
vector - traction is applied to the faces as specified from the scale and direction,
normal - traction is applied to the faces as a pressure specified from the product of scale and the outward face normal,
stress - traction is applied to the faces as specified by the inner product of input stress and face normal.-->
		<xsd:attribute name="tractionType" type="geos_TractionBoundaryCondition_TractionType" default="vector" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_TractionBoundaryCondition_TractionType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|vector|normal|stress" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="FunctionsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="CompositeFunction" type="CompositeFunctionType" />
			<xsd:element name="MultivariableTableFunction" type="MultivariableTableFunctionType" />
			<xsd:element name="SymbolicFunction" type="SymbolicFunctionType" />
			<xsd:element name="TableFunction" type="TableFunctionType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="CompositeFunctionType">
		<!--expression => Composite math expression-->
		<xsd:attribute name="expression" type="string" default="" />
		<!--functionNames => List of source functions. The order must match the variableNames argument.-->
		<xsd:attribute name="functionNames" type="string_array" default="{}" />
		<!--inputVarNames => Name of fields are input to function.-->
		<xsd:attribute name="inputVarNames" type="groupNameRef_array" default="{}" />
		<!--variableNames => List of variables in expression-->
		<xsd:attribute name="variableNames" type="groupNameRef_array" default="{}" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="MultivariableTableFunctionType">
		<!--inputVarNames => Name of fields are input to function.-->
		<xsd:attribute name="inputVarNames" type="groupNameRef_array" default="{}" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SymbolicFunctionType">
		<!--expression => Symbolic math expression-->
		<xsd:attribute name="expression" type="string" use="required" />
		<!--inputVarNames => Name of fields are input to function.-->
		<xsd:attribute name="inputVarNames" type="groupNameRef_array" default="{}" />
		<!--variableNames => List of variables in expression.  The order must match the evaluate argument-->
		<xsd:attribute name="variableNames" type="groupNameRef_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="TableFunctionType">
		<!--coordinateFiles => List of coordinate file names for ND Table-->
		<xsd:attribute name="coordinateFiles" type="path_array" default="{}" />
		<!--coordinates => Coordinates inputs for 1D tables-->
		<xsd:attribute name="coordinates" type="real64_array" default="{0}" />
		<!--inputVarNames => Name of fields are input to function.-->
		<xsd:attribute name="inputVarNames" type="groupNameRef_array" default="{}" />
		<!--interpolation => Interpolation method. Valid options:
* linear
* nearest
* upper
* lower-->
		<xsd:attribute name="interpolation" type="geos_TableFunction_InterpolationType" default="linear" />
		<!--values => Values for 1D tables-->
		<xsd:attribute name="values" type="real64_array" default="{0}" />
		<!--voxelFile => Voxel file name for ND Table-->
		<xsd:attribute name="voxelFile" type="path" default="" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_TableFunction_InterpolationType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|linear|nearest|upper|lower" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="GeometryType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Box" type="BoxType" />
			<xsd:element name="CustomPolarObject" type="CustomPolarObjectType" />
			<xsd:element name="Cylinder" type="CylinderType" />
			<xsd:element name="Disc" type="DiscType" />
			<xsd:element name="Rectangle" type="RectangleType" />
			<xsd:element name="ThickPlane" type="ThickPlaneType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="BoxType">
		<!--strike => The strike angle of the box-->
		<xsd:attribute name="strike" type="real64" default="-90" />
		<!--xMax => Maximum (x,y,z) coordinates of the box-->
		<xsd:attribute name="xMax" type="R1Tensor" use="required" />
		<!--xMin => Minimum (x,y,z) coordinates of the box-->
		<xsd:attribute name="xMin" type="R1Tensor" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CustomPolarObjectType">
		<!--center => (x,y,z) coordinates of the center of the CustomPolarObject-->
		<xsd:attribute name="center" type="R1Tensor" use="required" />
		<!--coefficients => Coefficients of the CustomPolarObject function relating the localradius to the angle theta.-->
		<xsd:attribute name="coefficients" type="real64_array" use="required" />
		<!--lengthVector => Tangent vector defining the orthonormal basis along with the normal.-->
		<xsd:attribute name="lengthVector" type="R1Tensor" use="required" />
		<!--normal => Normal (n_x,n_y,n_z) to the plane (will be normalized automatically)-->
		<xsd:attribute name="normal" type="R1Tensor" use="required" />
		<!--tolerance => Tolerance to determine if a point sits on the CustomPolarObject or not. It is relative to the maximum dimension of the CustomPolarObject.-->
		<xsd:attribute name="tolerance" type="real64" default="1e-05" />
		<!--widthVector => Tangent vector defining the orthonormal basis along with the normal.-->
		<xsd:attribute name="widthVector" type="R1Tensor" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CylinderType">
		<!--firstFaceCenter => Center point of the first face of the cylinder-->
		<xsd:attribute name="firstFaceCenter" type="R1Tensor" use="required" />
		<!--innerRadius => Inner radius of the annulus-->
		<xsd:attribute name="innerRadius" type="real64" default="-1" />
		<!--outerRadius => Outer radius of the cylinder-->
		<xsd:attribute name="outerRadius" type="real64" use="required" />
		<!--secondFaceCenter => Center point of the second face of the cylinder-->
		<xsd:attribute name="secondFaceCenter" type="R1Tensor" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="DiscType">
		<!--center => (x,y,z) coordinates of the center of the disc-->
		<xsd:attribute name="center" type="R1Tensor" use="required" />
		<!--lengthVector => Tangent vector defining the orthonormal basis along with the normal.-->
		<xsd:attribute name="lengthVector" type="R1Tensor" use="required" />
		<!--normal => Normal (n_x,n_y,n_z) to the plane (will be normalized automatically)-->
		<xsd:attribute name="normal" type="R1Tensor" use="required" />
		<!--radius => Radius of the disc.-->
		<xsd:attribute name="radius" type="real64" use="required" />
		<!--tolerance => Tolerance to determine if a point sits on the disc or not. It is relative to the maximum dimension of the disc.-->
		<xsd:attribute name="tolerance" type="real64" default="1e-05" />
		<!--widthVector => Tangent vector defining the orthonormal basis along with the normal.-->
		<xsd:attribute name="widthVector" type="R1Tensor" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="RectangleType">
		<!--dimensions => Length and width of the bounded plane-->
		<xsd:attribute name="dimensions" type="real64_array" use="required" />
		<!--lengthVector => Tangent vector defining the orthonormal basis along with the normal.-->
		<xsd:attribute name="lengthVector" type="R1Tensor" use="required" />
		<!--normal => Normal (n_x,n_y,n_z) to the plane (will be normalized automatically)-->
		<xsd:attribute name="normal" type="R1Tensor" use="required" />
		<!--origin => Origin point (x,y,z) of the plane (basically, any point on the plane)-->
		<xsd:attribute name="origin" type="R1Tensor" use="required" />
		<!--tolerance => Tolerance to determine if a point sits on the plane or not. It is relative to the maximum dimension of the plane.-->
		<xsd:attribute name="tolerance" type="real64" default="1e-05" />
		<!--widthVector => Tangent vector defining the orthonormal basis along with the normal.-->
		<xsd:attribute name="widthVector" type="R1Tensor" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ThickPlaneType">
		<!--normal => Normal (n_x,n_y,n_z) to the plane (will be normalized automatically)-->
		<xsd:attribute name="normal" type="R1Tensor" use="required" />
		<!--origin => Origin point (x,y,z) of the plane (basically, any point on the plane)-->
		<xsd:attribute name="origin" type="R1Tensor" use="required" />
		<!--thickness => The total thickness of the plane (with half to each side)-->
		<xsd:attribute name="thickness" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="MeshType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="InternalMesh" type="InternalMeshType">
				<xsd:unique name="MeshInternalMeshInternalWellUniqueName">
					<xsd:selector xpath="InternalWell" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="MeshInternalMeshVTKWellUniqueName">
					<xsd:selector xpath="VTKWell" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="InternalWellbore" type="InternalWellboreType">
				<xsd:unique name="MeshInternalWellboreInternalWellUniqueName">
					<xsd:selector xpath="InternalWell" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="MeshInternalWellboreVTKWellUniqueName">
					<xsd:selector xpath="VTKWell" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="ParticleMesh" type="ParticleMeshType" />
			<xsd:element name="VTKMesh" type="VTKMeshType">
				<xsd:unique name="MeshVTKMeshInternalWellUniqueName">
					<xsd:selector xpath="InternalWell" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="MeshVTKMeshVTKWellUniqueName">
					<xsd:selector xpath="VTKWell" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="InternalMeshType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="InternalWell" type="InternalWellType">
				<xsd:unique name="MeshInternalMeshInternalWellPerforationUniqueName">
					<xsd:selector xpath="Perforation" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="VTKWell" type="VTKWellType">
				<xsd:unique name="MeshInternalMeshVTKWellPerforationUniqueName">
					<xsd:selector xpath="Perforation" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
		</xsd:choice>
		<!--cellBlockNames => Names of each mesh block-->
		<xsd:attribute name="cellBlockNames" type="groupNameRef_array" use="required" />
		<!--elementTypes => Element types of each mesh block-->
		<xsd:attribute name="elementTypes" type="string_array" use="required" />
		<!--nx => Number of elements in the x-direction within each mesh block-->
		<xsd:attribute name="nx" type="integer_array" use="required" />
		<!--ny => Number of elements in the y-direction within each mesh block-->
		<xsd:attribute name="ny" type="integer_array" use="required" />
		<!--nz => Number of elements in the z-direction within each mesh block-->
		<xsd:attribute name="nz" type="integer_array" use="required" />
		<!--positionTolerance => A position tolerance to verify if a node belong to a nodeset-->
		<xsd:attribute name="positionTolerance" type="real64" default="1e-10" />
		<!--trianglePattern => Pattern by which to decompose the hex mesh into wedges-->
		<xsd:attribute name="trianglePattern" type="integer" default="0" />
		<!--xBias => Bias of element sizes in the x-direction within each mesh block (dx_left=(1+b)*L/N, dx_right=(1-b)*L/N)-->
		<xsd:attribute name="xBias" type="real64_array" default="{1}" />
		<!--xCoords => x-coordinates of each mesh block vertex-->
		<xsd:attribute name="xCoords" type="real64_array" use="required" />
		<!--yBias => Bias of element sizes in the y-direction within each mesh block (dy_left=(1+b)*L/N, dx_right=(1-b)*L/N)-->
		<xsd:attribute name="yBias" type="real64_array" default="{1}" />
		<!--yCoords => y-coordinates of each mesh block vertex-->
		<xsd:attribute name="yCoords" type="real64_array" use="required" />
		<!--zBias => Bias of element sizes in the z-direction within each mesh block (dz_left=(1+b)*L/N, dz_right=(1-b)*L/N)-->
		<xsd:attribute name="zBias" type="real64_array" default="{1}" />
		<!--zCoords => z-coordinates of each mesh block vertex-->
		<xsd:attribute name="zCoords" type="real64_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="InternalWellType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Perforation" type="PerforationType" />
		</xsd:choice>
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--minElementLength => Minimum length of a well element, computed as (segment length / number of elements per segment ) [m]-->
		<xsd:attribute name="minElementLength" type="real64" default="0.001" />
		<!--minSegmentLength => Minimum length of a well segment [m]-->
		<xsd:attribute name="minSegmentLength" type="real64" default="0.01" />
		<!--numElementsPerSegment => Number of well elements per polyline segment-->
		<xsd:attribute name="numElementsPerSegment" type="integer" use="required" />
		<!--polylineNodeCoords => Physical coordinates of the well polyline nodes-->
		<xsd:attribute name="polylineNodeCoords" type="real64_array2d" use="required" />
		<!--polylineSegmentConn => Connectivity of the polyline segments-->
		<xsd:attribute name="polylineSegmentConn" type="globalIndex_array2d" use="required" />
		<!--radius => Radius of the well [m]-->
		<xsd:attribute name="radius" type="real64" use="required" />
		<!--wellControlsName => Name of the set of constraints associated with this well-->
		<xsd:attribute name="wellControlsName" type="string" use="required" />
		<!--wellRegionName => Name of the well element region-->
		<xsd:attribute name="wellRegionName" type="string" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PerforationType">
		<!--distanceFromHead => Linear distance from well head to the perforation-->
		<xsd:attribute name="distanceFromHead" type="real64" use="required" />
		<!--skinFactor => Perforation skin factor-->
		<xsd:attribute name="skinFactor" type="real64" default="0" />
		<!--transmissibility => Perforation transmissibility-->
		<xsd:attribute name="transmissibility" type="real64" default="-1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="VTKWellType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Perforation" type="PerforationType" />
		</xsd:choice>
		<!--file => Path to the well file-->
		<xsd:attribute name="file" type="path" use="required" />
		<!--minElementLength => Minimum length of a well element, computed as (segment length / number of elements per segment ) [m]-->
		<xsd:attribute name="minElementLength" type="real64" default="0.001" />
		<!--minSegmentLength => Minimum length of a well segment [m]-->
		<xsd:attribute name="minSegmentLength" type="real64" default="0.01" />
		<!--numElementsPerSegment => Number of well elements per polyline segment-->
		<xsd:attribute name="numElementsPerSegment" type="integer" use="required" />
		<!--radius => Radius of the well [m]-->
		<xsd:attribute name="radius" type="real64" use="required" />
		<!--wellControlsName => Name of the set of constraints associated with this well-->
		<xsd:attribute name="wellControlsName" type="string" use="required" />
		<!--wellRegionName => Name of the well element region-->
		<xsd:attribute name="wellRegionName" type="string" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="InternalWellboreType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="InternalWell" type="InternalWellType">
				<xsd:unique name="MeshInternalWellboreInternalWellPerforationUniqueName">
					<xsd:selector xpath="Perforation" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="VTKWell" type="VTKWellType">
				<xsd:unique name="MeshInternalWellboreVTKWellPerforationUniqueName">
					<xsd:selector xpath="Perforation" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
		</xsd:choice>
		<!--autoSpaceRadialElems => Automatically set number and spacing of elements in the radial direction. This overrides the values of nr!Value in each block indicates factor to scale the radial increment.Larger numbers indicate larger radial elements.-->
		<xsd:attribute name="autoSpaceRadialElems" type="real64_array" default="{-1}" />
		<!--cartesianMappingInnerRadius => If using a Cartesian aligned outer boundary, this is inner radius at which to start the mapping.-->
		<xsd:attribute name="cartesianMappingInnerRadius" type="real64" default="1e+99" />
		<!--cellBlockNames => Names of each mesh block-->
		<xsd:attribute name="cellBlockNames" type="groupNameRef_array" use="required" />
		<!--elementTypes => Element types of each mesh block-->
		<xsd:attribute name="elementTypes" type="string_array" use="required" />
		<!--hardRadialCoords => Sets the radial spacing to specified values-->
		<xsd:attribute name="hardRadialCoords" type="real64_array" default="{0}" />
		<!--nr => Number of elements in the radial direction-->
		<xsd:attribute name="nr" type="integer_array" use="required" />
		<!--nt => Number of elements in the tangent direction-->
		<xsd:attribute name="nt" type="integer_array" use="required" />
		<!--nz => Number of elements in the z-direction within each mesh block-->
		<xsd:attribute name="nz" type="integer_array" use="required" />
		<!--positionTolerance => A position tolerance to verify if a node belong to a nodeset-->
		<xsd:attribute name="positionTolerance" type="real64" default="1e-10" />
		<!--rBias => Bias of element sizes in the radial direction-->
		<xsd:attribute name="rBias" type="real64_array" default="{-0.8}" />
		<!--radius => Wellbore radius-->
		<xsd:attribute name="radius" type="real64_array" use="required" />
		<!--theta => Tangent angle defining geometry size: 90 for quarter, 180 for half and 360 for full wellbore geometry-->
		<xsd:attribute name="theta" type="real64_array" use="required" />
		<!--trajectory => Coordinates defining the wellbore trajectory-->
		<xsd:attribute name="trajectory" type="real64_array2d" default="{{0}}" />
		<!--trianglePattern => Pattern by which to decompose the hex mesh into wedges-->
		<xsd:attribute name="trianglePattern" type="integer" default="0" />
		<!--useCartesianOuterBoundary => Enforce a Cartesian aligned outer boundary on the outer block starting with the radial block specified in this value-->
		<xsd:attribute name="useCartesianOuterBoundary" type="integer" default="1000000" />
		<!--xBias => Bias of element sizes in the x-direction within each mesh block (dx_left=(1+b)*L/N, dx_right=(1-b)*L/N)-->
		<xsd:attribute name="xBias" type="real64_array" default="{1}" />
		<!--yBias => Bias of element sizes in the y-direction within each mesh block (dy_left=(1+b)*L/N, dx_right=(1-b)*L/N)-->
		<xsd:attribute name="yBias" type="real64_array" default="{1}" />
		<!--zBias => Bias of element sizes in the z-direction within each mesh block (dz_left=(1+b)*L/N, dz_right=(1-b)*L/N)-->
		<xsd:attribute name="zBias" type="real64_array" default="{1}" />
		<!--zCoords => z-coordinates of each mesh block vertex-->
		<xsd:attribute name="zCoords" type="real64_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ParticleMeshType">
		<!--headerFile => path to the header file-->
		<xsd:attribute name="headerFile" type="path" use="required" />
		<!--particleBlockNames => Names of each particle block-->
		<xsd:attribute name="particleBlockNames" type="string_array" use="required" />
		<!--particleFile => path to the particle file-->
		<xsd:attribute name="particleFile" type="path" use="required" />
		<!--particleTypes => Particle types of each particle block-->
		<xsd:attribute name="particleTypes" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="VTKMeshType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="InternalWell" type="InternalWellType">
				<xsd:unique name="MeshVTKMeshInternalWellPerforationUniqueName">
					<xsd:selector xpath="Perforation" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="VTKWell" type="VTKWellType">
				<xsd:unique name="MeshVTKMeshVTKWellPerforationUniqueName">
					<xsd:selector xpath="Perforation" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
		</xsd:choice>
		<!--faceBlocks => For multi-block files, names of the face mesh block.-->
		<xsd:attribute name="faceBlocks" type="groupNameRef_array" default="{}" />
		<!--fieldNamesInGEOS => Names of the volumic fields in GEOS to import into-->
		<xsd:attribute name="fieldNamesInGEOS" type="groupNameRef_array" default="{}" />
		<!--fieldsToImport => Volumic fields to be imported from the external mesh file-->
		<xsd:attribute name="fieldsToImport" type="groupNameRef_array" default="{}" />
		<!--file => Path to the mesh file-->
		<xsd:attribute name="file" type="path" use="required" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--mainBlockName => For multi-block files, name of the 3d mesh block.-->
		<xsd:attribute name="mainBlockName" type="groupNameRef" default="main" />
		<!--nodesetNames => Names of the VTK nodesets to import-->
		<xsd:attribute name="nodesetNames" type="groupNameRef_array" default="{}" />
		<!--partitionMethod => Method (library) used to partition the mesh-->
		<xsd:attribute name="partitionMethod" type="geos_vtk_PartitionMethod" default="parmetis" />
		<!--partitionRefinement => Number of partitioning refinement iterations (defaults to 1, recommended value).A value of 0 disables graph partitioning and keeps simple kd-tree partitions (not recommended). Values higher than 1 may lead to slightly improved partitioning, but yield diminishing returns.-->
		<xsd:attribute name="partitionRefinement" type="integer" default="1" />
		<!--regionAttribute => Name of the VTK cell attribute to use as region marker-->
		<xsd:attribute name="regionAttribute" type="groupNameRef" default="attribute" />
		<!--scale => Scale the coordinates of the vertices by given scale factors (after translation)-->
		<xsd:attribute name="scale" type="R1Tensor" default="{1,1,1}" />
		<!--surfacicFieldsInGEOS => Names of the surfacic fields in GEOS to import into-->
		<xsd:attribute name="surfacicFieldsInGEOS" type="groupNameRef_array" default="{}" />
		<!--surfacicFieldsToImport => Surfacic fields to be imported from the external mesh file-->
		<xsd:attribute name="surfacicFieldsToImport" type="groupNameRef_array" default="{}" />
		<!--translate => Translate the coordinates of the vertices by a given vector (prior to scaling)-->
		<xsd:attribute name="translate" type="R1Tensor" default="{0,0,0}" />
		<!--useGlobalIds => Controls the use of global IDs in the input file for cells and points. If set to 0 (default value), the GlobalId arrays in the input mesh are used if available, and generated otherwise. If set to a negative value, the GlobalId arrays in the input mesh are not used, and generated global Ids are automatically generated. If set to a positive value, the GlobalId arrays in the input mesh are used and required, and the simulation aborts if they are not available-->
		<xsd:attribute name="useGlobalIds" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_vtk_PartitionMethod">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|parmetis|ptscotch" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="NumericalMethodsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="FiniteElements" type="FiniteElementsType" maxOccurs="1">
				<xsd:unique name="NumericalMethodsFiniteElementsFiniteElementSpaceUniqueName">
					<xsd:selector xpath="FiniteElementSpace" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="FiniteVolume" type="FiniteVolumeType" maxOccurs="1">
				<xsd:unique name="NumericalMethodsFiniteVolumeHybridMimeticDiscretizationUniqueName">
					<xsd:selector xpath="HybridMimeticDiscretization" />
					<xsd:field xpath="@name" />
				</xsd:unique>
				<xsd:unique name="NumericalMethodsFiniteVolumeTwoPointFluxApproximationUniqueName">
					<xsd:selector xpath="TwoPointFluxApproximation" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="FiniteElementsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="FiniteElementSpace" type="FiniteElementSpaceType" />
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="FiniteElementSpaceType">
		<!--formulation => Specifier to indicate any specialized formuations. For instance, one of the many enhanced assumed strain methods of the Hexahedron parent shape would be indicated here-->
		<xsd:attribute name="formulation" type="geos_FiniteElementDiscretization_Formulation" default="default" />
		<!--order => The order of the finite element basis.-->
		<xsd:attribute name="order" type="integer" use="required" />
		<!--useVirtualElements => Specifier to indicate whether to force the use of VEM-->
		<xsd:attribute name="useVirtualElements" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_FiniteElementDiscretization_Formulation">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|default|SEM" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="LinearSolverParametersType">
		<!--adaptiveExponent => Exponent parameter for adaptive method-->
		<xsd:attribute name="adaptiveExponent" type="real64" default="1" />
		<!--adaptiveGamma => Gamma parameter for adaptive method-->
		<xsd:attribute name="adaptiveGamma" type="real64" default="0.1" />
		<!--amgAggressiveCoarseningLevels => AMG number of levels for aggressive coarsening-->
		<xsd:attribute name="amgAggressiveCoarseningLevels" type="integer" default="0" />
		<!--amgAggressiveCoarseningPaths => AMG number of paths for aggressive coarsening-->
		<xsd:attribute name="amgAggressiveCoarseningPaths" type="integer" default="1" />
		<!--amgAggressiveInterpType => AMG aggressive interpolation algorithm. Available options are: ``default|extendedIStage2|standardStage2|extendedStage2|multipass|modifiedExtended|modifiedExtendedI|modifiedExtendedE|modifiedMultipass``-->
		<xsd:attribute name="amgAggressiveInterpType" type="geos_LinearSolverParameters_AMG_AggInterpType" default="multipass" />
		<!--amgCoarseSolver => AMG coarsest level solver/smoother type. Available options are: ``default|jacobi|l1jacobi|fgs|sgs|l1sgs|chebyshev|direct|bgs``-->
		<xsd:attribute name="amgCoarseSolver" type="geos_LinearSolverParameters_AMG_CoarseType" default="direct" />
		<!--amgCoarseningType => AMG coarsening algorithm. Available options are: ``default|CLJP|RugeStueben|Falgout|PMIS|HMIS``-->
		<xsd:attribute name="amgCoarseningType" type="geos_LinearSolverParameters_AMG_CoarseningType" default="HMIS" />
		<!--amgInterpolationMaxNonZeros => AMG interpolation maximum number of nonzeros per row-->
		<xsd:attribute name="amgInterpolationMaxNonZeros" type="integer" default="4" />
		<!--amgInterpolationType => AMG interpolation algorithm. Available options are: ``default|modifiedClassical|direct|multipass|extendedI|standard|extended|directBAMG|modifiedExtended|modifiedExtendedI|modifiedExtendedE``-->
		<xsd:attribute name="amgInterpolationType" type="geos_LinearSolverParameters_AMG_InterpType" default="extendedI" />
		<!--amgNullSpaceType => AMG near null space approximation. Available options are:``constantModes|rigidBodyModes``-->
		<xsd:attribute name="amgNullSpaceType" type="geos_LinearSolverParameters_AMG_NullSpaceType" default="constantModes" />
		<!--amgNumFunctions => AMG number of functions-->
		<xsd:attribute name="amgNumFunctions" type="integer" default="1" />
		<!--amgNumSweeps => AMG smoother sweeps-->
		<xsd:attribute name="amgNumSweeps" type="integer" default="1" />
		<!--amgRelaxWeight => AMG relaxation factor for the smoother-->
		<xsd:attribute name="amgRelaxWeight" type="real64" default="1" />
		<!--amgSeparateComponents => AMG apply separate component filter for multi-variable problems-->
		<xsd:attribute name="amgSeparateComponents" type="integer" default="0" />
		<!--amgSmootherType => AMG smoother type. Available options are: ``default|jacobi|l1jacobi|fgs|bgs|sgs|l1sgs|chebyshev|ilu0|ilut|ic0|ict``-->
		<xsd:attribute name="amgSmootherType" type="geos_LinearSolverParameters_AMG_SmootherType" default="l1sgs" />
		<!--amgThreshold => AMG strength-of-connection threshold-->
		<xsd:attribute name="amgThreshold" type="real64" default="0" />
		<!--directCheckResidual => Whether to check the linear system solution residual-->
		<xsd:attribute name="directCheckResidual" type="integer" default="0" />
		<!--directColPerm => How to permute the columns. Available options are: ``none|MMD_AtplusA|MMD_AtA|colAMD|metis|parmetis``-->
		<xsd:attribute name="directColPerm" type="geos_LinearSolverParameters_Direct_ColPerm" default="metis" />
		<!--directEquil => Whether to scale the rows and columns of the matrix-->
		<xsd:attribute name="directEquil" type="integer" default="1" />
		<!--directIterRef => Whether to perform iterative refinement-->
		<xsd:attribute name="directIterRef" type="integer" default="1" />
		<!--directParallel => Whether to use a parallel solver (instead of a serial one)-->
		<xsd:attribute name="directParallel" type="integer" default="1" />
		<!--directReplTinyPivot => Whether to replace tiny pivots by sqrt(epsilon)*norm(A)-->
		<xsd:attribute name="directReplTinyPivot" type="integer" default="1" />
		<!--directRowPerm => How to permute the rows. Available options are: ``none|mc64``-->
		<xsd:attribute name="directRowPerm" type="geos_LinearSolverParameters_Direct_RowPerm" default="mc64" />
		<!--iluFill => ILU(K) fill factor-->
		<xsd:attribute name="iluFill" type="integer" default="0" />
		<!--iluThreshold => ILU(T) threshold factor-->
		<xsd:attribute name="iluThreshold" type="real64" default="0" />
		<!--krylovAdaptiveTol => Use Eisenstat-Walker adaptive linear tolerance-->
		<xsd:attribute name="krylovAdaptiveTol" type="integer" default="0" />
		<!--krylovMaxIter => Maximum iterations allowed for an iterative solver-->
		<xsd:attribute name="krylovMaxIter" type="integer" default="200" />
		<!--krylovMaxRestart => Maximum iterations before restart (GMRES only)-->
		<xsd:attribute name="krylovMaxRestart" type="integer" default="200" />
		<!--krylovStrongestTol => Strongest-allowed tolerance for adaptive method-->
		<xsd:attribute name="krylovStrongestTol" type="real64" default="1e-08" />
		<!--krylovTol => Relative convergence tolerance of the iterative method
If the method converges, the iterative solution :math:`\mathsf{x}_k` is such that
the relative residual norm satisfies:
:math:`\left\lVert \mathsf{b} - \mathsf{A} \mathsf{x}_k \right\rVert_2` < ``krylovTol`` * :math:`\left\lVert\mathsf{b}\right\rVert_2`-->
		<xsd:attribute name="krylovTol" type="real64" default="1e-06" />
		<!--krylovWeakestTol => Weakest-allowed tolerance for adaptive method-->
		<xsd:attribute name="krylovWeakestTol" type="real64" default="0.001" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--preconditionerType => Preconditioner type. Available options are: ``none|jacobi|l1jacobi|fgs|sgs|l1sgs|chebyshev|iluk|ilut|icc|ict|amg|mgr|block|direct|bgs``-->
		<xsd:attribute name="preconditionerType" type="geos_LinearSolverParameters_PreconditionerType" default="iluk" />
		<!--solverType => Linear solver type. Available options are: ``direct|cg|gmres|fgmres|bicgstab|preconditioner``-->
		<xsd:attribute name="solverType" type="geos_LinearSolverParameters_SolverType" default="direct" />
		<!--stopIfError => Whether to stop the simulation if the linear solver reports an error-->
		<xsd:attribute name="stopIfError" type="integer" default="1" />
	</xsd:complexType>
	<xsd:simpleType name="geos_LinearSolverParameters_AMG_AggInterpType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|default|extendedIStage2|standardStage2|extendedStage2|multipass|modifiedExtended|modifiedExtendedI|modifiedExtendedE|modifiedMultipass" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geos_LinearSolverParameters_AMG_CoarseType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|default|jacobi|l1jacobi|fgs|sgs|l1sgs|chebyshev|direct|bgs" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geos_LinearSolverParameters_AMG_CoarseningType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|default|CLJP|RugeStueben|Falgout|PMIS|HMIS" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geos_LinearSolverParameters_AMG_InterpType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|default|modifiedClassical|direct|multipass|extendedI|standard|extended|directBAMG|modifiedExtended|modifiedExtendedI|modifiedExtendedE" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geos_LinearSolverParameters_AMG_NullSpaceType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|constantModes|rigidBodyModes" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geos_LinearSolverParameters_AMG_SmootherType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|default|jacobi|l1jacobi|fgs|bgs|sgs|l1sgs|chebyshev|ilu0|ilut|ic0|ict" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geos_LinearSolverParameters_Direct_ColPerm">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|none|MMD_AtplusA|MMD_AtA|colAMD|metis|parmetis" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geos_LinearSolverParameters_Direct_RowPerm">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|none|mc64" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geos_LinearSolverParameters_PreconditionerType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|none|jacobi|l1jacobi|fgs|sgs|l1sgs|chebyshev|iluk|ilut|icc|ict|amg|mgr|block|direct|bgs" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geos_LinearSolverParameters_SolverType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|direct|cg|gmres|fgmres|bicgstab|preconditioner" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="NonlinearSolverParametersType">
		<!--allowNonConverged => Allow non-converged solution to be accepted. (i.e. exit from the Newton loop without achieving the desired tolerance)-->
		<xsd:attribute name="allowNonConverged" type="integer" default="0" />
		<!--configurationTolerance => Configuration tolerance-->
		<xsd:attribute name="configurationTolerance" type="real64" default="0" />
		<!--couplingType => Type of coupling. Valid options:
* FullyImplicit
* Sequential-->
		<xsd:attribute name="couplingType" type="geos_NonlinearSolverParameters_CouplingType" default="FullyImplicit" />
		<!--lineSearchAction => How the line search is to be used. Options are: 
 * None    - Do not use line search.
* Attempt - Use line search. Allow exit from line search without achieving smaller residual than starting residual.
* Require - Use line search. If smaller residual than starting resdual is not achieved, cut time-step.-->
		<xsd:attribute name="lineSearchAction" type="geos_NonlinearSolverParameters_LineSearchAction" default="Attempt" />
		<!--lineSearchCutFactor => Line search cut factor. For instance, a value of 0.5 will result in the effective application of the last solution by a factor of (0.5, 0.25, 0.125, ...)-->
		<xsd:attribute name="lineSearchCutFactor" type="real64" default="0.5" />
		<!--lineSearchInterpolationType => Strategy to cut the solution update during the line search. Options are: 
 * Linear
* Parabolic-->
		<xsd:attribute name="lineSearchInterpolationType" type="geos_NonlinearSolverParameters_LineSearchInterpolationType" default="Linear" />
		<!--lineSearchMaxCuts => Maximum number of line search cuts.-->
		<xsd:attribute name="lineSearchMaxCuts" type="integer" default="4" />
		<!--lineSearchResidualFactor => Factor to determine residual increase (recommended values: 1.1 (conservative), 2.0 (relaxed), 10.0 (aggressive)).-->
		<xsd:attribute name="lineSearchResidualFactor" type="real64" default="1" />
		<!--lineSearchStartingIteration => Iteration when line search starts.-->
		<xsd:attribute name="lineSearchStartingIteration" type="integer" default="0" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxAllowedResidualNorm => Maximum value of residual norm that is allowed in a Newton loop-->
		<xsd:attribute name="maxAllowedResidualNorm" type="real64" default="1e+09" />
		<!--maxNumConfigurationAttempts => Max number of times that the configuration can be changed-->
		<xsd:attribute name="maxNumConfigurationAttempts" type="integer" default="10" />
		<!--maxSubSteps => Maximum number of time sub-steps allowed for the solver-->
		<xsd:attribute name="maxSubSteps" type="integer" default="10" />
		<!--maxTimeStepCuts => Max number of time-step cuts-->
		<xsd:attribute name="maxTimeStepCuts" type="integer" default="2" />
		<!--minNormalizer => Value used to make sure that residual normalizers are not too small when computing residual norm.-->
		<xsd:attribute name="minNormalizer" type="real64" default="1e-12" />
		<!--minTimeStepIncreaseInterval => Minimum number of cycles since the last time-step cut for increasing the time-step again.-->
		<xsd:attribute name="minTimeStepIncreaseInterval" type="integer" default="10" />
		<!--newtonMaxIter => Maximum number of iterations that are allowed in a Newton loop.-->
		<xsd:attribute name="newtonMaxIter" type="integer" default="5" />
		<!--newtonMinIter => Minimum number of iterations that are required before exiting the Newton loop.-->
		<xsd:attribute name="newtonMinIter" type="integer" default="1" />
		<!--newtonTol => The required tolerance in order to exit the Newton iteration loop.-->
		<xsd:attribute name="newtonTol" type="real64" default="1e-06" />
		<!--nonlinearAccelerationType => Nonlinear acceleration type for sequential solver.-->
		<xsd:attribute name="nonlinearAccelerationType" type="geos_NonlinearSolverParameters_NonlinearAccelerationType" default="None" />
		<!--sequentialConvergenceCriterion => Criterion used to check outer-loop convergence in sequential schemes. Valid options:
* ResidualNorm
* NumberOfNonlinearIterations
* SolutionIncrements-->
		<xsd:attribute name="sequentialConvergenceCriterion" type="geos_NonlinearSolverParameters_SequentialConvergenceCriterion" default="ResidualNorm" />
		<!--subcycling => Flag to decide whether to iterate between sequentially coupled solvers or not.-->
		<xsd:attribute name="subcycling" type="integer" default="0" />
		<!--timeStepCutFactor => Factor by which the time-step will be cut if a time-step cut is required.-->
		<xsd:attribute name="timeStepCutFactor" type="real64" default="0.5" />
		<!--timeStepDecreaseFactor => Factor by which the time-step is decreased when the number of Newton iterations is large.-->
		<xsd:attribute name="timeStepDecreaseFactor" type="real64" default="0.5" />
		<!--timeStepDecreaseIterLimit => Fraction of the max Newton iterations above which the solver asks for the time-step to be decreased for the next time-step.-->
		<xsd:attribute name="timeStepDecreaseIterLimit" type="real64" default="0.7" />
		<!--timeStepIncreaseFactor => Factor by which the time-step is increased when the number of Newton iterations is small.-->
		<xsd:attribute name="timeStepIncreaseFactor" type="real64" default="2" />
		<!--timeStepIncreaseIterLimit => Fraction of the max Newton iterations below which the solver asks for the time-step to be increased for the next time-step.-->
		<xsd:attribute name="timeStepIncreaseIterLimit" type="real64" default="0.4" />
		<!--normType => Norm used by the flow solver to check nonlinear convergence. Valid options:
* Linfinity
* L2-->
		<xsd:attribute name="normType" type="geos_solverBaseKernels_NormType" default="Linfinity" />
	</xsd:complexType>
	<xsd:simpleType name="geos_NonlinearSolverParameters_CouplingType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|FullyImplicit|Sequential" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geos_NonlinearSolverParameters_LineSearchAction">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|None|Attempt|Require" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geos_NonlinearSolverParameters_LineSearchInterpolationType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|Linear|Parabolic" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geos_NonlinearSolverParameters_NonlinearAccelerationType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|None|Aitken" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geos_NonlinearSolverParameters_SequentialConvergenceCriterion">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|ResidualNorm|NumberOfNonlinearIterations|SolutionIncrements" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="FiniteVolumeType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="HybridMimeticDiscretization" type="HybridMimeticDiscretizationType" />
			<xsd:element name="TwoPointFluxApproximation" type="TwoPointFluxApproximationType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="HybridMimeticDiscretizationType">
		<!--innerProductType => Type of inner product used in the hybrid FVM solver-->
		<xsd:attribute name="innerProductType" type="string" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="TwoPointFluxApproximationType">
		<!--areaRelTol => Relative tolerance for area calculations.-->
		<xsd:attribute name="areaRelTol" type="real64" default="1e-08" />
		<!--meanPermCoefficient => (no description available)-->
		<xsd:attribute name="meanPermCoefficient" type="real64" default="1" />
		<!--upwindingScheme => Type of upwinding scheme. Valid options:
* PPU
* C1PPU
* IHU-->
		<xsd:attribute name="upwindingScheme" type="geos_UpwindingScheme" default="PPU" />
		<!--usePEDFM => (no description available)-->
		<xsd:attribute name="usePEDFM" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_UpwindingScheme">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|PPU|C1PPU|IHU" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="OutputsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Blueprint" type="BlueprintType" />
			<xsd:element name="ChomboIO" type="ChomboIOType" />
			<xsd:element name="Python" type="PythonType" />
			<xsd:element name="Restart" type="RestartType" />
			<xsd:element name="Silo" type="SiloType" />
			<xsd:element name="TimeHistory" type="TimeHistoryType" />
			<xsd:element name="VTK" type="VTKType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="BlueprintType">
		<!--childDirectory => Child directory path-->
		<xsd:attribute name="childDirectory" type="string" default="" />
		<!--outputFullQuadratureData => If true writes out data associated with every quadrature point.-->
		<xsd:attribute name="outputFullQuadratureData" type="integer" default="0" />
		<!--parallelThreads => Number of plot files.-->
		<xsd:attribute name="parallelThreads" type="integer" default="1" />
		<!--plotLevel => Determines which fields to write.-->
		<xsd:attribute name="plotLevel" type="geos_dataRepository_PlotLevel" default="1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ChomboIOType">
		<!--beginCycle => Cycle at which the coupling will commence.-->
		<xsd:attribute name="beginCycle" type="real64" use="required" />
		<!--childDirectory => Child directory path-->
		<xsd:attribute name="childDirectory" type="string" default="" />
		<!--inputPath => Path at which the chombo to geos file will be written.-->
		<xsd:attribute name="inputPath" type="string" default="/INVALID_INPUT_PATH" />
		<!--outputPath => Path at which the geos to chombo file will be written.-->
		<xsd:attribute name="outputPath" type="string" use="required" />
		<!--parallelThreads => Number of plot files.-->
		<xsd:attribute name="parallelThreads" type="integer" default="1" />
		<!--useChomboPressures => True iff geos should use the pressures chombo writes out.-->
		<xsd:attribute name="useChomboPressures" type="integer" default="0" />
		<!--waitForInput => True iff geos should wait for chombo to write out a file. When true the inputPath must be set.-->
		<xsd:attribute name="waitForInput" type="integer" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PythonType">
		<!--childDirectory => Child directory path-->
		<xsd:attribute name="childDirectory" type="string" default="" />
		<!--parallelThreads => Number of plot files.-->
		<xsd:attribute name="parallelThreads" type="integer" default="1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="RestartType">
		<!--childDirectory => Child directory path-->
		<xsd:attribute name="childDirectory" type="string" default="" />
		<!--parallelThreads => Number of plot files.-->
		<xsd:attribute name="parallelThreads" type="integer" default="1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SiloType">
		<!--childDirectory => Child directory path-->
		<xsd:attribute name="childDirectory" type="string" default="" />
		<!--fieldNames => Names of the fields to output. If this attribute is specified, GEOSX outputs all (and only) the fields specified by the user, regardless of their plotLevel-->
		<xsd:attribute name="fieldNames" type="groupNameRef_array" default="{}" />
		<!--onlyPlotSpecifiedFieldNames => If this flag is equal to 1, then we only plot the fields listed in `fieldNames`. Otherwise, we plot all the fields with the required `plotLevel`, plus the fields listed in `fieldNames`-->
		<xsd:attribute name="onlyPlotSpecifiedFieldNames" type="integer" default="0" />
		<!--parallelThreads => Number of plot files.-->
		<xsd:attribute name="parallelThreads" type="integer" default="1" />
		<!--plotFileRoot => (no description available)-->
		<xsd:attribute name="plotFileRoot" type="string" default="plot" />
		<!--plotLevel => (no description available)-->
		<xsd:attribute name="plotLevel" type="integer" default="1" />
		<!--writeCellElementMesh => (no description available)-->
		<xsd:attribute name="writeCellElementMesh" type="integer" default="1" />
		<!--writeEdgeMesh => (no description available)-->
		<xsd:attribute name="writeEdgeMesh" type="integer" default="0" />
		<!--writeFEMFaces => (no description available)-->
		<xsd:attribute name="writeFEMFaces" type="integer" default="0" />
		<!--writeFaceElementMesh => (no description available)-->
		<xsd:attribute name="writeFaceElementMesh" type="integer" default="1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="TimeHistoryType">
		<!--childDirectory => Child directory path-->
		<xsd:attribute name="childDirectory" type="string" default="" />
		<!--filename => The filename to which to write time history output.-->
		<xsd:attribute name="filename" type="string" default="TimeHistory" />
		<!--format => The output file format for time history output.-->
		<xsd:attribute name="format" type="string" default="hdf" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--parallelThreads => Number of plot files.-->
		<xsd:attribute name="parallelThreads" type="integer" default="1" />
		<!--sources => A list of collectors from which to collect and output time history information.-->
		<xsd:attribute name="sources" type="groupNameRef_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="VTKType">
		<!--childDirectory => Child directory path-->
		<xsd:attribute name="childDirectory" type="string" default="" />
		<!--fieldNames => Names of the fields to output. If this attribute is specified, GEOSX outputs all the fields specified by the user, regardless of their `plotLevel`-->
		<xsd:attribute name="fieldNames" type="groupNameRef_array" default="{}" />
		<!--format => Output data format.  Valid options: ``binary``, ``ascii``-->
		<xsd:attribute name="format" type="geos_vtk_VTKOutputMode" default="binary" />
		<!--levelNames => Names of mesh levels to output.-->
		<xsd:attribute name="levelNames" type="string_array" default="{}" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--onlyPlotSpecifiedFieldNames => If this flag is equal to 1, then we only plot the fields listed in `fieldNames`. Otherwise, we plot all the fields with the required `plotLevel`, plus the fields listed in `fieldNames`-->
		<xsd:attribute name="onlyPlotSpecifiedFieldNames" type="integer" default="0" />
		<!--outputRegionType => Output region types.  Valid options: ``cell``, ``well``, ``surface``, ``particle``, ``all``-->
		<xsd:attribute name="outputRegionType" type="geos_vtk_VTKRegionTypes" default="all" />
		<!--parallelThreads => Number of plot files.-->
		<xsd:attribute name="parallelThreads" type="integer" default="1" />
		<!--plotFileRoot => Name of the root file for this output.-->
		<xsd:attribute name="plotFileRoot" type="string" default="VTK" />
		<!--plotLevel => Level detail plot. Only fields with lower of equal plot level will be output.-->
		<xsd:attribute name="plotLevel" type="integer" default="1" />
		<!--writeFEMFaces => (no description available)-->
		<xsd:attribute name="writeFEMFaces" type="integer" default="0" />
		<!--writeFaceElementsAs3D => Should the face elements be written as 3d volumes or not.-->
		<xsd:attribute name="writeFaceElementsAs3D" type="integer" default="0" />
		<!--writeGhostCells => Should the vtk files contain the ghost cells or not.-->
		<xsd:attribute name="writeGhostCells" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_vtk_VTKOutputMode">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|binary|ascii" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geos_vtk_VTKRegionTypes">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|cell|well|surface|particle|all" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="SolversType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="AcousticElasticSEM" type="AcousticElasticSEMType" />
			<xsd:element name="AcousticFirstOrderSEM" type="AcousticFirstOrderSEMType" />
			<xsd:element name="AcousticSEM" type="AcousticSEMType" />
			<xsd:element name="AcousticVTISEM" type="AcousticVTISEMType" />
			<xsd:element name="CompositionalMultiphaseFVM" type="CompositionalMultiphaseFVMType" />
			<xsd:element name="CompositionalMultiphaseHybridFVM" type="CompositionalMultiphaseHybridFVMType" />
			<xsd:element name="CompositionalMultiphaseReservoir" type="CompositionalMultiphaseReservoirType" />
			<xsd:element name="CompositionalMultiphaseReservoirPoromechanics" type="CompositionalMultiphaseReservoirPoromechanicsType" />
			<xsd:element name="CompositionalMultiphaseWell" type="CompositionalMultiphaseWellType">
				<xsd:unique name="SolversCompositionalMultiphaseWellWellControlsUniqueName">
					<xsd:selector xpath="WellControls" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="ElasticFirstOrderSEM" type="ElasticFirstOrderSEMType" />
			<xsd:element name="ElasticSEM" type="ElasticSEMType" />
			<xsd:element name="EmbeddedSurfaceGenerator" type="EmbeddedSurfaceGeneratorType" />
			<xsd:element name="FlowProppantTransport" type="FlowProppantTransportType" />
			<xsd:element name="Hydrofracture" type="HydrofractureType" />
			<xsd:element name="LaplaceFEM" type="LaplaceFEMType" />
			<xsd:element name="MultiphasePoromechanics" type="MultiphasePoromechanicsType" />
			<xsd:element name="MultiphasePoromechanicsReservoir" type="MultiphasePoromechanicsReservoirType" />
			<xsd:element name="PhaseFieldDamageFEM" type="PhaseFieldDamageFEMType" />
			<xsd:element name="PhaseFieldFracture" type="PhaseFieldFractureType" />
			<xsd:element name="ProppantTransport" type="ProppantTransportType" />
			<xsd:element name="ReactiveCompositionalMultiphaseOBL" type="ReactiveCompositionalMultiphaseOBLType" />
			<xsd:element name="SeismicityRate" type="SeismicityRateType" />
			<xsd:element name="SinglePhaseFVM" type="SinglePhaseFVMType" />
			<xsd:element name="SinglePhaseHybridFVM" type="SinglePhaseHybridFVMType" />
			<xsd:element name="SinglePhasePoromechanics" type="SinglePhasePoromechanicsType" />
			<xsd:element name="SinglePhasePoromechanicsConformingFractures" type="SinglePhasePoromechanicsConformingFracturesType" />
			<xsd:element name="SinglePhasePoromechanicsConformingFracturesReservoir" type="SinglePhasePoromechanicsConformingFracturesReservoirType" />
			<xsd:element name="SinglePhasePoromechanicsEmbeddedFractures" type="SinglePhasePoromechanicsEmbeddedFracturesType" />
			<xsd:element name="SinglePhasePoromechanicsReservoir" type="SinglePhasePoromechanicsReservoirType" />
			<xsd:element name="SinglePhaseProppantFVM" type="SinglePhaseProppantFVMType" />
			<xsd:element name="SinglePhaseReservoir" type="SinglePhaseReservoirType" />
			<xsd:element name="SinglePhaseReservoirPoromechanics" type="SinglePhaseReservoirPoromechanicsType" />
			<xsd:element name="SinglePhaseWell" type="SinglePhaseWellType">
				<xsd:unique name="SolversSinglePhaseWellWellControlsUniqueName">
					<xsd:selector xpath="WellControls" />
					<xsd:field xpath="@name" />
				</xsd:unique>
			</xsd:element>
			<xsd:element name="SolidMechanicsAugmentedLagrangianContact" type="SolidMechanicsAugmentedLagrangianContactType" />
			<xsd:element name="SolidMechanicsEmbeddedFractures" type="SolidMechanicsEmbeddedFracturesType" />
			<xsd:element name="SolidMechanicsLagrangeContact" type="SolidMechanicsLagrangeContactType" />
			<xsd:element name="SolidMechanicsLagrangianSSLE" type="SolidMechanicsLagrangianSSLEType" />
			<xsd:element name="SolidMechanics_LagrangianFEM" type="SolidMechanics_LagrangianFEMType" />
			<xsd:element name="SolidMechanics_MPM" type="SolidMechanics_MPMType" />
			<xsd:element name="SurfaceGenerator" type="SurfaceGeneratorType" />
		</xsd:choice>
		<!--gravityVector => Gravity vector used in the physics solvers-->
		<xsd:attribute name="gravityVector" type="R1Tensor" default="{0,0,-9.81}" />
	</xsd:complexType>
	<xsd:complexType name="AcousticElasticSEMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--acousticSolverName => Name of the acoustic solver used by the coupled solver-->
		<xsd:attribute name="acousticSolverName" type="groupNameRef" use="required" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--elasticSolverName => Name of the elastic solver used by the coupled solver-->
		<xsd:attribute name="elasticSolverName" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="AcousticFirstOrderSEMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--attenuationType => Flag to indicate which attenuation model to use: "none" for no attenuation, "sls\ for the standard-linear-solid (SLS) model (Fichtner, 2014).-->
		<xsd:attribute name="attenuationType" type="geos_WaveSolverUtils_AttenuationType" default="none" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--dtSeismoTrace => Time step for output pressure at receivers-->
		<xsd:attribute name="dtSeismoTrace" type="real64" default="0" />
		<!--enableLifo => Set to 1 to enable LIFO storage feature-->
		<xsd:attribute name="enableLifo" type="integer" default="0" />
		<!--forward => Set to 1 to compute forward propagation-->
		<xsd:attribute name="forward" type="integer" default="1" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--lifoOnDevice => Set the capacity of the lifo device storage (if negative, opposite of percentage of remaining memory)-->
		<xsd:attribute name="lifoOnDevice" type="integer" default="-80" />
		<!--lifoOnHost => Set the capacity of the lifo host storage (if negative, opposite of percentage of remaining memory)-->
		<xsd:attribute name="lifoOnHost" type="integer" default="-80" />
		<!--lifoSize => Set the capacity of the lifo storage (should be the total number of buffers to store in the LIFO)-->
		<xsd:attribute name="lifoSize" type="integer" default="2147483647" />
		<!--linearDASGeometry => Geometry parameters for a linear DAS fiber (dip, azimuth, gauge length)-->
		<xsd:attribute name="linearDASGeometry" type="real64_array2d" default="{{0}}" />
		<!--linearDASSamples => Number of sample points to be used for strain integration when integrating the strain for the DAS signal-->
		<xsd:attribute name="linearDASSamples" type="integer" default="5" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--outputSeismoTrace => Flag that indicates if we write the seismo trace in a file .txt, 0 no output, 1 otherwise-->
		<xsd:attribute name="outputSeismoTrace" type="integer" default="0" />
		<!--receiverCoordinates => Coordinates (x,y,z) of the receivers-->
		<xsd:attribute name="receiverCoordinates" type="real64_array2d" default="{{0}}" />
		<!--rickerOrder => Flag that indicates the order of the Ricker to be used o, 1 or 2. Order 2 by default-->
		<xsd:attribute name="rickerOrder" type="integer" default="2" />
		<!--saveFields => Set to 1 to save fields during forward and restore them during backward-->
		<xsd:attribute name="saveFields" type="integer" default="0" />
		<!--shotIndex => Set the current shot for temporary files-->
		<xsd:attribute name="shotIndex" type="integer" default="0" />
		<!--slsAnelasticityCoefficients => Anelasticity coefficients for the standard-linear-solid (SLS) anelasticity.The default value is { }, corresponding to no attenuation. An array with the corresponding reference frequencies must be provided.-->
		<xsd:attribute name="slsAnelasticityCoefficients" type="real32_array" default="{0}" />
		<!--slsReferenceAngularFrequencies => Reference angular frequencies (omega) for the standard-linear-solid (SLS) anelasticity.The default value is { }, corresponding to no attenuation. An array with the corresponding anelasticity coefficients must be provided.-->
		<xsd:attribute name="slsReferenceAngularFrequencies" type="real32_array" default="{0}" />
		<!--sourceCoordinates => Coordinates (x,y,z) of the sources-->
		<xsd:attribute name="sourceCoordinates" type="real64_array2d" default="{{0}}" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--timeSourceDelay => Source time delay (1 / f0 by default)-->
		<xsd:attribute name="timeSourceDelay" type="real32" default="-1" />
		<!--timeSourceFrequency => Central frequency for the time source-->
		<xsd:attribute name="timeSourceFrequency" type="real32" default="0" />
		<!--useDAS => Flag to indicate if DAS data will be modeled, and which DAS type to use: "none" to deactivate DAS, "strainIntegration" for strain integration, "dipole" for displacement difference-->
		<xsd:attribute name="useDAS" type="geos_WaveSolverUtils_DASType" default="none" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_WaveSolverUtils_AttenuationType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|none|sls" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geos_WaveSolverUtils_DASType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|none|dipole|strainIntegration" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="AcousticSEMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--attenuationType => Flag to indicate which attenuation model to use: "none" for no attenuation, "sls\ for the standard-linear-solid (SLS) model (Fichtner, 2014).-->
		<xsd:attribute name="attenuationType" type="geos_WaveSolverUtils_AttenuationType" default="none" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--dtSeismoTrace => Time step for output pressure at receivers-->
		<xsd:attribute name="dtSeismoTrace" type="real64" default="0" />
		<!--enableLifo => Set to 1 to enable LIFO storage feature-->
		<xsd:attribute name="enableLifo" type="integer" default="0" />
		<!--forward => Set to 1 to compute forward propagation-->
		<xsd:attribute name="forward" type="integer" default="1" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--lifoOnDevice => Set the capacity of the lifo device storage (if negative, opposite of percentage of remaining memory)-->
		<xsd:attribute name="lifoOnDevice" type="integer" default="-80" />
		<!--lifoOnHost => Set the capacity of the lifo host storage (if negative, opposite of percentage of remaining memory)-->
		<xsd:attribute name="lifoOnHost" type="integer" default="-80" />
		<!--lifoSize => Set the capacity of the lifo storage (should be the total number of buffers to store in the LIFO)-->
		<xsd:attribute name="lifoSize" type="integer" default="2147483647" />
		<!--linearDASGeometry => Geometry parameters for a linear DAS fiber (dip, azimuth, gauge length)-->
		<xsd:attribute name="linearDASGeometry" type="real64_array2d" default="{{0}}" />
		<!--linearDASSamples => Number of sample points to be used for strain integration when integrating the strain for the DAS signal-->
		<xsd:attribute name="linearDASSamples" type="integer" default="5" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--outputSeismoTrace => Flag that indicates if we write the seismo trace in a file .txt, 0 no output, 1 otherwise-->
		<xsd:attribute name="outputSeismoTrace" type="integer" default="0" />
		<!--receiverCoordinates => Coordinates (x,y,z) of the receivers-->
		<xsd:attribute name="receiverCoordinates" type="real64_array2d" default="{{0}}" />
		<!--rickerOrder => Flag that indicates the order of the Ricker to be used o, 1 or 2. Order 2 by default-->
		<xsd:attribute name="rickerOrder" type="integer" default="2" />
		<!--saveFields => Set to 1 to save fields during forward and restore them during backward-->
		<xsd:attribute name="saveFields" type="integer" default="0" />
		<!--shotIndex => Set the current shot for temporary files-->
		<xsd:attribute name="shotIndex" type="integer" default="0" />
		<!--slsAnelasticityCoefficients => Anelasticity coefficients for the standard-linear-solid (SLS) anelasticity.The default value is { }, corresponding to no attenuation. An array with the corresponding reference frequencies must be provided.-->
		<xsd:attribute name="slsAnelasticityCoefficients" type="real32_array" default="{0}" />
		<!--slsReferenceAngularFrequencies => Reference angular frequencies (omega) for the standard-linear-solid (SLS) anelasticity.The default value is { }, corresponding to no attenuation. An array with the corresponding anelasticity coefficients must be provided.-->
		<xsd:attribute name="slsReferenceAngularFrequencies" type="real32_array" default="{0}" />
		<!--sourceCoordinates => Coordinates (x,y,z) of the sources-->
		<xsd:attribute name="sourceCoordinates" type="real64_array2d" default="{{0}}" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--timeSourceDelay => Source time delay (1 / f0 by default)-->
		<xsd:attribute name="timeSourceDelay" type="real32" default="-1" />
		<!--timeSourceFrequency => Central frequency for the time source-->
		<xsd:attribute name="timeSourceFrequency" type="real32" default="0" />
		<!--useDAS => Flag to indicate if DAS data will be modeled, and which DAS type to use: "none" to deactivate DAS, "strainIntegration" for strain integration, "dipole" for displacement difference-->
		<xsd:attribute name="useDAS" type="geos_WaveSolverUtils_DASType" default="none" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="AcousticVTISEMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--attenuationType => Flag to indicate which attenuation model to use: "none" for no attenuation, "sls\ for the standard-linear-solid (SLS) model (Fichtner, 2014).-->
		<xsd:attribute name="attenuationType" type="geos_WaveSolverUtils_AttenuationType" default="none" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--dtSeismoTrace => Time step for output pressure at receivers-->
		<xsd:attribute name="dtSeismoTrace" type="real64" default="0" />
		<!--enableLifo => Set to 1 to enable LIFO storage feature-->
		<xsd:attribute name="enableLifo" type="integer" default="0" />
		<!--forward => Set to 1 to compute forward propagation-->
		<xsd:attribute name="forward" type="integer" default="1" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--lifoOnDevice => Set the capacity of the lifo device storage (if negative, opposite of percentage of remaining memory)-->
		<xsd:attribute name="lifoOnDevice" type="integer" default="-80" />
		<!--lifoOnHost => Set the capacity of the lifo host storage (if negative, opposite of percentage of remaining memory)-->
		<xsd:attribute name="lifoOnHost" type="integer" default="-80" />
		<!--lifoSize => Set the capacity of the lifo storage (should be the total number of buffers to store in the LIFO)-->
		<xsd:attribute name="lifoSize" type="integer" default="2147483647" />
		<!--linearDASGeometry => Geometry parameters for a linear DAS fiber (dip, azimuth, gauge length)-->
		<xsd:attribute name="linearDASGeometry" type="real64_array2d" default="{{0}}" />
		<!--linearDASSamples => Number of sample points to be used for strain integration when integrating the strain for the DAS signal-->
		<xsd:attribute name="linearDASSamples" type="integer" default="5" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--outputSeismoTrace => Flag that indicates if we write the seismo trace in a file .txt, 0 no output, 1 otherwise-->
		<xsd:attribute name="outputSeismoTrace" type="integer" default="0" />
		<!--receiverCoordinates => Coordinates (x,y,z) of the receivers-->
		<xsd:attribute name="receiverCoordinates" type="real64_array2d" default="{{0}}" />
		<!--rickerOrder => Flag that indicates the order of the Ricker to be used o, 1 or 2. Order 2 by default-->
		<xsd:attribute name="rickerOrder" type="integer" default="2" />
		<!--saveFields => Set to 1 to save fields during forward and restore them during backward-->
		<xsd:attribute name="saveFields" type="integer" default="0" />
		<!--shotIndex => Set the current shot for temporary files-->
		<xsd:attribute name="shotIndex" type="integer" default="0" />
		<!--slsAnelasticityCoefficients => Anelasticity coefficients for the standard-linear-solid (SLS) anelasticity.The default value is { }, corresponding to no attenuation. An array with the corresponding reference frequencies must be provided.-->
		<xsd:attribute name="slsAnelasticityCoefficients" type="real32_array" default="{0}" />
		<!--slsReferenceAngularFrequencies => Reference angular frequencies (omega) for the standard-linear-solid (SLS) anelasticity.The default value is { }, corresponding to no attenuation. An array with the corresponding anelasticity coefficients must be provided.-->
		<xsd:attribute name="slsReferenceAngularFrequencies" type="real32_array" default="{0}" />
		<!--sourceCoordinates => Coordinates (x,y,z) of the sources-->
		<xsd:attribute name="sourceCoordinates" type="real64_array2d" default="{{0}}" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--timeSourceDelay => Source time delay (1 / f0 by default)-->
		<xsd:attribute name="timeSourceDelay" type="real32" default="-1" />
		<!--timeSourceFrequency => Central frequency for the time source-->
		<xsd:attribute name="timeSourceFrequency" type="real32" default="0" />
		<!--useDAS => Flag to indicate if DAS data will be modeled, and which DAS type to use: "none" to deactivate DAS, "strainIntegration" for strain integration, "dipole" for displacement difference-->
		<xsd:attribute name="useDAS" type="geos_WaveSolverUtils_DASType" default="none" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CompositionalMultiphaseFVMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--allowLocalCompDensityChopping => Flag indicating whether local (cell-wise) chopping of negative compositions is allowed-->
		<xsd:attribute name="allowLocalCompDensityChopping" type="integer" default="1" />
		<!--allowNegativePressure => Flag indicating if negative pressure is allowed-->
		<xsd:attribute name="allowNegativePressure" type="integer" default="1" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--contMultiplierDBC => Factor by which continuation parameter is changed every newton when DBC is used-->
		<xsd:attribute name="contMultiplierDBC" type="real64" default="0.5" />
		<!--continuationDBC => Flag for enabling continuation parameter-->
		<xsd:attribute name="continuationDBC" type="integer" default="1" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--isThermal => Flag indicating whether the problem is thermal or not.-->
		<xsd:attribute name="isThermal" type="integer" default="0" />
		<!--kappaminDBC => Factor that controls how much dissipation is kept in the system when continuation is used-->
		<xsd:attribute name="kappaminDBC" type="real64" default="1e-20" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxAbsolutePressureChange => Maximum (absolute) pressure change in a Newton iteration-->
		<xsd:attribute name="maxAbsolutePressureChange" type="real64" default="-1" />
		<!--maxCompFractionChange => Maximum (absolute) change in a component fraction in a Newton iteration-->
		<xsd:attribute name="maxCompFractionChange" type="real64" default="0.5" />
		<!--maxRelativeCompDensChange => Maximum (relative) change in a component density in a Newton iteration-->
		<xsd:attribute name="maxRelativeCompDensChange" type="real64" default="1.79769e+208" />
		<!--maxRelativePressureChange => Maximum (relative) change in pressure in a Newton iteration-->
		<xsd:attribute name="maxRelativePressureChange" type="real64" default="0.5" />
		<!--maxRelativeTemperatureChange => Maximum (relative) change in temperature in a Newton iteration-->
		<xsd:attribute name="maxRelativeTemperatureChange" type="real64" default="0.5" />
		<!--maxSequentialCompDensChange => Maximum (absolute) component density change in a sequential iteration, used for outer loop convergence check-->
		<xsd:attribute name="maxSequentialCompDensChange" type="real64" default="1" />
		<!--maxSequentialPressureChange => Maximum (absolute) pressure change in a sequential iteration, used for outer loop convergence check-->
		<xsd:attribute name="maxSequentialPressureChange" type="real64" default="100000" />
		<!--maxSequentialTemperatureChange => Maximum (absolute) temperature change in a sequential iteration, used for outer loop convergence check-->
		<xsd:attribute name="maxSequentialTemperatureChange" type="real64" default="0.1" />
		<!--minCompDens => Minimum allowed global component density-->
		<xsd:attribute name="minCompDens" type="real64" default="1e-10" />
		<!--minScalingFactor => Minimum value for solution scaling factor-->
		<xsd:attribute name="minScalingFactor" type="real64" default="0.01" />
		<!--miscibleDBC => Flag for enabling DBC formulation with/without miscibility-->
		<xsd:attribute name="miscibleDBC" type="integer" default="0" />
		<!--omegaDBC => Factor by which DBC flux is multiplied-->
		<xsd:attribute name="omegaDBC" type="real64" default="1" />
		<!--scalingType => Solution scaling type.Valid options:
* Global
* Local-->
		<xsd:attribute name="scalingType" type="geos_CompositionalMultiphaseFVM_ScalingType" default="Global" />
		<!--solutionChangeScalingFactor => Damping factor for solution change targets-->
		<xsd:attribute name="solutionChangeScalingFactor" type="real64" default="0.5" />
		<!--targetFlowCFL => Target CFL condition `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when computing the next timestep.-->
		<xsd:attribute name="targetFlowCFL" type="real64" default="-1" />
		<!--targetPhaseVolFractionChangeInTimeStep => Target (absolute) change in phase volume fraction in a time step-->
		<xsd:attribute name="targetPhaseVolFractionChangeInTimeStep" type="real64" default="0.2" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--targetRelativeCompDensChangeInTimeStep => Target (relative) change in component density in a time step-->
		<xsd:attribute name="targetRelativeCompDensChangeInTimeStep" type="real64" default="1.79769e+308" />
		<!--targetRelativePressureChangeInTimeStep => Target (relative) change in pressure in a time step (expected value between 0 and 1)-->
		<xsd:attribute name="targetRelativePressureChangeInTimeStep" type="real64" default="0.2" />
		<!--targetRelativeTemperatureChangeInTimeStep => Target (relative) change in temperature in a time step (expected value between 0 and 1)-->
		<xsd:attribute name="targetRelativeTemperatureChangeInTimeStep" type="real64" default="0.2" />
		<!--temperature => Temperature-->
		<xsd:attribute name="temperature" type="real64" use="required" />
		<!--useDBC => Enable Dissipation-based continuation flux-->
		<xsd:attribute name="useDBC" type="integer" default="0" />
		<!--useMass => Use mass formulation instead of molar. Warning : Affects SourceFlux rates units.-->
		<xsd:attribute name="useMass" type="integer" default="0" />
		<!--useSimpleAccumulation => Flag indicating whether simple accumulation form is used-->
		<xsd:attribute name="useSimpleAccumulation" type="integer" default="1" />
		<!--useTotalMassEquation => Flag indicating whether total mass equation is used-->
		<xsd:attribute name="useTotalMassEquation" type="integer" default="1" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_solverBaseKernels_NormType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|Linfinity|L2" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geos_CompositionalMultiphaseFVM_ScalingType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|Global|Local" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="CompositionalMultiphaseHybridFVMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--allowLocalCompDensityChopping => Flag indicating whether local (cell-wise) chopping of negative compositions is allowed-->
		<xsd:attribute name="allowLocalCompDensityChopping" type="integer" default="1" />
		<!--allowNegativePressure => Flag indicating if negative pressure is allowed-->
		<xsd:attribute name="allowNegativePressure" type="integer" default="1" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--isThermal => Flag indicating whether the problem is thermal or not.-->
		<xsd:attribute name="isThermal" type="integer" default="0" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxAbsolutePressureChange => Maximum (absolute) pressure change in a Newton iteration-->
		<xsd:attribute name="maxAbsolutePressureChange" type="real64" default="-1" />
		<!--maxCompFractionChange => Maximum (absolute) change in a component fraction in a Newton iteration-->
		<xsd:attribute name="maxCompFractionChange" type="real64" default="0.5" />
		<!--maxRelativeCompDensChange => Maximum (relative) change in a component density in a Newton iteration-->
		<xsd:attribute name="maxRelativeCompDensChange" type="real64" default="1.79769e+208" />
		<!--maxRelativePressureChange => Maximum (relative) change in pressure in a Newton iteration-->
		<xsd:attribute name="maxRelativePressureChange" type="real64" default="0.5" />
		<!--maxRelativeTemperatureChange => Maximum (relative) change in temperature in a Newton iteration-->
		<xsd:attribute name="maxRelativeTemperatureChange" type="real64" default="0.5" />
		<!--maxSequentialCompDensChange => Maximum (absolute) component density change in a sequential iteration, used for outer loop convergence check-->
		<xsd:attribute name="maxSequentialCompDensChange" type="real64" default="1" />
		<!--maxSequentialPressureChange => Maximum (absolute) pressure change in a sequential iteration, used for outer loop convergence check-->
		<xsd:attribute name="maxSequentialPressureChange" type="real64" default="100000" />
		<!--maxSequentialTemperatureChange => Maximum (absolute) temperature change in a sequential iteration, used for outer loop convergence check-->
		<xsd:attribute name="maxSequentialTemperatureChange" type="real64" default="0.1" />
		<!--minCompDens => Minimum allowed global component density-->
		<xsd:attribute name="minCompDens" type="real64" default="1e-10" />
		<!--minScalingFactor => Minimum value for solution scaling factor-->
		<xsd:attribute name="minScalingFactor" type="real64" default="0.01" />
		<!--solutionChangeScalingFactor => Damping factor for solution change targets-->
		<xsd:attribute name="solutionChangeScalingFactor" type="real64" default="0.5" />
		<!--targetFlowCFL => Target CFL condition `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when computing the next timestep.-->
		<xsd:attribute name="targetFlowCFL" type="real64" default="-1" />
		<!--targetPhaseVolFractionChangeInTimeStep => Target (absolute) change in phase volume fraction in a time step-->
		<xsd:attribute name="targetPhaseVolFractionChangeInTimeStep" type="real64" default="0.2" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--targetRelativeCompDensChangeInTimeStep => Target (relative) change in component density in a time step-->
		<xsd:attribute name="targetRelativeCompDensChangeInTimeStep" type="real64" default="1.79769e+308" />
		<!--targetRelativePressureChangeInTimeStep => Target (relative) change in pressure in a time step (expected value between 0 and 1)-->
		<xsd:attribute name="targetRelativePressureChangeInTimeStep" type="real64" default="0.2" />
		<!--targetRelativeTemperatureChangeInTimeStep => Target (relative) change in temperature in a time step (expected value between 0 and 1)-->
		<xsd:attribute name="targetRelativeTemperatureChangeInTimeStep" type="real64" default="0.2" />
		<!--temperature => Temperature-->
		<xsd:attribute name="temperature" type="real64" use="required" />
		<!--useMass => Use mass formulation instead of molar. Warning : Affects SourceFlux rates units.-->
		<xsd:attribute name="useMass" type="integer" default="0" />
		<!--useSimpleAccumulation => Flag indicating whether simple accumulation form is used-->
		<xsd:attribute name="useSimpleAccumulation" type="integer" default="1" />
		<!--useTotalMassEquation => Flag indicating whether total mass equation is used-->
		<xsd:attribute name="useTotalMassEquation" type="integer" default="1" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CompositionalMultiphaseReservoirType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--flowSolverName => Name of the flow solver used by the coupled solver-->
		<xsd:attribute name="flowSolverName" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
 - Coupling information
 - Crossflow information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--wellSolverName => Name of the well solver used by the coupled solver-->
		<xsd:attribute name="wellSolverName" type="groupNameRef" use="required" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CompositionalMultiphaseReservoirPoromechanicsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--isThermal => Flag indicating whether the problem is thermal or not. Set isThermal="1" to enable the thermal coupling-->
		<xsd:attribute name="isThermal" type="integer" default="0" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
 - Coupling information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--reservoirAndWellsSolverName => Name of the reservoirAndWells solver used by the coupled solver-->
		<xsd:attribute name="reservoirAndWellsSolverName" type="groupNameRef" use="required" />
		<!--solidSolverName => Name of the solid solver used by the coupled solver-->
		<xsd:attribute name="solidSolverName" type="groupNameRef" use="required" />
		<!--stabilizationMultiplier => Constant multiplier of stabilization strength-->
		<xsd:attribute name="stabilizationMultiplier" type="real64" default="1" />
		<!--stabilizationRegionNames => Regions where stabilization is applied.-->
		<xsd:attribute name="stabilizationRegionNames" type="groupNameRef_array" default="{}" />
		<!--stabilizationType => StabilizationType. Options are:
None- Add no stabilization to mass equation 
Global- Add jump stabilization to all faces 
Local- Add jump stabilization on interior of macro elements-->
		<xsd:attribute name="stabilizationType" type="geos_stabilization_StabilizationType" default="None" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_stabilization_StabilizationType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|None|Global|Local" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="CompositionalMultiphaseWellType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="WellControls" type="WellControlsType" />
		</xsd:choice>
		<!--allowLocalCompDensityChopping => Flag indicating whether local (cell-wise) chopping of negative compositions is allowed-->
		<xsd:attribute name="allowLocalCompDensityChopping" type="integer" default="1" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
 - Well control information
 - Crossflow information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxAbsolutePressureChange => Maximum (absolute) pressure change in a Newton iteration-->
		<xsd:attribute name="maxAbsolutePressureChange" type="real64" default="-1" />
		<!--maxCompFractionChange => Maximum (absolute) change in a component fraction between two Newton iterations-->
		<xsd:attribute name="maxCompFractionChange" type="real64" default="1" />
		<!--maxRelativeCompDensChange => Maximum (relative) change in a component density between two Newton iterations-->
		<xsd:attribute name="maxRelativeCompDensChange" type="real64" default="1.79769e+208" />
		<!--maxRelativePressureChange => Maximum (relative) change in pressure between two Newton iterations (recommended with rate control)-->
		<xsd:attribute name="maxRelativePressureChange" type="real64" default="1" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--useMass => Use mass formulation instead of molar-->
		<xsd:attribute name="useMass" type="integer" default="0" />
		<!--useTotalMassEquation => Use total mass equation-->
		<xsd:attribute name="useTotalMassEquation" type="integer" default="1" />
		<!--writeCSV => Write rates into a CSV file-->
		<xsd:attribute name="writeCSV" type="integer" default="0" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="WellControlsType">
		<!--control => Well control. Valid options:
* BHP
* phaseVolRate
* totalVolRate
* massRate
* uninitialized-->
		<xsd:attribute name="control" type="geos_WellControls_Control" use="required" />
		<!--enableCrossflow => Flag to enable crossflow. Currently only supported for injectors: 
 - If the flag is set to 1, both reservoir-to-well flow and well-to-reservoir flow are allowed at the perforations. 
 - If the flag is set to 0, we only allow well-to-reservoir flow at the perforations.-->
		<xsd:attribute name="enableCrossflow" type="integer" default="1" />
		<!--initialPressureCoefficient => Tuning coefficient for the initial well pressure of rate-controlled wells: 
 - Injector pressure at reference depth initialized as: (1+initialPressureCoefficient)*reservoirPressureAtClosestPerforation + density*g*( zRef - zPerf ) 
 - Producer pressure at reference depth initialized as: (1-initialPressureCoefficient)*reservoirPressureAtClosestPerforation + density*g*( zRef - zPerf ) -->
		<xsd:attribute name="initialPressureCoefficient" type="real64" default="0.1" />
		<!--injectionStream => Global component densities of the injection stream [moles/m^3 or kg/m^3]-->
		<xsd:attribute name="injectionStream" type="real64_array" default="{-1}" />
		<!--injectionTemperature => Temperature of the injection stream [K]-->
		<xsd:attribute name="injectionTemperature" type="real64" default="-1" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--referenceElevation => Reference elevation where BHP control is enforced [m]-->
		<xsd:attribute name="referenceElevation" type="real64" use="required" />
		<!--statusTableName => Name of the well status table when the status of the well is a time dependent function. 
If the status function evaluates to a positive value at the current time, the well will be open otherwise the well will be shut.-->
		<xsd:attribute name="statusTableName" type="groupNameRef" default="" />
		<!--surfacePressure => Surface pressure used to compute volumetric rates when surface conditions are used [Pa]-->
		<xsd:attribute name="surfacePressure" type="real64" default="0" />
		<!--surfaceTemperature => Surface temperature used to compute volumetric rates when surface conditions are used [K]-->
		<xsd:attribute name="surfaceTemperature" type="real64" default="0" />
		<!--targetBHP => Target bottom-hole pressure [Pa]-->
		<xsd:attribute name="targetBHP" type="real64" default="0" />
		<!--targetBHPTableName => Name of the BHP table when the rate is a time dependent function-->
		<xsd:attribute name="targetBHPTableName" type="groupNameRef" default="" />
		<!--targetMassRate => Target Mass Rate rate ( [kg^3/s])-->
		<xsd:attribute name="targetMassRate" type="real64" default="0" />
		<!--targetMassRateTableName => Name of the mass rate table when the rate is a time dependent function-->
		<xsd:attribute name="targetMassRateTableName" type="groupNameRef" default="" />
		<!--targetPhaseName => Name of the target phase-->
		<xsd:attribute name="targetPhaseName" type="groupNameRef" default="" />
		<!--targetPhaseRate => Target phase volumetric rate (if useSurfaceConditions: [surface m^3/s]; else [reservoir m^3/s])-->
		<xsd:attribute name="targetPhaseRate" type="real64" default="0" />
		<!--targetPhaseRateTableName => Name of the phase rate table when the rate is a time dependent function-->
		<xsd:attribute name="targetPhaseRateTableName" type="groupNameRef" default="" />
		<!--targetTotalRate => Target total volumetric rate (if useSurfaceConditions: [surface m^3/s]; else [reservoir m^3/s])-->
		<xsd:attribute name="targetTotalRate" type="real64" default="0" />
		<!--targetTotalRateTableName => Name of the total rate table when the rate is a time dependent function-->
		<xsd:attribute name="targetTotalRateTableName" type="groupNameRef" default="" />
		<!--type => Well type. Valid options:
* producer
* injector-->
		<xsd:attribute name="type" type="geos_WellControls_Type" use="required" />
		<!--useSurfaceConditions => Flag to specify whether rates are checked at surface or reservoir conditions.
Equal to 1 for surface conditions, and to 0 for reservoir conditions-->
		<xsd:attribute name="useSurfaceConditions" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_WellControls_Control">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|BHP|phaseVolRate|totalVolRate|massRate|uninitialized" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geos_WellControls_Type">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|producer|injector" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="ElasticFirstOrderSEMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--attenuationType => Flag to indicate which attenuation model to use: "none" for no attenuation, "sls\ for the standard-linear-solid (SLS) model (Fichtner, 2014).-->
		<xsd:attribute name="attenuationType" type="geos_WaveSolverUtils_AttenuationType" default="none" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--dtSeismoTrace => Time step for output pressure at receivers-->
		<xsd:attribute name="dtSeismoTrace" type="real64" default="0" />
		<!--enableLifo => Set to 1 to enable LIFO storage feature-->
		<xsd:attribute name="enableLifo" type="integer" default="0" />
		<!--forward => Set to 1 to compute forward propagation-->
		<xsd:attribute name="forward" type="integer" default="1" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--lifoOnDevice => Set the capacity of the lifo device storage (if negative, opposite of percentage of remaining memory)-->
		<xsd:attribute name="lifoOnDevice" type="integer" default="-80" />
		<!--lifoOnHost => Set the capacity of the lifo host storage (if negative, opposite of percentage of remaining memory)-->
		<xsd:attribute name="lifoOnHost" type="integer" default="-80" />
		<!--lifoSize => Set the capacity of the lifo storage (should be the total number of buffers to store in the LIFO)-->
		<xsd:attribute name="lifoSize" type="integer" default="2147483647" />
		<!--linearDASGeometry => Geometry parameters for a linear DAS fiber (dip, azimuth, gauge length)-->
		<xsd:attribute name="linearDASGeometry" type="real64_array2d" default="{{0}}" />
		<!--linearDASSamples => Number of sample points to be used for strain integration when integrating the strain for the DAS signal-->
		<xsd:attribute name="linearDASSamples" type="integer" default="5" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--outputSeismoTrace => Flag that indicates if we write the seismo trace in a file .txt, 0 no output, 1 otherwise-->
		<xsd:attribute name="outputSeismoTrace" type="integer" default="0" />
		<!--receiverCoordinates => Coordinates (x,y,z) of the receivers-->
		<xsd:attribute name="receiverCoordinates" type="real64_array2d" default="{{0}}" />
		<!--rickerOrder => Flag that indicates the order of the Ricker to be used o, 1 or 2. Order 2 by default-->
		<xsd:attribute name="rickerOrder" type="integer" default="2" />
		<!--saveFields => Set to 1 to save fields during forward and restore them during backward-->
		<xsd:attribute name="saveFields" type="integer" default="0" />
		<!--shotIndex => Set the current shot for temporary files-->
		<xsd:attribute name="shotIndex" type="integer" default="0" />
		<!--slsAnelasticityCoefficients => Anelasticity coefficients for the standard-linear-solid (SLS) anelasticity.The default value is { }, corresponding to no attenuation. An array with the corresponding reference frequencies must be provided.-->
		<xsd:attribute name="slsAnelasticityCoefficients" type="real32_array" default="{0}" />
		<!--slsReferenceAngularFrequencies => Reference angular frequencies (omega) for the standard-linear-solid (SLS) anelasticity.The default value is { }, corresponding to no attenuation. An array with the corresponding anelasticity coefficients must be provided.-->
		<xsd:attribute name="slsReferenceAngularFrequencies" type="real32_array" default="{0}" />
		<!--sourceCoordinates => Coordinates (x,y,z) of the sources-->
		<xsd:attribute name="sourceCoordinates" type="real64_array2d" default="{{0}}" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--timeSourceDelay => Source time delay (1 / f0 by default)-->
		<xsd:attribute name="timeSourceDelay" type="real32" default="-1" />
		<!--timeSourceFrequency => Central frequency for the time source-->
		<xsd:attribute name="timeSourceFrequency" type="real32" default="0" />
		<!--useDAS => Flag to indicate if DAS data will be modeled, and which DAS type to use: "none" to deactivate DAS, "strainIntegration" for strain integration, "dipole" for displacement difference-->
		<xsd:attribute name="useDAS" type="geos_WaveSolverUtils_DASType" default="none" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ElasticSEMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--attenuationType => Flag to indicate which attenuation model to use: "none" for no attenuation, "sls\ for the standard-linear-solid (SLS) model (Fichtner, 2014).-->
		<xsd:attribute name="attenuationType" type="geos_WaveSolverUtils_AttenuationType" default="none" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--dtSeismoTrace => Time step for output pressure at receivers-->
		<xsd:attribute name="dtSeismoTrace" type="real64" default="0" />
		<!--enableLifo => Set to 1 to enable LIFO storage feature-->
		<xsd:attribute name="enableLifo" type="integer" default="0" />
		<!--forward => Set to 1 to compute forward propagation-->
		<xsd:attribute name="forward" type="integer" default="1" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--lifoOnDevice => Set the capacity of the lifo device storage (if negative, opposite of percentage of remaining memory)-->
		<xsd:attribute name="lifoOnDevice" type="integer" default="-80" />
		<!--lifoOnHost => Set the capacity of the lifo host storage (if negative, opposite of percentage of remaining memory)-->
		<xsd:attribute name="lifoOnHost" type="integer" default="-80" />
		<!--lifoSize => Set the capacity of the lifo storage (should be the total number of buffers to store in the LIFO)-->
		<xsd:attribute name="lifoSize" type="integer" default="2147483647" />
		<!--linearDASGeometry => Geometry parameters for a linear DAS fiber (dip, azimuth, gauge length)-->
		<xsd:attribute name="linearDASGeometry" type="real64_array2d" default="{{0}}" />
		<!--linearDASSamples => Number of sample points to be used for strain integration when integrating the strain for the DAS signal-->
		<xsd:attribute name="linearDASSamples" type="integer" default="5" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--outputSeismoTrace => Flag that indicates if we write the seismo trace in a file .txt, 0 no output, 1 otherwise-->
		<xsd:attribute name="outputSeismoTrace" type="integer" default="0" />
		<!--receiverCoordinates => Coordinates (x,y,z) of the receivers-->
		<xsd:attribute name="receiverCoordinates" type="real64_array2d" default="{{0}}" />
		<!--rickerOrder => Flag that indicates the order of the Ricker to be used o, 1 or 2. Order 2 by default-->
		<xsd:attribute name="rickerOrder" type="integer" default="2" />
		<!--saveFields => Set to 1 to save fields during forward and restore them during backward-->
		<xsd:attribute name="saveFields" type="integer" default="0" />
		<!--shotIndex => Set the current shot for temporary files-->
		<xsd:attribute name="shotIndex" type="integer" default="0" />
		<!--slsAnelasticityCoefficients => Anelasticity coefficients for the standard-linear-solid (SLS) anelasticity.The default value is { }, corresponding to no attenuation. An array with the corresponding reference frequencies must be provided.-->
		<xsd:attribute name="slsAnelasticityCoefficients" type="real32_array" default="{0}" />
		<!--slsReferenceAngularFrequencies => Reference angular frequencies (omega) for the standard-linear-solid (SLS) anelasticity.The default value is { }, corresponding to no attenuation. An array with the corresponding anelasticity coefficients must be provided.-->
		<xsd:attribute name="slsReferenceAngularFrequencies" type="real32_array" default="{0}" />
		<!--sourceCoordinates => Coordinates (x,y,z) of the sources-->
		<xsd:attribute name="sourceCoordinates" type="real64_array2d" default="{{0}}" />
		<!--sourceForce => Force of the source: 3 real values for a vector source, and 6 real values for a tensor source (in Voigt notation).The default value is { 0, 0, 0 } (no net force).-->
		<xsd:attribute name="sourceForce" type="R1Tensor" default="{0,0,0}" />
		<!--sourceMoment => Moment of the source: 6 real values describing a symmetric tensor in Voigt notation.The default value is { 1, 1, 1, 0, 0, 0 } (diagonal moment, corresponding to a seismic charge).-->
		<xsd:attribute name="sourceMoment" type="R2SymTensor" default="{1,1,1,0,0,0}" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--timeSourceDelay => Source time delay (1 / f0 by default)-->
		<xsd:attribute name="timeSourceDelay" type="real32" default="-1" />
		<!--timeSourceFrequency => Central frequency for the time source-->
		<xsd:attribute name="timeSourceFrequency" type="real32" default="0" />
		<!--useDAS => Flag to indicate if DAS data will be modeled, and which DAS type to use: "none" to deactivate DAS, "strainIntegration" for strain integration, "dipole" for displacement difference-->
		<xsd:attribute name="useDAS" type="geos_WaveSolverUtils_DASType" default="none" />
		<!--useVTI => Flag to apply VTI anisotropy. The default is to use isotropic physic.-->
		<xsd:attribute name="useVTI" type="integer" default="0" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="EmbeddedSurfaceGeneratorType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--fractureRegion => (no description available)-->
		<xsd:attribute name="fractureRegion" type="groupNameRef" default="FractureRegion" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--mpiCommOrder => Flag to enable MPI consistent communication ordering-->
		<xsd:attribute name="mpiCommOrder" type="integer" default="0" />
		<!--targetObjects => List of geometric objects that will be used to initialized the embedded surfaces/fractures.-->
		<xsd:attribute name="targetObjects" type="groupNameRef_array" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="FlowProppantTransportType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--flowSolverName => Name of the flow solver used by the coupled solver-->
		<xsd:attribute name="flowSolverName" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
 - Coupling information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--proppantSolverName => Name of the proppant solver used by the coupled solver-->
		<xsd:attribute name="proppantSolverName" type="groupNameRef" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="HydrofractureType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--flowSolverName => Name of the flow solver used by the coupled solver-->
		<xsd:attribute name="flowSolverName" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--isLaggingFractureStencilWeightsUpdate => Flag to determine whether or not to apply lagging update for the fracture stencil weights. -->
		<xsd:attribute name="isLaggingFractureStencilWeightsUpdate" type="integer" default="0" />
		<!--isMatrixPoroelastic => (no description available)-->
		<xsd:attribute name="isMatrixPoroelastic" type="integer" default="0" />
		<!--isThermal => Flag indicating whether the problem is thermal or not. Set isThermal="1" to enable the thermal coupling-->
		<xsd:attribute name="isThermal" type="integer" default="0" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
 - Coupling information
 - Fracture generation information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxNumResolves => Value to indicate how many resolves may be executed to perform surface generation after the execution of flow and mechanics solver. -->
		<xsd:attribute name="maxNumResolves" type="integer" default="10" />
		<!--newFractureInitializationType => Type of new fracture element initialization. Can be Pressure or Displacement. -->
		<xsd:attribute name="newFractureInitializationType" type="geos_HydrofractureSolver_lt_geos_SinglePhasePoromechanics_lt_geos_SinglePhaseBase_cm_-geos_SolidMechanicsLagrangianFEM_gt_-_gt__InitializationType" default="Pressure" />
		<!--solidSolverName => Name of the solid solver used by the coupled solver-->
		<xsd:attribute name="solidSolverName" type="groupNameRef" use="required" />
		<!--stabilizationMultiplier => Constant multiplier of stabilization strength-->
		<xsd:attribute name="stabilizationMultiplier" type="real64" default="1" />
		<!--stabilizationRegionNames => Regions where stabilization is applied.-->
		<xsd:attribute name="stabilizationRegionNames" type="groupNameRef_array" default="{}" />
		<!--stabilizationType => StabilizationType. Options are:
None- Add no stabilization to mass equation 
Global- Add jump stabilization to all faces 
Local- Add jump stabilization on interior of macro elements-->
		<xsd:attribute name="stabilizationType" type="geos_stabilization_StabilizationType" default="None" />
		<!--surfaceGeneratorName => Name of the surface generator to use in the hydrofracture solver-->
		<xsd:attribute name="surfaceGeneratorName" type="groupNameRef" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--useQuasiNewton => (no description available)-->
		<xsd:attribute name="useQuasiNewton" type="integer" default="0" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_HydrofractureSolver_lt_geos_SinglePhasePoromechanics_lt_geos_SinglePhaseBase_cm_-geos_SolidMechanicsLagrangianFEM_gt_-_gt__InitializationType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|Pressure|Displacement" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="LaplaceFEMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--fieldName => Name of field variable-->
		<xsd:attribute name="fieldName" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--timeIntegrationOption => Time integration method. Options are:
* SteadyState
* ImplicitTransient-->
		<xsd:attribute name="timeIntegrationOption" type="geos_LaplaceBaseH1_TimeIntegrationOption" use="required" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_LaplaceBaseH1_TimeIntegrationOption">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|SteadyState|ImplicitTransient" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="MultiphasePoromechanicsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--flowSolverName => Name of the flow solver used by the coupled solver-->
		<xsd:attribute name="flowSolverName" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--isThermal => Flag indicating whether the problem is thermal or not. Set isThermal="1" to enable the thermal coupling-->
		<xsd:attribute name="isThermal" type="integer" default="0" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
 - Coupling information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--solidSolverName => Name of the solid solver used by the coupled solver-->
		<xsd:attribute name="solidSolverName" type="groupNameRef" use="required" />
		<!--stabilizationMultiplier => Constant multiplier of stabilization strength-->
		<xsd:attribute name="stabilizationMultiplier" type="real64" default="1" />
		<!--stabilizationRegionNames => Regions where stabilization is applied.-->
		<xsd:attribute name="stabilizationRegionNames" type="groupNameRef_array" default="{}" />
		<!--stabilizationType => StabilizationType. Options are:
None- Add no stabilization to mass equation 
Global- Add jump stabilization to all faces 
Local- Add jump stabilization on interior of macro elements-->
		<xsd:attribute name="stabilizationType" type="geos_stabilization_StabilizationType" default="None" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="MultiphasePoromechanicsReservoirType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
 - Coupling information
 - Crossflow information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--poromechanicsSolverName => Name of the poromechanics solver used by the coupled solver-->
		<xsd:attribute name="poromechanicsSolverName" type="groupNameRef" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--wellSolverName => Name of the well solver used by the coupled solver-->
		<xsd:attribute name="wellSolverName" type="groupNameRef" use="required" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PhaseFieldDamageFEMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--damageUpperBound => The upper bound of the damage-->
		<xsd:attribute name="damageUpperBound" type="real64" default="1.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--fieldName => name of field variable-->
		<xsd:attribute name="fieldName" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--irreversibilityFlag => The flag to indicate whether to apply the irreversibility constraint-->
		<xsd:attribute name="irreversibilityFlag" type="integer" default="0" />
		<!--localDissipation => Type of local dissipation function. Can be Linear or Quadratic-->
		<xsd:attribute name="localDissipation" type="geos_PhaseFieldDamageFEM_LocalDissipation" use="required" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--timeIntegrationOption => option for default time integration method-->
		<xsd:attribute name="timeIntegrationOption" type="geos_PhaseFieldDamageFEM_TimeIntegrationOption" use="required" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_PhaseFieldDamageFEM_LocalDissipation">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|Linear|Quadratic" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geos_PhaseFieldDamageFEM_TimeIntegrationOption">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|SteadyState|ImplicitTransient|ExplicitTransient" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="PhaseFieldFractureType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--damageSolverName => Name of the damage solver used by the coupled solver-->
		<xsd:attribute name="damageSolverName" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
 - Coupling information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--solidSolverName => Name of the solid solver used by the coupled solver-->
		<xsd:attribute name="solidSolverName" type="groupNameRef" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ProppantTransportType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--allowNegativePressure => Flag indicating if negative pressure is allowed-->
		<xsd:attribute name="allowNegativePressure" type="integer" default="1" />
		<!--bridgingFactor => Bridging factor used for bridging/screen-out calculation-->
		<xsd:attribute name="bridgingFactor" type="real64" default="0" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--criticalShieldsNumber => Critical Shields number-->
		<xsd:attribute name="criticalShieldsNumber" type="real64" default="0" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--frictionCoefficient => Friction coefficient-->
		<xsd:attribute name="frictionCoefficient" type="real64" default="0.03" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--isThermal => Flag indicating whether the problem is thermal or not.-->
		<xsd:attribute name="isThermal" type="integer" default="0" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxAbsolutePressureChange => Maximum (absolute) pressure change in a Newton iteration-->
		<xsd:attribute name="maxAbsolutePressureChange" type="real64" default="-1" />
		<!--maxProppantConcentration => Maximum proppant concentration-->
		<xsd:attribute name="maxProppantConcentration" type="real64" default="0.6" />
		<!--maxSequentialPressureChange => Maximum (absolute) pressure change in a sequential iteration, used for outer loop convergence check-->
		<xsd:attribute name="maxSequentialPressureChange" type="real64" default="100000" />
		<!--maxSequentialTemperatureChange => Maximum (absolute) temperature change in a sequential iteration, used for outer loop convergence check-->
		<xsd:attribute name="maxSequentialTemperatureChange" type="real64" default="0.1" />
		<!--proppantDensity => Proppant density-->
		<xsd:attribute name="proppantDensity" type="real64" default="2500" />
		<!--proppantDiameter => Proppant diameter-->
		<xsd:attribute name="proppantDiameter" type="real64" default="0.0004" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--updateProppantPacking => Flag that enables/disables proppant-packing update-->
		<xsd:attribute name="updateProppantPacking" type="integer" default="0" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ReactiveCompositionalMultiphaseOBLType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--OBLOperatorsTableFile => File containing OBL operator values-->
		<xsd:attribute name="OBLOperatorsTableFile" type="path" use="required" />
		<!--allowLocalOBLChopping => Allow keeping solution within OBL limits-->
		<xsd:attribute name="allowLocalOBLChopping" type="integer" default="1" />
		<!--allowNegativePressure => Flag indicating if negative pressure is allowed-->
		<xsd:attribute name="allowNegativePressure" type="integer" default="1" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--componentNames => List of component names-->
		<xsd:attribute name="componentNames" type="string_array" default="{}" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--enableEnergyBalance => Enable energy balance calculation and temperature degree of freedom-->
		<xsd:attribute name="enableEnergyBalance" type="integer" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--isThermal => Flag indicating whether the problem is thermal or not.-->
		<xsd:attribute name="isThermal" type="integer" default="0" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxAbsolutePressureChange => Maximum (absolute) pressure change in a Newton iteration-->
		<xsd:attribute name="maxAbsolutePressureChange" type="real64" default="-1" />
		<!--maxCompFractionChange => Maximum (absolute) change in a component fraction between two Newton iterations-->
		<xsd:attribute name="maxCompFractionChange" type="real64" default="1" />
		<!--maxSequentialPressureChange => Maximum (absolute) pressure change in a sequential iteration, used for outer loop convergence check-->
		<xsd:attribute name="maxSequentialPressureChange" type="real64" default="100000" />
		<!--maxSequentialTemperatureChange => Maximum (absolute) temperature change in a sequential iteration, used for outer loop convergence check-->
		<xsd:attribute name="maxSequentialTemperatureChange" type="real64" default="0.1" />
		<!--numComponents => Number of components-->
		<xsd:attribute name="numComponents" type="integer" use="required" />
		<!--numPhases => Number of phases-->
		<xsd:attribute name="numPhases" type="integer" use="required" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" default="{}" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--transMultExp => Exponent of dynamic transmissibility multiplier-->
		<xsd:attribute name="transMultExp" type="real64" default="1" />
		<!--useDARTSL2Norm => Use L2 norm calculation similar to one used DARTS-->
		<xsd:attribute name="useDARTSL2Norm" type="integer" default="1" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SeismicityRateType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--backgroundStressingRate => Background stressing rate (Pa/s).-->
		<xsd:attribute name="backgroundStressingRate" type="real64" use="required" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--directEffect => Rate-and-state friction direct effect parameter.-->
		<xsd:attribute name="directEffect" type="real64" use="required" />
		<!--faultNormalDirection => Fault normal direction-->
		<xsd:attribute name="faultNormalDirection" type="R1Tensor" default="{0,0,0}" />
		<!--faultShearDirection => Fault shear direction-->
		<xsd:attribute name="faultShearDirection" type="R1Tensor" default="{0,0,0}" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--stressSolverName => Name of solver for computing stress-->
		<xsd:attribute name="stressSolverName" type="string" default="" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhaseFVMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--allowNegativePressure => Flag indicating if negative pressure is allowed-->
		<xsd:attribute name="allowNegativePressure" type="integer" default="1" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--isThermal => Flag indicating whether the problem is thermal or not.
SourceFluxes application if isThermal is enabled :
- negative value (injection): the mass balance equation is modified to considered the additional source term,
- positive value (production): both the mass balance and the energy balance equations are modified to considered the additional source term.
For the energy balance equation, the mass flux is multipied by the enthalpy in the cell from which the fluid is being produced.-->
		<xsd:attribute name="isThermal" type="integer" default="0" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxAbsolutePressureChange => Maximum (absolute) pressure change in a Newton iteration-->
		<xsd:attribute name="maxAbsolutePressureChange" type="real64" default="-1" />
		<!--maxSequentialPressureChange => Maximum (absolute) pressure change in a sequential iteration, used for outer loop convergence check-->
		<xsd:attribute name="maxSequentialPressureChange" type="real64" default="100000" />
		<!--maxSequentialTemperatureChange => Maximum (absolute) temperature change in a sequential iteration, used for outer loop convergence check-->
		<xsd:attribute name="maxSequentialTemperatureChange" type="real64" default="0.1" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--temperature => Temperature-->
		<xsd:attribute name="temperature" type="real64" default="0" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhaseHybridFVMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--allowNegativePressure => Flag indicating if negative pressure is allowed-->
		<xsd:attribute name="allowNegativePressure" type="integer" default="1" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--isThermal => Flag indicating whether the problem is thermal or not.
SourceFluxes application if isThermal is enabled :
- negative value (injection): the mass balance equation is modified to considered the additional source term,
- positive value (production): both the mass balance and the energy balance equations are modified to considered the additional source term.
For the energy balance equation, the mass flux is multipied by the enthalpy in the cell from which the fluid is being produced.-->
		<xsd:attribute name="isThermal" type="integer" default="0" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxAbsolutePressureChange => Maximum (absolute) pressure change in a Newton iteration-->
		<xsd:attribute name="maxAbsolutePressureChange" type="real64" default="-1" />
		<!--maxSequentialPressureChange => Maximum (absolute) pressure change in a sequential iteration, used for outer loop convergence check-->
		<xsd:attribute name="maxSequentialPressureChange" type="real64" default="100000" />
		<!--maxSequentialTemperatureChange => Maximum (absolute) temperature change in a sequential iteration, used for outer loop convergence check-->
		<xsd:attribute name="maxSequentialTemperatureChange" type="real64" default="0.1" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--temperature => Temperature-->
		<xsd:attribute name="temperature" type="real64" default="0" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhasePoromechanicsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--flowSolverName => Name of the flow solver used by the coupled solver-->
		<xsd:attribute name="flowSolverName" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--isThermal => Flag indicating whether the problem is thermal or not. Set isThermal="1" to enable the thermal coupling-->
		<xsd:attribute name="isThermal" type="integer" default="0" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
 - Coupling information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--solidSolverName => Name of the solid solver used by the coupled solver-->
		<xsd:attribute name="solidSolverName" type="groupNameRef" use="required" />
		<!--stabilizationMultiplier => Constant multiplier of stabilization strength-->
		<xsd:attribute name="stabilizationMultiplier" type="real64" default="1" />
		<!--stabilizationRegionNames => Regions where stabilization is applied.-->
		<xsd:attribute name="stabilizationRegionNames" type="groupNameRef_array" default="{}" />
		<!--stabilizationType => StabilizationType. Options are:
None- Add no stabilization to mass equation 
Global- Add jump stabilization to all faces 
Local- Add jump stabilization on interior of macro elements-->
		<xsd:attribute name="stabilizationType" type="geos_stabilization_StabilizationType" default="None" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhasePoromechanicsConformingFracturesType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--flowSolverName => Name of the flow solver used by the coupled solver-->
		<xsd:attribute name="flowSolverName" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--isThermal => Flag indicating whether the problem is thermal or not. Set isThermal="1" to enable the thermal coupling-->
		<xsd:attribute name="isThermal" type="integer" default="0" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
 - Coupling information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--solidSolverName => Name of the solid solver used by the coupled solver-->
		<xsd:attribute name="solidSolverName" type="groupNameRef" use="required" />
		<!--stabilizationMultiplier => Constant multiplier of stabilization strength-->
		<xsd:attribute name="stabilizationMultiplier" type="real64" default="1" />
		<!--stabilizationRegionNames => Regions where stabilization is applied.-->
		<xsd:attribute name="stabilizationRegionNames" type="groupNameRef_array" default="{}" />
		<!--stabilizationType => StabilizationType. Options are:
None- Add no stabilization to mass equation 
Global- Add jump stabilization to all faces 
Local- Add jump stabilization on interior of macro elements-->
		<xsd:attribute name="stabilizationType" type="geos_stabilization_StabilizationType" default="None" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhasePoromechanicsConformingFracturesReservoirType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
 - Coupling information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--poromechanicsConformingFracturesSolverName => Name of the poromechanicsConformingFractures solver used by the coupled solver-->
		<xsd:attribute name="poromechanicsConformingFracturesSolverName" type="groupNameRef" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--wellSolverName => Name of the well solver used by the coupled solver-->
		<xsd:attribute name="wellSolverName" type="groupNameRef" use="required" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhasePoromechanicsEmbeddedFracturesType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--flowSolverName => Name of the flow solver used by the coupled solver-->
		<xsd:attribute name="flowSolverName" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--isThermal => Flag indicating whether the problem is thermal or not. Set isThermal="1" to enable the thermal coupling-->
		<xsd:attribute name="isThermal" type="integer" default="0" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
 - Coupling information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--solidSolverName => Name of the solid solver used by the coupled solver-->
		<xsd:attribute name="solidSolverName" type="groupNameRef" use="required" />
		<!--stabilizationMultiplier => Constant multiplier of stabilization strength-->
		<xsd:attribute name="stabilizationMultiplier" type="real64" default="1" />
		<!--stabilizationRegionNames => Regions where stabilization is applied.-->
		<xsd:attribute name="stabilizationRegionNames" type="groupNameRef_array" default="{}" />
		<!--stabilizationType => StabilizationType. Options are:
None- Add no stabilization to mass equation 
Global- Add jump stabilization to all faces 
Local- Add jump stabilization on interior of macro elements-->
		<xsd:attribute name="stabilizationType" type="geos_stabilization_StabilizationType" default="None" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhasePoromechanicsReservoirType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
 - Coupling information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--poromechanicsSolverName => Name of the poromechanics solver used by the coupled solver-->
		<xsd:attribute name="poromechanicsSolverName" type="groupNameRef" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--wellSolverName => Name of the well solver used by the coupled solver-->
		<xsd:attribute name="wellSolverName" type="groupNameRef" use="required" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhaseProppantFVMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--allowNegativePressure => Flag indicating if negative pressure is allowed-->
		<xsd:attribute name="allowNegativePressure" type="integer" default="1" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--isThermal => Flag indicating whether the problem is thermal or not.
SourceFluxes application if isThermal is enabled :
- negative value (injection): the mass balance equation is modified to considered the additional source term,
- positive value (production): both the mass balance and the energy balance equations are modified to considered the additional source term.
For the energy balance equation, the mass flux is multipied by the enthalpy in the cell from which the fluid is being produced.-->
		<xsd:attribute name="isThermal" type="integer" default="0" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxAbsolutePressureChange => Maximum (absolute) pressure change in a Newton iteration-->
		<xsd:attribute name="maxAbsolutePressureChange" type="real64" default="-1" />
		<!--maxSequentialPressureChange => Maximum (absolute) pressure change in a sequential iteration, used for outer loop convergence check-->
		<xsd:attribute name="maxSequentialPressureChange" type="real64" default="100000" />
		<!--maxSequentialTemperatureChange => Maximum (absolute) temperature change in a sequential iteration, used for outer loop convergence check-->
		<xsd:attribute name="maxSequentialTemperatureChange" type="real64" default="0.1" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--temperature => Temperature-->
		<xsd:attribute name="temperature" type="real64" default="0" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhaseReservoirType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--flowSolverName => Name of the flow solver used by the coupled solver-->
		<xsd:attribute name="flowSolverName" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
 - Coupling information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--wellSolverName => Name of the well solver used by the coupled solver-->
		<xsd:attribute name="wellSolverName" type="groupNameRef" use="required" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhaseReservoirPoromechanicsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--isThermal => Flag indicating whether the problem is thermal or not. Set isThermal="1" to enable the thermal coupling-->
		<xsd:attribute name="isThermal" type="integer" default="0" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
 - Coupling information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--reservoirAndWellsSolverName => Name of the reservoirAndWells solver used by the coupled solver-->
		<xsd:attribute name="reservoirAndWellsSolverName" type="groupNameRef" use="required" />
		<!--solidSolverName => Name of the solid solver used by the coupled solver-->
		<xsd:attribute name="solidSolverName" type="groupNameRef" use="required" />
		<!--stabilizationMultiplier => Constant multiplier of stabilization strength-->
		<xsd:attribute name="stabilizationMultiplier" type="real64" default="1" />
		<!--stabilizationRegionNames => Regions where stabilization is applied.-->
		<xsd:attribute name="stabilizationRegionNames" type="groupNameRef_array" default="{}" />
		<!--stabilizationType => StabilizationType. Options are:
None- Add no stabilization to mass equation 
Global- Add jump stabilization to all faces 
Local- Add jump stabilization on interior of macro elements-->
		<xsd:attribute name="stabilizationType" type="geos_stabilization_StabilizationType" default="None" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhaseWellType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="WellControls" type="WellControlsType" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
 - Well control information
 - Crossflow information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--writeCSV => Write rates into a CSV file-->
		<xsd:attribute name="writeCSV" type="integer" default="0" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SolidMechanicsAugmentedLagrangianContactType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--contactPenaltyStiffness => Value of the penetration penalty stiffness. Units of Pressure/length-->
		<xsd:attribute name="contactPenaltyStiffness" type="real64" default="0" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling
 - Configuration information-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--massDamping => Value of mass based damping coefficient. -->
		<xsd:attribute name="massDamping" type="real64" default="0" />
		<!--maxNumResolves => Value to indicate how many resolves may be executed after some other event is executed. For example, if a SurfaceGenerator is specified, it will be executed after the mechanics solve. However if a new surface is generated, then the mechanics solve must be executed again due to the change in topology.-->
		<xsd:attribute name="maxNumResolves" type="integer" default="10" />
		<!--newmarkBeta => Value of :math:`\beta` in the Newmark Method for Implicit Dynamic time integration option. This should be pow(newmarkGamma+0.5,2.0)/4.0 unless you know what you are doing.-->
		<xsd:attribute name="newmarkBeta" type="real64" default="0.25" />
		<!--newmarkGamma => Value of :math:`\gamma` in the Newmark Method for Implicit Dynamic time integration option-->
		<xsd:attribute name="newmarkGamma" type="real64" default="0.5" />
		<!--stiffnessDamping => Value of stiffness based damping coefficient. -->
		<xsd:attribute name="stiffnessDamping" type="real64" default="0" />
		<!--strainTheory => Indicates whether or not to use `Infinitesimal Strain Theory <https://en.wikipedia.org/wiki/Infinitesimal_strain_theory>`_, or `Finite Strain Theory <https://en.wikipedia.org/wiki/Finite_strain_theory>`_. Valid Inputs are:
 0 - Infinitesimal Strain 
 1 - Finite Strain-->
		<xsd:attribute name="strainTheory" type="integer" default="0" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--timeIntegrationOption => Time integration method. Options are:
* QuasiStatic
* ImplicitDynamic
* ExplicitDynamic-->
		<xsd:attribute name="timeIntegrationOption" type="geos_SolidMechanicsLagrangianFEM_TimeIntegrationOption" default="ExplicitDynamic" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_SolidMechanicsLagrangianFEM_TimeIntegrationOption">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|QuasiStatic|ImplicitDynamic|ExplicitDynamic" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="SolidMechanicsEmbeddedFracturesType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--contactPenaltyStiffness => Value of the penetration penalty stiffness. Units of Pressure/length-->
		<xsd:attribute name="contactPenaltyStiffness" type="real64" use="required" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--massDamping => Value of mass based damping coefficient. -->
		<xsd:attribute name="massDamping" type="real64" default="0" />
		<!--maxNumResolves => Value to indicate how many resolves may be executed after some other event is executed. For example, if a SurfaceGenerator is specified, it will be executed after the mechanics solve. However if a new surface is generated, then the mechanics solve must be executed again due to the change in topology.-->
		<xsd:attribute name="maxNumResolves" type="integer" default="10" />
		<!--newmarkBeta => Value of :math:`\beta` in the Newmark Method for Implicit Dynamic time integration option. This should be pow(newmarkGamma+0.5,2.0)/4.0 unless you know what you are doing.-->
		<xsd:attribute name="newmarkBeta" type="real64" default="0.25" />
		<!--newmarkGamma => Value of :math:`\gamma` in the Newmark Method for Implicit Dynamic time integration option-->
		<xsd:attribute name="newmarkGamma" type="real64" default="0.5" />
		<!--stiffnessDamping => Value of stiffness based damping coefficient. -->
		<xsd:attribute name="stiffnessDamping" type="real64" default="0" />
		<!--strainTheory => Indicates whether or not to use `Infinitesimal Strain Theory <https://en.wikipedia.org/wiki/Infinitesimal_strain_theory>`_, or `Finite Strain Theory <https://en.wikipedia.org/wiki/Finite_strain_theory>`_. Valid Inputs are:
 0 - Infinitesimal Strain 
 1 - Finite Strain-->
		<xsd:attribute name="strainTheory" type="integer" default="0" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--timeIntegrationOption => Time integration method. Options are:
* QuasiStatic
* ImplicitDynamic
* ExplicitDynamic-->
		<xsd:attribute name="timeIntegrationOption" type="geos_SolidMechanicsLagrangianFEM_TimeIntegrationOption" default="ExplicitDynamic" />
		<!--useStaticCondensation => Defines whether to use static condensation or not.-->
		<xsd:attribute name="useStaticCondensation" type="integer" default="0" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SolidMechanicsLagrangeContactType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--contactPenaltyStiffness => Value of the penetration penalty stiffness. Units of Pressure/length-->
		<xsd:attribute name="contactPenaltyStiffness" type="real64" default="0" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling
 - Configuration information-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--massDamping => Value of mass based damping coefficient. -->
		<xsd:attribute name="massDamping" type="real64" default="0" />
		<!--maxNumResolves => Value to indicate how many resolves may be executed after some other event is executed. For example, if a SurfaceGenerator is specified, it will be executed after the mechanics solve. However if a new surface is generated, then the mechanics solve must be executed again due to the change in topology.-->
		<xsd:attribute name="maxNumResolves" type="integer" default="10" />
		<!--newmarkBeta => Value of :math:`\beta` in the Newmark Method for Implicit Dynamic time integration option. This should be pow(newmarkGamma+0.5,2.0)/4.0 unless you know what you are doing.-->
		<xsd:attribute name="newmarkBeta" type="real64" default="0.25" />
		<!--newmarkGamma => Value of :math:`\gamma` in the Newmark Method for Implicit Dynamic time integration option-->
		<xsd:attribute name="newmarkGamma" type="real64" default="0.5" />
		<!--stabilizationName => Name of the stabilization to use in the lagrangian contact solver-->
		<xsd:attribute name="stabilizationName" type="groupNameRef" use="required" />
		<!--stabilizationScalingCoefficient => It be used to increase the scale of the stabilization entries. A value < 1.0 results in larger entries in the stabilization matrix.-->
		<xsd:attribute name="stabilizationScalingCoefficient" type="real64" default="1" />
		<!--stiffnessDamping => Value of stiffness based damping coefficient. -->
		<xsd:attribute name="stiffnessDamping" type="real64" default="0" />
		<!--strainTheory => Indicates whether or not to use `Infinitesimal Strain Theory <https://en.wikipedia.org/wiki/Infinitesimal_strain_theory>`_, or `Finite Strain Theory <https://en.wikipedia.org/wiki/Finite_strain_theory>`_. Valid Inputs are:
 0 - Infinitesimal Strain 
 1 - Finite Strain-->
		<xsd:attribute name="strainTheory" type="integer" default="0" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--timeIntegrationOption => Time integration method. Options are:
* QuasiStatic
* ImplicitDynamic
* ExplicitDynamic-->
		<xsd:attribute name="timeIntegrationOption" type="geos_SolidMechanicsLagrangianFEM_TimeIntegrationOption" default="ExplicitDynamic" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SolidMechanicsLagrangianSSLEType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--contactPenaltyStiffness => Value of the penetration penalty stiffness. Units of Pressure/length-->
		<xsd:attribute name="contactPenaltyStiffness" type="real64" default="0" />
		<!--contactRelationName => Name of contact relation to enforce constraints on fracture boundary.-->
		<xsd:attribute name="contactRelationName" type="groupNameRef" default="NOCONTACT" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--massDamping => Value of mass based damping coefficient. -->
		<xsd:attribute name="massDamping" type="real64" default="0" />
		<!--maxNumResolves => Value to indicate how many resolves may be executed after some other event is executed. For example, if a SurfaceGenerator is specified, it will be executed after the mechanics solve. However if a new surface is generated, then the mechanics solve must be executed again due to the change in topology.-->
		<xsd:attribute name="maxNumResolves" type="integer" default="10" />
		<!--newmarkBeta => Value of :math:`\beta` in the Newmark Method for Implicit Dynamic time integration option. This should be pow(newmarkGamma+0.5,2.0)/4.0 unless you know what you are doing.-->
		<xsd:attribute name="newmarkBeta" type="real64" default="0.25" />
		<!--newmarkGamma => Value of :math:`\gamma` in the Newmark Method for Implicit Dynamic time integration option-->
		<xsd:attribute name="newmarkGamma" type="real64" default="0.5" />
		<!--stiffnessDamping => Value of stiffness based damping coefficient. -->
		<xsd:attribute name="stiffnessDamping" type="real64" default="0" />
		<!--strainTheory => Indicates whether or not to use `Infinitesimal Strain Theory <https://en.wikipedia.org/wiki/Infinitesimal_strain_theory>`_, or `Finite Strain Theory <https://en.wikipedia.org/wiki/Finite_strain_theory>`_. Valid Inputs are:
 0 - Infinitesimal Strain 
 1 - Finite Strain-->
		<xsd:attribute name="strainTheory" type="integer" default="0" />
		<!--surfaceGeneratorName => Name of the surface generator to use-->
		<xsd:attribute name="surfaceGeneratorName" type="string" default="" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--timeIntegrationOption => Time integration method. Options are:
* QuasiStatic
* ImplicitDynamic
* ExplicitDynamic-->
		<xsd:attribute name="timeIntegrationOption" type="geos_SolidMechanicsLagrangianFEM_TimeIntegrationOption" default="ExplicitDynamic" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SolidMechanics_LagrangianFEMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--contactPenaltyStiffness => Value of the penetration penalty stiffness. Units of Pressure/length-->
		<xsd:attribute name="contactPenaltyStiffness" type="real64" default="0" />
		<!--contactRelationName => Name of contact relation to enforce constraints on fracture boundary.-->
		<xsd:attribute name="contactRelationName" type="groupNameRef" default="NOCONTACT" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--massDamping => Value of mass based damping coefficient. -->
		<xsd:attribute name="massDamping" type="real64" default="0" />
		<!--maxNumResolves => Value to indicate how many resolves may be executed after some other event is executed. For example, if a SurfaceGenerator is specified, it will be executed after the mechanics solve. However if a new surface is generated, then the mechanics solve must be executed again due to the change in topology.-->
		<xsd:attribute name="maxNumResolves" type="integer" default="10" />
		<!--newmarkBeta => Value of :math:`\beta` in the Newmark Method for Implicit Dynamic time integration option. This should be pow(newmarkGamma+0.5,2.0)/4.0 unless you know what you are doing.-->
		<xsd:attribute name="newmarkBeta" type="real64" default="0.25" />
		<!--newmarkGamma => Value of :math:`\gamma` in the Newmark Method for Implicit Dynamic time integration option-->
		<xsd:attribute name="newmarkGamma" type="real64" default="0.5" />
		<!--stiffnessDamping => Value of stiffness based damping coefficient. -->
		<xsd:attribute name="stiffnessDamping" type="real64" default="0" />
		<!--strainTheory => Indicates whether or not to use `Infinitesimal Strain Theory <https://en.wikipedia.org/wiki/Infinitesimal_strain_theory>`_, or `Finite Strain Theory <https://en.wikipedia.org/wiki/Finite_strain_theory>`_. Valid Inputs are:
 0 - Infinitesimal Strain 
 1 - Finite Strain-->
		<xsd:attribute name="strainTheory" type="integer" default="0" />
		<!--surfaceGeneratorName => Name of the surface generator to use-->
		<xsd:attribute name="surfaceGeneratorName" type="string" default="" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--timeIntegrationOption => Time integration method. Options are:
* QuasiStatic
* ImplicitDynamic
* ExplicitDynamic-->
		<xsd:attribute name="timeIntegrationOption" type="geos_SolidMechanicsLagrangianFEM_TimeIntegrationOption" default="ExplicitDynamic" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SolidMechanics_MPMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--boundaryConditionTypes => Boundary conditions on x-, x+, y-, y+, z- and z+ faces. Options are:
* Outflow
* Symmetry-->
		<xsd:attribute name="boundaryConditionTypes" type="integer_array" default="{0}" />
		<!--boxAverageHistory => Flag for whether to output box average history-->
		<xsd:attribute name="boxAverageHistory" type="integer" default="0" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--contactGapCorrection => Flag for mitigating contact gaps-->
		<xsd:attribute name="contactGapCorrection" type="integer" default="0" />
		<!--cpdiDomainScaling => Option for CPDI domain scaling-->
		<xsd:attribute name="cpdiDomainScaling" type="integer" default="0" />
		<!--damageFieldPartitioning => Flag for using the gradient of the particle damage field to partition material into separate velocity fields-->
		<xsd:attribute name="damageFieldPartitioning" type="integer" default="0" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="groupNameRef" use="required" />
		<!--fTableInterpType => The type of F table interpolation. Options are 0 (linear), 1 (cosine), 2 (quintic polynomial).-->
		<xsd:attribute name="fTableInterpType" type="integer" default="0" />
		<!--fTablePath => Path to f-table-->
		<xsd:attribute name="fTablePath" type="path" default="" />
		<!--frictionCoefficient => Coefficient of friction, currently assumed to be the same everywhere-->
		<xsd:attribute name="frictionCoefficient" type="real64" default="0" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
2
 - The summary of declared fields and coupling-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--needsNeighborList => Flag for whether to construct neighbor list-->
		<xsd:attribute name="needsNeighborList" type="integer" default="0" />
		<!--neighborRadius => Neighbor radius for SPH-type calculations-->
		<xsd:attribute name="neighborRadius" type="real64" default="-1" />
		<!--planeStrain => Flag for performing plane strain calculations-->
		<xsd:attribute name="planeStrain" type="integer" default="0" />
		<!--prescribedBcTable => Flag for whether to have time-dependent boundary condition types-->
		<xsd:attribute name="prescribedBcTable" type="integer" default="0" />
		<!--prescribedBoundaryFTable => Flag for whether to have time-dependent boundary conditions described by a global background grid F-->
		<xsd:attribute name="prescribedBoundaryFTable" type="integer" default="0" />
		<!--reactionHistory => Flag for whether to output face reaction history-->
		<xsd:attribute name="reactionHistory" type="integer" default="0" />
		<!--separabilityMinDamage => Damage threshold for field separability-->
		<xsd:attribute name="separabilityMinDamage" type="real64" default="0.5" />
		<!--solverProfiling => Flag for timing subroutines in the solver-->
		<xsd:attribute name="solverProfiling" type="integer" default="0" />
		<!--surfaceDetection => Flag for automatic surface detection on the 1st cycle-->
		<xsd:attribute name="surfaceDetection" type="integer" default="0" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--timeIntegrationOption => Time integration method. Options are:
* QuasiStatic
* ImplicitDynamic
* ExplicitDynamic-->
		<xsd:attribute name="timeIntegrationOption" type="geos_SolidMechanicsMPM_TimeIntegrationOption" default="ExplicitDynamic" />
		<!--treatFullyDamagedAsSingleField => Whether to consolidate fully damaged fields into a single field. Nice for modeling damaged mush.-->
		<xsd:attribute name="treatFullyDamagedAsSingleField" type="integer" default="1" />
		<!--useDamageAsSurfaceFlag => Indicates whether particle damage at the beginning of the simulation should be interpreted as a surface flag-->
		<xsd:attribute name="useDamageAsSurfaceFlag" type="integer" default="0" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_SolidMechanicsMPM_TimeIntegrationOption">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|QuasiStatic|ImplicitDynamic|ExplicitDynamic" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="SurfaceGeneratorType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--fractureRegion => (no description available)-->
		<xsd:attribute name="fractureRegion" type="groupNameRef" default="Fracture" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--isPoroelastic => Flag that defines whether the material is poroelastic or not.-->
		<xsd:attribute name="isPoroelastic" type="integer" default="0" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Line search information
 - Solution information (scaling, maximum changes, quality check)
 - Convergence information
 - Time step information
 - Linear solver information
 - Nonlinear solver information
 - Solver timers information
 - Fracture generation information
2
 - The summary of declared fields and coupling
 - Mapping information
3
 - Rupture rate information-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--mpiCommOrder => Flag to enable MPI consistent communication ordering-->
		<xsd:attribute name="mpiCommOrder" type="integer" default="0" />
		<!--nodeBasedSIF => Flag for choosing between node or edge based criteria: 1 for node based criterion-->
		<xsd:attribute name="nodeBasedSIF" type="integer" default="0" />
		<!--rockToughness => Rock toughness of the solid material-->
		<xsd:attribute name="rockToughness" type="real64" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="groupNameRef_array" use="required" />
		<!--writeLinearSystem => Write matrix, rhs, solution to screen ( = 1) or file ( = 2).-->
		<xsd:attribute name="writeLinearSystem" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="TasksType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="CellToCellDataCollection" type="CellToCellDataCollectionType" />
			<xsd:element name="CompositionalMultiphaseReservoirPoromechanicsInitialization" type="CompositionalMultiphaseReservoirPoromechanicsInitializationType" />
			<xsd:element name="CompositionalMultiphaseStatistics" type="CompositionalMultiphaseStatisticsType" />
			<xsd:element name="HydrofractureInitialization" type="HydrofractureInitializationType" />
			<xsd:element name="MultiphasePoromechanicsInitialization" type="MultiphasePoromechanicsInitializationType" />
			<xsd:element name="PVTDriver" type="PVTDriverType" />
			<xsd:element name="PackCollection" type="PackCollectionType" />
			<xsd:element name="ReactiveFluidDriver" type="ReactiveFluidDriverType" />
			<xsd:element name="RelpermDriver" type="RelpermDriverType" />
			<xsd:element name="SinglePhasePoromechanicsConformingFracturesInitialization" type="SinglePhasePoromechanicsConformingFracturesInitializationType" />
			<xsd:element name="SinglePhasePoromechanicsEmbeddedFracturesInitialization" type="SinglePhasePoromechanicsEmbeddedFracturesInitializationType" />
			<xsd:element name="SinglePhasePoromechanicsInitialization" type="SinglePhasePoromechanicsInitializationType" />
			<xsd:element name="SinglePhaseReservoirPoromechanicsInitialization" type="SinglePhaseReservoirPoromechanicsInitializationType" />
			<xsd:element name="SinglePhaseStatistics" type="SinglePhaseStatisticsType" />
			<xsd:element name="SolidMechanicsStateReset" type="SolidMechanicsStateResetType" />
			<xsd:element name="SolidMechanicsStatistics" type="SolidMechanicsStatisticsType" />
			<xsd:element name="SourceFluxStatistics" type="SourceFluxStatisticsType" />
			<xsd:element name="TriaxialDriver" type="TriaxialDriverType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="CellToCellDataCollectionType">
		<!--flowSolverName => Name of the flow solver, to get the permeabilities.-->
		<xsd:attribute name="flowSolverName" type="groupNameRef" use="required" />
		<!--logLevel => When higher than 1: Display store events details.-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--meshBody => Name of the target -->
		<xsd:attribute name="meshBody" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CompositionalMultiphaseReservoirPoromechanicsInitializationType">
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Initialization information-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--poromechanicsSolverName => Name of the poromechanics solver-->
		<xsd:attribute name="poromechanicsSolverName" type="groupNameRef" use="required" />
		<!--solidMechanicsStatisticsName => Name of the solid mechanics statistics-->
		<xsd:attribute name="solidMechanicsStatisticsName" type="groupNameRef" default="" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CompositionalMultiphaseStatisticsType">
		<!--computeCFLNumbers => Flag to decide whether CFL numbers are computed or not-->
		<xsd:attribute name="computeCFLNumbers" type="integer" default="0" />
		<!--computeRegionStatistics => Flag to decide whether region statistics are computed or not-->
		<xsd:attribute name="computeRegionStatistics" type="integer" default="1" />
		<!--flowSolverName => Name of the flow solver-->
		<xsd:attribute name="flowSolverName" type="groupNameRef" use="required" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - CFL information
 - Print statistics-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--relpermThreshold => Flag to decide whether a phase is considered mobile (when the relperm is above the threshold) or immobile (when the relperm is below the threshold) in metric 2-->
		<xsd:attribute name="relpermThreshold" type="real64" default="1e-06" />
		<!--writeCSV => Write statistics into a CSV file-->
		<xsd:attribute name="writeCSV" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="HydrofractureInitializationType">
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Initialization information-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--poromechanicsSolverName => Name of the poromechanics solver-->
		<xsd:attribute name="poromechanicsSolverName" type="groupNameRef" use="required" />
		<!--solidMechanicsStatisticsName => Name of the solid mechanics statistics-->
		<xsd:attribute name="solidMechanicsStatisticsName" type="groupNameRef" default="" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="MultiphasePoromechanicsInitializationType">
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Initialization information-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--poromechanicsSolverName => Name of the poromechanics solver-->
		<xsd:attribute name="poromechanicsSolverName" type="groupNameRef" use="required" />
		<!--solidMechanicsStatisticsName => Name of the solid mechanics statistics-->
		<xsd:attribute name="solidMechanicsStatisticsName" type="groupNameRef" default="" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PVTDriverType">
		<!--baseline => Baseline file-->
		<xsd:attribute name="baseline" type="path" default="none" />
		<!--feedComposition => Feed composition array [mol fraction]-->
		<xsd:attribute name="feedComposition" type="real64_array" use="required" />
		<!--fluid => Fluid to test-->
		<xsd:attribute name="fluid" type="groupNameRef" use="required" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--output => Output file-->
		<xsd:attribute name="output" type="string" default="none" />
		<!--outputCompressibility => Flag to indicate that the total compressibility should be output-->
		<xsd:attribute name="outputCompressibility" type="integer" default="0" />
		<!--outputMassDensity => Flag to indicate that the mass density of each phase should be output-->
		<xsd:attribute name="outputMassDensity" type="integer" default="0" />
		<!--outputPhaseComposition => Flag to indicate that phase compositions should be output-->
		<xsd:attribute name="outputPhaseComposition" type="integer" default="0" />
		<!--pressureControl => Function controlling pressure time history-->
		<xsd:attribute name="pressureControl" type="groupNameRef" use="required" />
		<!--steps => Number of load steps to take-->
		<xsd:attribute name="steps" type="integer" use="required" />
		<!--temperatureControl => Function controlling temperature time history-->
		<xsd:attribute name="temperatureControl" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PackCollectionType">
		<!--disableCoordCollection => Whether or not to create coordinate meta-collectors if collected objects are mesh objects.-->
		<xsd:attribute name="disableCoordCollection" type="integer" default="0" />
		<!--fieldName => The name of the (packable) field associated with the specified object to retrieve data from-->
		<xsd:attribute name="fieldName" type="groupNameRef" use="required" />
		<!--objectPath => The name of the object from which to retrieve field values.-->
		<xsd:attribute name="objectPath" type="groupNameRef" use="required" />
		<!--onlyOnSetChange => Whether or not to only collect when the collected sets of indices change in any way.-->
		<xsd:attribute name="onlyOnSetChange" type="integer" default="0" />
		<!--setNames => The set(s) for which to retrieve data.-->
		<xsd:attribute name="setNames" type="groupNameRef_array" default="{}" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ReactiveFluidDriverType">
		<!--baseline => Baseline file-->
		<xsd:attribute name="baseline" type="path" default="none" />
		<!--feedComposition => Feed composition array: total concentration of the primary species -->
		<xsd:attribute name="feedComposition" type="real64_array" use="required" />
		<!--fluid => Fluid to test-->
		<xsd:attribute name="fluid" type="groupNameRef" use="required" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--output => Output file-->
		<xsd:attribute name="output" type="string" default="none" />
		<!--pressureControl => Function controlling pressure time history-->
		<xsd:attribute name="pressureControl" type="groupNameRef" use="required" />
		<!--steps => Number of load steps to take-->
		<xsd:attribute name="steps" type="integer" use="required" />
		<!--temperatureControl => Function controlling temperature time history-->
		<xsd:attribute name="temperatureControl" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="RelpermDriverType">
		<!--baseline => Baseline file-->
		<xsd:attribute name="baseline" type="path" default="none" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--output => Output file-->
		<xsd:attribute name="output" type="string" default="none" />
		<!--relperm => Relperm model to test-->
		<xsd:attribute name="relperm" type="groupNameRef" use="required" />
		<!--steps => Number of saturation steps to take-->
		<xsd:attribute name="steps" type="integer" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhasePoromechanicsConformingFracturesInitializationType">
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Initialization information-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--poromechanicsSolverName => Name of the poromechanics solver-->
		<xsd:attribute name="poromechanicsSolverName" type="groupNameRef" use="required" />
		<!--solidMechanicsStatisticsName => Name of the solid mechanics statistics-->
		<xsd:attribute name="solidMechanicsStatisticsName" type="groupNameRef" default="" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhasePoromechanicsEmbeddedFracturesInitializationType">
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Initialization information-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--poromechanicsSolverName => Name of the poromechanics solver-->
		<xsd:attribute name="poromechanicsSolverName" type="groupNameRef" use="required" />
		<!--solidMechanicsStatisticsName => Name of the solid mechanics statistics-->
		<xsd:attribute name="solidMechanicsStatisticsName" type="groupNameRef" default="" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhasePoromechanicsInitializationType">
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Initialization information-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--poromechanicsSolverName => Name of the poromechanics solver-->
		<xsd:attribute name="poromechanicsSolverName" type="groupNameRef" use="required" />
		<!--solidMechanicsStatisticsName => Name of the solid mechanics statistics-->
		<xsd:attribute name="solidMechanicsStatisticsName" type="groupNameRef" default="" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhaseReservoirPoromechanicsInitializationType">
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Initialization information-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--poromechanicsSolverName => Name of the poromechanics solver-->
		<xsd:attribute name="poromechanicsSolverName" type="groupNameRef" use="required" />
		<!--solidMechanicsStatisticsName => Name of the solid mechanics statistics-->
		<xsd:attribute name="solidMechanicsStatisticsName" type="groupNameRef" default="" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhaseStatisticsType">
		<!--flowSolverName => Name of the flow solver-->
		<xsd:attribute name="flowSolverName" type="groupNameRef" use="required" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Print statistics-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--writeCSV => Write statistics into a CSV file-->
		<xsd:attribute name="writeCSV" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SolidMechanicsStateResetType">
		<!--disableInelasticity => Flag to enable/disable inelastic behavior-->
		<xsd:attribute name="disableInelasticity" type="integer" default="0" />
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Initialization information-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--resetDisplacements => Flag to reset displacements (and velocities)-->
		<xsd:attribute name="resetDisplacements" type="integer" default="1" />
		<!--solidSolverName => Name of the solid mechanics solver-->
		<xsd:attribute name="solidSolverName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SolidMechanicsStatisticsType">
		<!--logLevel => Sets the level of information to write in the standard output (the console typically).
Level 0 outputs no specific information for this solver. Higher levels require more outputs.
1
 - Print statistics-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--solidSolverName => Name of the solid solver-->
		<xsd:attribute name="solidSolverName" type="groupNameRef" use="required" />
		<!--writeCSV => Write statistics into a CSV file-->
		<xsd:attribute name="writeCSV" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SourceFluxStatisticsType">
		<!--flowSolverName => Name of the flow solver-->
		<xsd:attribute name="flowSolverName" type="groupNameRef" use="required" />
		<!--fluxNames => Name(s) array of the SourceFlux(s) for which we want the statistics. Use "*" to target all SourceFlux.-->
		<xsd:attribute name="fluxNames" type="groupNameRef_array" default="{*}" />
		<!--logLevel => Log level
- Log Level 1 outputs the sum of all SourceFlux(s) produced rate & mass,
- Log Level 2 details values for each SourceFlux,
- Log Level 3 details values for each region.-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--writeCSV => Write statistics into a CSV file-->
		<xsd:attribute name="writeCSV" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="TriaxialDriverType">
		<!--axialControl => Function controlling axial stress or strain (depending on test mode)-->
		<xsd:attribute name="axialControl" type="groupNameRef" use="required" />
		<!--baseline => Baseline file-->
		<xsd:attribute name="baseline" type="path" default="none" />
		<!--initialStress => Initial stress (scalar used to set an isotropic stress state)-->
		<xsd:attribute name="initialStress" type="real64" use="required" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--material => Solid material to test-->
		<xsd:attribute name="material" type="groupNameRef" use="required" />
		<!--mode => Test mode [stressControl, strainControl, mixedControl]-->
		<xsd:attribute name="mode" type="geos_TriaxialDriver_Mode" use="required" />
		<!--output => Output file-->
		<xsd:attribute name="output" type="string" default="none" />
		<!--radialControl => Function controlling radial stress or strain (depending on test mode)-->
		<xsd:attribute name="radialControl" type="groupNameRef" use="required" />
		<!--steps => Number of load steps to take-->
		<xsd:attribute name="steps" type="integer" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_TriaxialDriver_Mode">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|mixedControl|strainControl|stressControl" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="ConstitutiveType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="BiotPorosity" type="BiotPorosityType" />
			<xsd:element name="BlackOilFluid" type="BlackOilFluidType" />
			<xsd:element name="BrooksCoreyBakerRelativePermeability" type="BrooksCoreyBakerRelativePermeabilityType" />
			<xsd:element name="BrooksCoreyCapillaryPressure" type="BrooksCoreyCapillaryPressureType" />
			<xsd:element name="BrooksCoreyRelativePermeability" type="BrooksCoreyRelativePermeabilityType" />
			<xsd:element name="BrooksCoreyStone2RelativePermeability" type="BrooksCoreyStone2RelativePermeabilityType" />
			<xsd:element name="CO2BrineEzrokhiFluid" type="CO2BrineEzrokhiFluidType" />
			<xsd:element name="CO2BrineEzrokhiThermalFluid" type="CO2BrineEzrokhiThermalFluidType" />
			<xsd:element name="CO2BrinePhillipsFluid" type="CO2BrinePhillipsFluidType" />
			<xsd:element name="CO2BrinePhillipsThermalFluid" type="CO2BrinePhillipsThermalFluidType" />
			<xsd:element name="CarmanKozenyPermeability" type="CarmanKozenyPermeabilityType" />
			<xsd:element name="CeramicDamage" type="CeramicDamageType" />
			<xsd:element name="CompositionalMultiphaseFluid" type="CompositionalMultiphaseFluidType" />
			<xsd:element name="CompositionalTwoPhaseFluid" type="CompositionalTwoPhaseFluidType" />
			<xsd:element name="CompositionalTwoPhaseFluidLohrenzBrayClark" type="CompositionalTwoPhaseFluidLohrenzBrayClarkType" />
			<xsd:element name="CompressibleSinglePhaseFluid" type="CompressibleSinglePhaseFluidType" />
			<xsd:element name="CompressibleSolidCarmanKozenyPermeability" type="CompressibleSolidCarmanKozenyPermeabilityType" />
			<xsd:element name="CompressibleSolidConstantPermeability" type="CompressibleSolidConstantPermeabilityType" />
			<xsd:element name="CompressibleSolidExponentialDecayPermeability" type="CompressibleSolidExponentialDecayPermeabilityType" />
			<xsd:element name="CompressibleSolidParallelPlatesPermeability" type="CompressibleSolidParallelPlatesPermeabilityType" />
			<xsd:element name="CompressibleSolidPressurePermeability" type="CompressibleSolidPressurePermeabilityType" />
			<xsd:element name="CompressibleSolidSlipDependentPermeability" type="CompressibleSolidSlipDependentPermeabilityType" />
			<xsd:element name="CompressibleSolidWillisRichardsPermeability" type="CompressibleSolidWillisRichardsPermeabilityType" />
			<xsd:element name="ConstantDiffusion" type="ConstantDiffusionType" />
			<xsd:element name="ConstantPermeability" type="ConstantPermeabilityType" />
			<xsd:element name="Coulomb" type="CoulombType" />
			<xsd:element name="DamageElasticIsotropic" type="DamageElasticIsotropicType" />
			<xsd:element name="DamageSpectralElasticIsotropic" type="DamageSpectralElasticIsotropicType" />
			<xsd:element name="DamageVolDevElasticIsotropic" type="DamageVolDevElasticIsotropicType" />
			<xsd:element name="DeadOilFluid" type="DeadOilFluidType" />
			<xsd:element name="DelftEgg" type="DelftEggType" />
			<xsd:element name="DruckerPrager" type="DruckerPragerType" />
			<xsd:element name="ElasticIsotropic" type="ElasticIsotropicType" />
			<xsd:element name="ElasticIsotropicPressureDependent" type="ElasticIsotropicPressureDependentType" />
			<xsd:element name="ElasticOrthotropic" type="ElasticOrthotropicType" />
			<xsd:element name="ElasticTransverseIsotropic" type="ElasticTransverseIsotropicType" />
			<xsd:element name="ExponentialDecayPermeability" type="ExponentialDecayPermeabilityType" />
			<xsd:element name="ExtendedDruckerPrager" type="ExtendedDruckerPragerType" />
			<xsd:element name="FrictionlessContact" type="FrictionlessContactType" />
			<xsd:element name="HydraulicApertureTable" type="HydraulicApertureTableType" />
			<xsd:element name="JFunctionCapillaryPressure" type="JFunctionCapillaryPressureType" />
			<xsd:element name="LinearIsotropicDispersion" type="LinearIsotropicDispersionType" />
			<xsd:element name="ModifiedCamClay" type="ModifiedCamClayType" />
			<xsd:element name="MultiPhaseConstantThermalConductivity" type="MultiPhaseConstantThermalConductivityType" />
			<xsd:element name="MultiPhaseVolumeWeightedThermalConductivity" type="MultiPhaseVolumeWeightedThermalConductivityType" />
			<xsd:element name="NullModel" type="NullModelType" />
			<xsd:element name="ParallelPlatesPermeability" type="ParallelPlatesPermeabilityType" />
			<xsd:element name="ParticleFluid" type="ParticleFluidType" />
			<xsd:element name="PerfectlyPlastic" type="PerfectlyPlasticType" />
			<xsd:element name="PorousDamageElasticIsotropic" type="PorousDamageElasticIsotropicType" />
			<xsd:element name="PorousDamageSpectralElasticIsotropic" type="PorousDamageSpectralElasticIsotropicType" />
			<xsd:element name="PorousDamageVolDevElasticIsotropic" type="PorousDamageVolDevElasticIsotropicType" />
			<xsd:element name="PorousDelftEgg" type="PorousDelftEggType" />
			<xsd:element name="PorousDruckerPrager" type="PorousDruckerPragerType" />
			<xsd:element name="PorousElasticIsotropic" type="PorousElasticIsotropicType" />
			<xsd:element name="PorousElasticOrthotropic" type="PorousElasticOrthotropicType" />
			<xsd:element name="PorousElasticTransverseIsotropic" type="PorousElasticTransverseIsotropicType" />
			<xsd:element name="PorousExtendedDruckerPrager" type="PorousExtendedDruckerPragerType" />
			<xsd:element name="PorousModifiedCamClay" type="PorousModifiedCamClayType" />
			<xsd:element name="PorousViscoDruckerPrager" type="PorousViscoDruckerPragerType" />
			<xsd:element name="PorousViscoExtendedDruckerPrager" type="PorousViscoExtendedDruckerPragerType" />
			<xsd:element name="PorousViscoModifiedCamClay" type="PorousViscoModifiedCamClayType" />
			<xsd:element name="PressurePermeability" type="PressurePermeabilityType" />
			<xsd:element name="PressurePorosity" type="PressurePorosityType" />
			<xsd:element name="ProppantPermeability" type="ProppantPermeabilityType" />
			<xsd:element name="ProppantPorosity" type="ProppantPorosityType" />
			<xsd:element name="ProppantSlurryFluid" type="ProppantSlurryFluidType" />
			<xsd:element name="ProppantSolidProppantPermeability" type="ProppantSolidProppantPermeabilityType" />
			<xsd:element name="ReactiveBrine" type="ReactiveBrineType" />
			<xsd:element name="ReactiveBrineThermal" type="ReactiveBrineThermalType" />
			<xsd:element name="SinglePhaseThermalConductivity" type="SinglePhaseThermalConductivityType" />
			<xsd:element name="SlipDependentPermeability" type="SlipDependentPermeabilityType" />
			<xsd:element name="SolidInternalEnergy" type="SolidInternalEnergyType" />
			<xsd:element name="TableCapillaryPressure" type="TableCapillaryPressureType" />
			<xsd:element name="TableRelativePermeability" type="TableRelativePermeabilityType" />
			<xsd:element name="TableRelativePermeabilityHysteresis" type="TableRelativePermeabilityHysteresisType" />
			<xsd:element name="ThermalCompressibleSinglePhaseFluid" type="ThermalCompressibleSinglePhaseFluidType" />
			<xsd:element name="VanGenuchtenBakerRelativePermeability" type="VanGenuchtenBakerRelativePermeabilityType" />
			<xsd:element name="VanGenuchtenCapillaryPressure" type="VanGenuchtenCapillaryPressureType" />
			<xsd:element name="VanGenuchtenStone2RelativePermeability" type="VanGenuchtenStone2RelativePermeabilityType" />
			<xsd:element name="ViscoDruckerPrager" type="ViscoDruckerPragerType" />
			<xsd:element name="ViscoExtendedDruckerPrager" type="ViscoExtendedDruckerPragerType" />
			<xsd:element name="ViscoModifiedCamClay" type="ViscoModifiedCamClayType" />
			<xsd:element name="WillisRichardsPermeability" type="WillisRichardsPermeabilityType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="BiotPorosityType">
		<!--defaultGrainBulkModulus => Grain bulk modulus-->
		<xsd:attribute name="defaultGrainBulkModulus" type="real64" use="required" />
		<!--defaultPorosityTEC => Default thermal expansion coefficient-->
		<xsd:attribute name="defaultPorosityTEC" type="real64" default="0" />
		<!--defaultReferencePorosity => Default value of the reference porosity-->
		<xsd:attribute name="defaultReferencePorosity" type="real64" use="required" />
		<!--useUniaxialFixedStress => Flag enabling uniaxial approximation in fixed stress update-->
		<xsd:attribute name="useUniaxialFixedStress" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="BlackOilFluidType">
		<!--checkPVTTablesRanges => Enable (1) or disable (0) an error when the input pressure or temperature of the PVT tables is out of range.-->
		<xsd:attribute name="checkPVTTablesRanges" type="integer" default="1" />
		<!--componentMolarWeight => Component molar weights-->
		<xsd:attribute name="componentMolarWeight" type="real64_array" use="required" />
		<!--componentNames => List of component names-->
		<xsd:attribute name="componentNames" type="string_array" default="{}" />
		<!--hydrocarbonFormationVolFactorTableNames => List of formation volume factor TableFunction names from the Functions block. 
The user must provide one TableFunction per hydrocarbon phase, in the order provided in "phaseNames". 
For instance, if "oil" is before "gas" in "phaseNames", the table order should be: oilTableName, gasTableName-->
		<xsd:attribute name="hydrocarbonFormationVolFactorTableNames" type="groupNameRef_array" default="{}" />
		<!--hydrocarbonViscosityTableNames => List of viscosity TableFunction names from the Functions block. 
The user must provide one TableFunction per hydrocarbon phase, in the order provided in "phaseNames". 
For instance, if "oil" is before "gas" in "phaseNames", the table order should be: oilTableName, gasTableName-->
		<xsd:attribute name="hydrocarbonViscosityTableNames" type="groupNameRef_array" default="{}" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" use="required" />
		<!--surfaceDensities => List of surface mass densities for each phase-->
		<xsd:attribute name="surfaceDensities" type="real64_array" use="required" />
		<!--tableFiles => List of filenames with input PVT tables (one per phase)-->
		<xsd:attribute name="tableFiles" type="path_array" default="{}" />
		<!--waterCompressibility => Water compressibility-->
		<xsd:attribute name="waterCompressibility" type="real64" default="0" />
		<!--waterFormationVolumeFactor => Water formation volume factor-->
		<xsd:attribute name="waterFormationVolumeFactor" type="real64" default="0" />
		<!--waterReferencePressure => Water reference pressure-->
		<xsd:attribute name="waterReferencePressure" type="real64" default="0" />
		<!--waterViscosity => Water viscosity-->
		<xsd:attribute name="waterViscosity" type="real64" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="BrooksCoreyBakerRelativePermeabilityType">
		<!--gasOilRelPermExponent => Rel perm power law exponent for the pair (gas phase, oil phase) at residual water saturation
The expected format is "{ gasExp, oilExp }", in that order-->
		<xsd:attribute name="gasOilRelPermExponent" type="real64_array" default="{1}" />
		<!--gasOilRelPermMaxValue => Maximum rel perm value for the pair (gas phase, oil phase) at residual water saturation
The expected format is "{ gasMax, oilMax }", in that order-->
		<xsd:attribute name="gasOilRelPermMaxValue" type="real64_array" default="{0}" />
		<!--phaseMinVolumeFraction => Minimum volume fraction value for each phase-->
		<xsd:attribute name="phaseMinVolumeFraction" type="real64_array" default="{0}" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" use="required" />
		<!--waterOilRelPermExponent => Rel perm power law exponent for the pair (water phase, oil phase) at residual gas saturation
The expected format is "{ waterExp, oilExp }", in that order-->
		<xsd:attribute name="waterOilRelPermExponent" type="real64_array" default="{1}" />
		<!--waterOilRelPermMaxValue => Maximum rel perm value for the pair (water phase, oil phase) at residual gas saturation
The expected format is "{ waterMax, oilMax }", in that order-->
		<xsd:attribute name="waterOilRelPermMaxValue" type="real64_array" default="{0}" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="BrooksCoreyCapillaryPressureType">
		<!--capPressureEpsilon => Wetting-phase saturation at which the max cap. pressure is attained; used to avoid infinite cap. pressure values for saturations close to zero-->
		<xsd:attribute name="capPressureEpsilon" type="real64" default="1e-06" />
		<!--phaseCapPressureExponentInv => Inverse of capillary power law exponent for each phase-->
		<xsd:attribute name="phaseCapPressureExponentInv" type="real64_array" default="{2}" />
		<!--phaseEntryPressure => Entry pressure value for each phase-->
		<xsd:attribute name="phaseEntryPressure" type="real64_array" default="{1}" />
		<!--phaseMinVolumeFraction => Minimum volume fraction value for each phase-->
		<xsd:attribute name="phaseMinVolumeFraction" type="real64_array" default="{0}" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="BrooksCoreyRelativePermeabilityType">
		<!--phaseMinVolumeFraction => Minimum volume fraction value for each phase-->
		<xsd:attribute name="phaseMinVolumeFraction" type="real64_array" default="{0}" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" use="required" />
		<!--phaseRelPermExponent => Minimum relative permeability power law exponent for each phase-->
		<xsd:attribute name="phaseRelPermExponent" type="real64_array" default="{1}" />
		<!--phaseRelPermMaxValue => Maximum relative permeability value for each phase-->
		<xsd:attribute name="phaseRelPermMaxValue" type="real64_array" default="{0}" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="BrooksCoreyStone2RelativePermeabilityType">
		<!--gasOilRelPermExponent => Rel perm power law exponent for the pair (gas phase, oil phase) at residual water saturation
The expected format is "{ gasExp, oilExp }", in that order-->
		<xsd:attribute name="gasOilRelPermExponent" type="real64_array" default="{1}" />
		<!--gasOilRelPermMaxValue => Maximum rel perm value for the pair (gas phase, oil phase) at residual water saturation
The expected format is "{ gasMax, oilMax }", in that order-->
		<xsd:attribute name="gasOilRelPermMaxValue" type="real64_array" default="{0}" />
		<!--phaseMinVolumeFraction => Minimum volume fraction value for each phase-->
		<xsd:attribute name="phaseMinVolumeFraction" type="real64_array" default="{0}" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" use="required" />
		<!--waterOilRelPermExponent => Rel perm power law exponent for the pair (water phase, oil phase) at residual gas saturation
The expected format is "{ waterExp, oilExp }", in that order-->
		<xsd:attribute name="waterOilRelPermExponent" type="real64_array" default="{1}" />
		<!--waterOilRelPermMaxValue => Maximum rel perm value for the pair (water phase, oil phase) at residual gas saturation
The expected format is "{ waterMax, oilMax }", in that order-->
		<xsd:attribute name="waterOilRelPermMaxValue" type="real64_array" default="{0}" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CO2BrineEzrokhiFluidType">
		<!--checkPVTTablesRanges => Enable (1) or disable (0) an error when the input pressure or temperature of the PVT tables is out of range.-->
		<xsd:attribute name="checkPVTTablesRanges" type="integer" default="1" />
		<!--componentMolarWeight => Component molar weights-->
		<xsd:attribute name="componentMolarWeight" type="real64_array" default="{0}" />
		<!--componentNames => List of component names-->
		<xsd:attribute name="componentNames" type="string_array" default="{}" />
		<!--flashModelParaFile => Name of the file defining the parameters of the flash model-->
		<xsd:attribute name="flashModelParaFile" type="path" default="" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" default="{}" />
		<!--phasePVTParaFiles => Names of the files defining the parameters of the viscosity and density models-->
		<xsd:attribute name="phasePVTParaFiles" type="path_array" use="required" />
		<!--solubilityTableNames => Names of solubility tables for each phase-->
		<xsd:attribute name="solubilityTableNames" type="string_array" default="{}" />
		<!--writeCSV => Write PVT tables into a CSV file-->
		<xsd:attribute name="writeCSV" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CO2BrineEzrokhiThermalFluidType">
		<!--checkPVTTablesRanges => Enable (1) or disable (0) an error when the input pressure or temperature of the PVT tables is out of range.-->
		<xsd:attribute name="checkPVTTablesRanges" type="integer" default="1" />
		<!--componentMolarWeight => Component molar weights-->
		<xsd:attribute name="componentMolarWeight" type="real64_array" default="{0}" />
		<!--componentNames => List of component names-->
		<xsd:attribute name="componentNames" type="string_array" default="{}" />
		<!--flashModelParaFile => Name of the file defining the parameters of the flash model-->
		<xsd:attribute name="flashModelParaFile" type="path" default="" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" default="{}" />
		<!--phasePVTParaFiles => Names of the files defining the parameters of the viscosity and density models-->
		<xsd:attribute name="phasePVTParaFiles" type="path_array" use="required" />
		<!--solubilityTableNames => Names of solubility tables for each phase-->
		<xsd:attribute name="solubilityTableNames" type="string_array" default="{}" />
		<!--writeCSV => Write PVT tables into a CSV file-->
		<xsd:attribute name="writeCSV" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CO2BrinePhillipsFluidType">
		<!--checkPVTTablesRanges => Enable (1) or disable (0) an error when the input pressure or temperature of the PVT tables is out of range.-->
		<xsd:attribute name="checkPVTTablesRanges" type="integer" default="1" />
		<!--componentMolarWeight => Component molar weights-->
		<xsd:attribute name="componentMolarWeight" type="real64_array" default="{0}" />
		<!--componentNames => List of component names-->
		<xsd:attribute name="componentNames" type="string_array" default="{}" />
		<!--flashModelParaFile => Name of the file defining the parameters of the flash model-->
		<xsd:attribute name="flashModelParaFile" type="path" default="" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" default="{}" />
		<!--phasePVTParaFiles => Names of the files defining the parameters of the viscosity and density models-->
		<xsd:attribute name="phasePVTParaFiles" type="path_array" use="required" />
		<!--solubilityTableNames => Names of solubility tables for each phase-->
		<xsd:attribute name="solubilityTableNames" type="string_array" default="{}" />
		<!--writeCSV => Write PVT tables into a CSV file-->
		<xsd:attribute name="writeCSV" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CO2BrinePhillipsThermalFluidType">
		<!--checkPVTTablesRanges => Enable (1) or disable (0) an error when the input pressure or temperature of the PVT tables is out of range.-->
		<xsd:attribute name="checkPVTTablesRanges" type="integer" default="1" />
		<!--componentMolarWeight => Component molar weights-->
		<xsd:attribute name="componentMolarWeight" type="real64_array" default="{0}" />
		<!--componentNames => List of component names-->
		<xsd:attribute name="componentNames" type="string_array" default="{}" />
		<!--flashModelParaFile => Name of the file defining the parameters of the flash model-->
		<xsd:attribute name="flashModelParaFile" type="path" default="" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" default="{}" />
		<!--phasePVTParaFiles => Names of the files defining the parameters of the viscosity and density models-->
		<xsd:attribute name="phasePVTParaFiles" type="path_array" use="required" />
		<!--solubilityTableNames => Names of solubility tables for each phase-->
		<xsd:attribute name="solubilityTableNames" type="string_array" default="{}" />
		<!--writeCSV => Write PVT tables into a CSV file-->
		<xsd:attribute name="writeCSV" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CarmanKozenyPermeabilityType">
		<!--anisotropy => Anisotropy factors for three permeability components.-->
		<xsd:attribute name="anisotropy" type="R1Tensor" default="{1,1,1}" />
		<!--particleDiameter => Diameter of the spherical particles.-->
		<xsd:attribute name="particleDiameter" type="real64" use="required" />
		<!--sphericity => Sphericity of the particles.-->
		<xsd:attribute name="sphericity" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CeramicDamageType">
		<!--compressiveStrength => Compressive strength-->
		<xsd:attribute name="compressiveStrength" type="real64" use="required" />
		<!--crackSpeed => Crack speed-->
		<xsd:attribute name="crackSpeed" type="real64" use="required" />
		<!--defaultBulkModulus => Default Bulk Modulus Parameter-->
		<xsd:attribute name="defaultBulkModulus" type="real64" default="-1" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultDrainedLinearTEC => Default Linear Thermal Expansion Coefficient of the Solid Rock Frame-->
		<xsd:attribute name="defaultDrainedLinearTEC" type="real64" default="0" />
		<!--defaultPoissonRatio => Default Poisson's Ratio-->
		<xsd:attribute name="defaultPoissonRatio" type="real64" default="-1" />
		<!--defaultShearModulus => Default Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulus" type="real64" default="-1" />
		<!--defaultYoungModulus => Default Young's Modulus-->
		<xsd:attribute name="defaultYoungModulus" type="real64" default="-1" />
		<!--maximumStrength => Maximum theoretical strength-->
		<xsd:attribute name="maximumStrength" type="real64" use="required" />
		<!--tensileStrength => Tensile strength-->
		<xsd:attribute name="tensileStrength" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CompositionalMultiphaseFluidType">
		<!--checkPVTTablesRanges => Enable (1) or disable (0) an error when the input pressure or temperature of the PVT tables is out of range.-->
		<xsd:attribute name="checkPVTTablesRanges" type="integer" default="1" />
		<!--componentAcentricFactor => Component acentric factors-->
		<xsd:attribute name="componentAcentricFactor" type="real64_array" use="required" />
		<!--componentBinaryCoeff => Table of binary interaction coefficients-->
		<xsd:attribute name="componentBinaryCoeff" type="real64_array2d" default="{{0}}" />
		<!--componentCriticalPressure => Component critical pressures-->
		<xsd:attribute name="componentCriticalPressure" type="real64_array" use="required" />
		<!--componentCriticalTemperature => Component critical temperatures-->
		<xsd:attribute name="componentCriticalTemperature" type="real64_array" use="required" />
		<!--componentMolarWeight => Component molar weights-->
		<xsd:attribute name="componentMolarWeight" type="real64_array" use="required" />
		<!--componentNames => List of component names-->
		<xsd:attribute name="componentNames" type="string_array" use="required" />
		<!--componentVolumeShift => Component volume shifts-->
		<xsd:attribute name="componentVolumeShift" type="real64_array" default="{0}" />
		<!--constantPhaseViscosity => Viscosity for each phase-->
		<xsd:attribute name="constantPhaseViscosity" type="real64_array" default="{0}" />
		<!--equationsOfState => List of equation of state types for each phase-->
		<xsd:attribute name="equationsOfState" type="string_array" use="required" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CompositionalTwoPhaseFluidType">
		<!--checkPVTTablesRanges => Enable (1) or disable (0) an error when the input pressure or temperature of the PVT tables is out of range.-->
		<xsd:attribute name="checkPVTTablesRanges" type="integer" default="1" />
		<!--componentAcentricFactor => Component acentric factors-->
		<xsd:attribute name="componentAcentricFactor" type="real64_array" use="required" />
		<!--componentBinaryCoeff => Table of binary interaction coefficients-->
		<xsd:attribute name="componentBinaryCoeff" type="real64_array2d" default="{{0}}" />
		<!--componentCriticalPressure => Component critical pressures-->
		<xsd:attribute name="componentCriticalPressure" type="real64_array" use="required" />
		<!--componentCriticalTemperature => Component critical temperatures-->
		<xsd:attribute name="componentCriticalTemperature" type="real64_array" use="required" />
		<!--componentCriticalVolume => Component critical volumes-->
		<xsd:attribute name="componentCriticalVolume" type="real64_array" default="{0}" />
		<!--componentMolarWeight => Component molar weights-->
		<xsd:attribute name="componentMolarWeight" type="real64_array" use="required" />
		<!--componentNames => List of component names-->
		<xsd:attribute name="componentNames" type="string_array" use="required" />
		<!--componentVolumeShift => Component volume shifts-->
		<xsd:attribute name="componentVolumeShift" type="real64_array" default="{0}" />
		<!--constantPhaseViscosity => Constant phase viscosity-->
		<xsd:attribute name="constantPhaseViscosity" type="real64_array" default="{0}" />
		<!--equationsOfState => List of equation of state types for each phase. Valid options:
* pr
* srk-->
		<xsd:attribute name="equationsOfState" type="string_array" use="required" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CompositionalTwoPhaseFluidLohrenzBrayClarkType">
		<!--checkPVTTablesRanges => Enable (1) or disable (0) an error when the input pressure or temperature of the PVT tables is out of range.-->
		<xsd:attribute name="checkPVTTablesRanges" type="integer" default="1" />
		<!--componentAcentricFactor => Component acentric factors-->
		<xsd:attribute name="componentAcentricFactor" type="real64_array" use="required" />
		<!--componentBinaryCoeff => Table of binary interaction coefficients-->
		<xsd:attribute name="componentBinaryCoeff" type="real64_array2d" default="{{0}}" />
		<!--componentCriticalPressure => Component critical pressures-->
		<xsd:attribute name="componentCriticalPressure" type="real64_array" use="required" />
		<!--componentCriticalTemperature => Component critical temperatures-->
		<xsd:attribute name="componentCriticalTemperature" type="real64_array" use="required" />
		<!--componentCriticalVolume => Component critical volumes-->
		<xsd:attribute name="componentCriticalVolume" type="real64_array" default="{0}" />
		<!--componentMolarWeight => Component molar weights-->
		<xsd:attribute name="componentMolarWeight" type="real64_array" use="required" />
		<!--componentNames => List of component names-->
		<xsd:attribute name="componentNames" type="string_array" use="required" />
		<!--componentVolumeShift => Component volume shifts-->
		<xsd:attribute name="componentVolumeShift" type="real64_array" default="{0}" />
		<!--equationsOfState => List of equation of state types for each phase. Valid options:
* pr
* srk-->
		<xsd:attribute name="equationsOfState" type="string_array" use="required" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" use="required" />
		<!--viscosityMixingRule => Viscosity mixing rule to be used for Lohrenz-Bray-Clark computation. Valid options:
* HerningZipperer
* Wilke
* Brokaw-->
		<xsd:attribute name="viscosityMixingRule" type="string" default="HerningZipperer" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CompressibleSinglePhaseFluidType">
		<!--compressibility => Fluid compressibility-->
		<xsd:attribute name="compressibility" type="real64" default="0" />
		<!--defaultDensity => Default value for density.-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultViscosity => Default value for viscosity.-->
		<xsd:attribute name="defaultViscosity" type="real64" use="required" />
		<!--densityModelType => Type of density model. Valid options:
* exponential
* linear
* quadratic-->
		<xsd:attribute name="densityModelType" type="geos_constitutive_ExponentApproximationType" default="linear" />
		<!--referenceDensity => Reference fluid density-->
		<xsd:attribute name="referenceDensity" type="real64" default="1000" />
		<!--referencePressure => Reference pressure-->
		<xsd:attribute name="referencePressure" type="real64" default="0" />
		<!--referenceViscosity => Reference fluid viscosity-->
		<xsd:attribute name="referenceViscosity" type="real64" default="0.001" />
		<!--viscosibility => Fluid viscosity exponential coefficient-->
		<xsd:attribute name="viscosibility" type="real64" default="0" />
		<!--viscosityModelType => Type of viscosity model. Valid options:
* exponential
* linear
* quadratic-->
		<xsd:attribute name="viscosityModelType" type="geos_constitutive_ExponentApproximationType" default="linear" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_constitutive_ExponentApproximationType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|exponential|linear|quadratic" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="CompressibleSolidCarmanKozenyPermeabilityType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CompressibleSolidConstantPermeabilityType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CompressibleSolidExponentialDecayPermeabilityType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CompressibleSolidParallelPlatesPermeabilityType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CompressibleSolidPressurePermeabilityType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CompressibleSolidSlipDependentPermeabilityType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CompressibleSolidWillisRichardsPermeabilityType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ConstantDiffusionType">
		<!--defaultPhaseDiffusivityMultipliers => List of phase diffusivity multipliers-->
		<xsd:attribute name="defaultPhaseDiffusivityMultipliers" type="real64_array" default="{1}" />
		<!--diffusivityComponents => xx, yy, and zz components of a diffusivity tensor [m^2/s]-->
		<xsd:attribute name="diffusivityComponents" type="real64_array" use="required" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ConstantPermeabilityType">
		<!--permeabilityComponents => xx, yy and zz components of a diagonal permeability tensor.-->
		<xsd:attribute name="permeabilityComponents" type="R1Tensor" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CoulombType">
		<!--cohesion => Cohesion-->
		<xsd:attribute name="cohesion" type="real64" use="required" />
		<!--displacementJumpThreshold => A threshold valued to determine whether a fracture is open or not.-->
		<xsd:attribute name="displacementJumpThreshold" type="real64" default="2.22045e-16" />
		<!--frictionCoefficient => Friction coefficient-->
		<xsd:attribute name="frictionCoefficient" type="real64" use="required" />
		<!--shearStiffness => Value of the shear elastic stiffness. Units of Pressure/length-->
		<xsd:attribute name="shearStiffness" type="real64" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="DamageElasticIsotropicType">
		<!--compressiveStrength => Compressive strength from the uniaxial compression test-->
		<xsd:attribute name="compressiveStrength" type="real64" default="0" />
		<!--criticalFractureEnergy => Critical fracture energy-->
		<xsd:attribute name="criticalFractureEnergy" type="real64" use="required" />
		<!--criticalStrainEnergy => Critical stress in a 1d tension test-->
		<xsd:attribute name="criticalStrainEnergy" type="real64" use="required" />
		<!--defaultBulkModulus => Default Bulk Modulus Parameter-->
		<xsd:attribute name="defaultBulkModulus" type="real64" default="-1" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultDrainedLinearTEC => Default Linear Thermal Expansion Coefficient of the Solid Rock Frame-->
		<xsd:attribute name="defaultDrainedLinearTEC" type="real64" default="0" />
		<!--defaultPoissonRatio => Default Poisson's Ratio-->
		<xsd:attribute name="defaultPoissonRatio" type="real64" default="-1" />
		<!--defaultShearModulus => Default Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulus" type="real64" default="-1" />
		<!--defaultYoungModulus => Default Young's Modulus-->
		<xsd:attribute name="defaultYoungModulus" type="real64" default="-1" />
		<!--degradationLowerLimit => The lower limit of the degradation function-->
		<xsd:attribute name="degradationLowerLimit" type="real64" default="0" />
		<!--deltaCoefficient => Coefficient in the calculation of the external driving force-->
		<xsd:attribute name="deltaCoefficient" type="real64" default="-1" />
		<!--extDrivingForceFlag => Whether to have external driving force. Can be 0 or 1-->
		<xsd:attribute name="extDrivingForceFlag" type="integer" default="0" />
		<!--lengthScale => Length scale l in the phase-field equation-->
		<xsd:attribute name="lengthScale" type="real64" use="required" />
		<!--tensileStrength => Tensile strength from the uniaxial tension test-->
		<xsd:attribute name="tensileStrength" type="real64" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="DamageSpectralElasticIsotropicType">
		<!--compressiveStrength => Compressive strength from the uniaxial compression test-->
		<xsd:attribute name="compressiveStrength" type="real64" default="0" />
		<!--criticalFractureEnergy => Critical fracture energy-->
		<xsd:attribute name="criticalFractureEnergy" type="real64" use="required" />
		<!--criticalStrainEnergy => Critical stress in a 1d tension test-->
		<xsd:attribute name="criticalStrainEnergy" type="real64" use="required" />
		<!--defaultBulkModulus => Default Bulk Modulus Parameter-->
		<xsd:attribute name="defaultBulkModulus" type="real64" default="-1" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultDrainedLinearTEC => Default Linear Thermal Expansion Coefficient of the Solid Rock Frame-->
		<xsd:attribute name="defaultDrainedLinearTEC" type="real64" default="0" />
		<!--defaultPoissonRatio => Default Poisson's Ratio-->
		<xsd:attribute name="defaultPoissonRatio" type="real64" default="-1" />
		<!--defaultShearModulus => Default Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulus" type="real64" default="-1" />
		<!--defaultYoungModulus => Default Young's Modulus-->
		<xsd:attribute name="defaultYoungModulus" type="real64" default="-1" />
		<!--degradationLowerLimit => The lower limit of the degradation function-->
		<xsd:attribute name="degradationLowerLimit" type="real64" default="0" />
		<!--deltaCoefficient => Coefficient in the calculation of the external driving force-->
		<xsd:attribute name="deltaCoefficient" type="real64" default="-1" />
		<!--extDrivingForceFlag => Whether to have external driving force. Can be 0 or 1-->
		<xsd:attribute name="extDrivingForceFlag" type="integer" default="0" />
		<!--lengthScale => Length scale l in the phase-field equation-->
		<xsd:attribute name="lengthScale" type="real64" use="required" />
		<!--tensileStrength => Tensile strength from the uniaxial tension test-->
		<xsd:attribute name="tensileStrength" type="real64" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="DamageVolDevElasticIsotropicType">
		<!--compressiveStrength => Compressive strength from the uniaxial compression test-->
		<xsd:attribute name="compressiveStrength" type="real64" default="0" />
		<!--criticalFractureEnergy => Critical fracture energy-->
		<xsd:attribute name="criticalFractureEnergy" type="real64" use="required" />
		<!--criticalStrainEnergy => Critical stress in a 1d tension test-->
		<xsd:attribute name="criticalStrainEnergy" type="real64" use="required" />
		<!--defaultBulkModulus => Default Bulk Modulus Parameter-->
		<xsd:attribute name="defaultBulkModulus" type="real64" default="-1" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultDrainedLinearTEC => Default Linear Thermal Expansion Coefficient of the Solid Rock Frame-->
		<xsd:attribute name="defaultDrainedLinearTEC" type="real64" default="0" />
		<!--defaultPoissonRatio => Default Poisson's Ratio-->
		<xsd:attribute name="defaultPoissonRatio" type="real64" default="-1" />
		<!--defaultShearModulus => Default Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulus" type="real64" default="-1" />
		<!--defaultYoungModulus => Default Young's Modulus-->
		<xsd:attribute name="defaultYoungModulus" type="real64" default="-1" />
		<!--degradationLowerLimit => The lower limit of the degradation function-->
		<xsd:attribute name="degradationLowerLimit" type="real64" default="0" />
		<!--deltaCoefficient => Coefficient in the calculation of the external driving force-->
		<xsd:attribute name="deltaCoefficient" type="real64" default="-1" />
		<!--extDrivingForceFlag => Whether to have external driving force. Can be 0 or 1-->
		<xsd:attribute name="extDrivingForceFlag" type="integer" default="0" />
		<!--lengthScale => Length scale l in the phase-field equation-->
		<xsd:attribute name="lengthScale" type="real64" use="required" />
		<!--tensileStrength => Tensile strength from the uniaxial tension test-->
		<xsd:attribute name="tensileStrength" type="real64" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="DeadOilFluidType">
		<!--checkPVTTablesRanges => Enable (1) or disable (0) an error when the input pressure or temperature of the PVT tables is out of range.-->
		<xsd:attribute name="checkPVTTablesRanges" type="integer" default="1" />
		<!--componentMolarWeight => Component molar weights-->
		<xsd:attribute name="componentMolarWeight" type="real64_array" use="required" />
		<!--componentNames => List of component names-->
		<xsd:attribute name="componentNames" type="string_array" default="{}" />
		<!--hydrocarbonFormationVolFactorTableNames => List of formation volume factor TableFunction names from the Functions block. 
The user must provide one TableFunction per hydrocarbon phase, in the order provided in "phaseNames". 
For instance, if "oil" is before "gas" in "phaseNames", the table order should be: oilTableName, gasTableName-->
		<xsd:attribute name="hydrocarbonFormationVolFactorTableNames" type="groupNameRef_array" default="{}" />
		<!--hydrocarbonViscosityTableNames => List of viscosity TableFunction names from the Functions block. 
The user must provide one TableFunction per hydrocarbon phase, in the order provided in "phaseNames". 
For instance, if "oil" is before "gas" in "phaseNames", the table order should be: oilTableName, gasTableName-->
		<xsd:attribute name="hydrocarbonViscosityTableNames" type="groupNameRef_array" default="{}" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" use="required" />
		<!--surfaceDensities => List of surface mass densities for each phase-->
		<xsd:attribute name="surfaceDensities" type="real64_array" use="required" />
		<!--tableFiles => List of filenames with input PVT tables (one per phase)-->
		<xsd:attribute name="tableFiles" type="path_array" default="{}" />
		<!--waterCompressibility => Water compressibility-->
		<xsd:attribute name="waterCompressibility" type="real64" default="0" />
		<!--waterFormationVolumeFactor => Water formation volume factor-->
		<xsd:attribute name="waterFormationVolumeFactor" type="real64" default="0" />
		<!--waterReferencePressure => Water reference pressure-->
		<xsd:attribute name="waterReferencePressure" type="real64" default="0" />
		<!--waterViscosity => Water viscosity-->
		<xsd:attribute name="waterViscosity" type="real64" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="DelftEggType">
		<!--defaultBulkModulus => Default Bulk Modulus Parameter-->
		<xsd:attribute name="defaultBulkModulus" type="real64" default="-1" />
		<!--defaultCslSlope => Slope of the critical state line-->
		<xsd:attribute name="defaultCslSlope" type="real64" default="1" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultDrainedLinearTEC => Default Linear Thermal Expansion Coefficient of the Solid Rock Frame-->
		<xsd:attribute name="defaultDrainedLinearTEC" type="real64" default="0" />
		<!--defaultPoissonRatio => Default Poisson's Ratio-->
		<xsd:attribute name="defaultPoissonRatio" type="real64" default="-1" />
		<!--defaultPreConsolidationPressure => Initial preconsolidation pressure-->
		<xsd:attribute name="defaultPreConsolidationPressure" type="real64" default="-1.5" />
		<!--defaultRecompressionIndex => Recompresion Index-->
		<xsd:attribute name="defaultRecompressionIndex" type="real64" default="0.002" />
		<!--defaultShapeParameter => Shape parameter for the yield surface-->
		<xsd:attribute name="defaultShapeParameter" type="real64" default="1" />
		<!--defaultShearModulus => Default Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulus" type="real64" default="-1" />
		<!--defaultVirginCompressionIndex => Virgin compression index-->
		<xsd:attribute name="defaultVirginCompressionIndex" type="real64" default="0.005" />
		<!--defaultYoungModulus => Default Young's Modulus-->
		<xsd:attribute name="defaultYoungModulus" type="real64" default="-1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="DruckerPragerType">
		<!--defaultBulkModulus => Default Bulk Modulus Parameter-->
		<xsd:attribute name="defaultBulkModulus" type="real64" default="-1" />
		<!--defaultCohesion => Initial cohesion-->
		<xsd:attribute name="defaultCohesion" type="real64" default="0" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultDilationAngle => Dilation angle (degrees)-->
		<xsd:attribute name="defaultDilationAngle" type="real64" default="30" />
		<!--defaultDrainedLinearTEC => Default Linear Thermal Expansion Coefficient of the Solid Rock Frame-->
		<xsd:attribute name="defaultDrainedLinearTEC" type="real64" default="0" />
		<!--defaultFrictionAngle => Friction angle (degrees)-->
		<xsd:attribute name="defaultFrictionAngle" type="real64" default="30" />
		<!--defaultHardeningRate => Cohesion hardening/softening rate-->
		<xsd:attribute name="defaultHardeningRate" type="real64" default="0" />
		<!--defaultPoissonRatio => Default Poisson's Ratio-->
		<xsd:attribute name="defaultPoissonRatio" type="real64" default="-1" />
		<!--defaultShearModulus => Default Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulus" type="real64" default="-1" />
		<!--defaultYoungModulus => Default Young's Modulus-->
		<xsd:attribute name="defaultYoungModulus" type="real64" default="-1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ElasticIsotropicType">
		<!--defaultBulkModulus => Default Bulk Modulus Parameter-->
		<xsd:attribute name="defaultBulkModulus" type="real64" default="-1" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultDrainedLinearTEC => Default Linear Thermal Expansion Coefficient of the Solid Rock Frame-->
		<xsd:attribute name="defaultDrainedLinearTEC" type="real64" default="0" />
		<!--defaultPoissonRatio => Default Poisson's Ratio-->
		<xsd:attribute name="defaultPoissonRatio" type="real64" default="-1" />
		<!--defaultShearModulus => Default Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulus" type="real64" default="-1" />
		<!--defaultYoungModulus => Default Young's Modulus-->
		<xsd:attribute name="defaultYoungModulus" type="real64" default="-1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ElasticIsotropicPressureDependentType">
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultDrainedLinearTEC => Default Linear Thermal Expansion Coefficient of the Solid Rock Frame-->
		<xsd:attribute name="defaultDrainedLinearTEC" type="real64" default="0" />
		<!--defaultRecompressionIndex => Recompresion Index-->
		<xsd:attribute name="defaultRecompressionIndex" type="real64" default="0.002" />
		<!--defaultRefPressure => Reference Pressure-->
		<xsd:attribute name="defaultRefPressure" type="real64" default="-1" />
		<!--defaultRefStrainVol => Reference Volumetric Strain-->
		<xsd:attribute name="defaultRefStrainVol" type="real64" default="0" />
		<!--defaultShearModulus => Elastic Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulus" type="real64" default="-1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ElasticOrthotropicType">
		<!--defaultC11 => Default C11 Component of Voigt Stiffness Tensor-->
		<xsd:attribute name="defaultC11" type="real64" default="-1" />
		<!--defaultC12 => Default C12 Component of Voigt Stiffness Tensor-->
		<xsd:attribute name="defaultC12" type="real64" default="-1" />
		<!--defaultC13 => Default C13 Component of Voigt Stiffness Tensor-->
		<xsd:attribute name="defaultC13" type="real64" default="-1" />
		<!--defaultC22 => Default C22 Component of Voigt Stiffness Tensor-->
		<xsd:attribute name="defaultC22" type="real64" default="-1" />
		<!--defaultC23 => Default C23 Component of Voigt Stiffness Tensor-->
		<xsd:attribute name="defaultC23" type="real64" default="-1" />
		<!--defaultC33 => Default C33 Component of Voigt Stiffness Tensor-->
		<xsd:attribute name="defaultC33" type="real64" default="-1" />
		<!--defaultC44 => Default C44 Component of Voigt Stiffness Tensor-->
		<xsd:attribute name="defaultC44" type="real64" default="-1" />
		<!--defaultC55 => Default C55 Component of Voigt Stiffness Tensor-->
		<xsd:attribute name="defaultC55" type="real64" default="-1" />
		<!--defaultC66 => Default C66 Component of Voigt Stiffness Tensor-->
		<xsd:attribute name="defaultC66" type="real64" default="-1" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultDrainedLinearTEC => Default Linear Thermal Expansion Coefficient of the Solid Rock Frame-->
		<xsd:attribute name="defaultDrainedLinearTEC" type="real64" default="0" />
		<!--defaultE1 => Default Young's Modulus E1-->
		<xsd:attribute name="defaultE1" type="real64" default="-1" />
		<!--defaultE2 => Default Young's Modulus E2-->
		<xsd:attribute name="defaultE2" type="real64" default="-1" />
		<!--defaultE3 => Default Young's Modulus E3-->
		<xsd:attribute name="defaultE3" type="real64" default="-1" />
		<!--defaultG12 => Default Shear Modulus G12-->
		<xsd:attribute name="defaultG12" type="real64" default="-1" />
		<!--defaultG13 => Default Shear Modulus G13-->
		<xsd:attribute name="defaultG13" type="real64" default="-1" />
		<!--defaultG23 => Default Shear Modulus G23-->
		<xsd:attribute name="defaultG23" type="real64" default="-1" />
		<!--defaultNu12 => Default Poission's Ratio Nu12-->
		<xsd:attribute name="defaultNu12" type="real64" default="-1" />
		<!--defaultNu13 => Default Poission's Ratio Nu13-->
		<xsd:attribute name="defaultNu13" type="real64" default="-1" />
		<!--defaultNu23 => Default Poission's Ratio Nu23-->
		<xsd:attribute name="defaultNu23" type="real64" default="-1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ElasticTransverseIsotropicType">
		<!--defaultC11 => Default Stiffness Parameter C11-->
		<xsd:attribute name="defaultC11" type="real64" default="-1" />
		<!--defaultC13 => Default Stiffness Parameter C13-->
		<xsd:attribute name="defaultC13" type="real64" default="-1" />
		<!--defaultC33 => Default Stiffness Parameter C33-->
		<xsd:attribute name="defaultC33" type="real64" default="-1" />
		<!--defaultC44 => Default Stiffness Parameter C44-->
		<xsd:attribute name="defaultC44" type="real64" default="-1" />
		<!--defaultC66 => Default Stiffness Parameter C66-->
		<xsd:attribute name="defaultC66" type="real64" default="-1" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultDrainedLinearTEC => Default Linear Thermal Expansion Coefficient of the Solid Rock Frame-->
		<xsd:attribute name="defaultDrainedLinearTEC" type="real64" default="0" />
		<!--defaultPoissonRatioAxialTransverse => Default Axial-Transverse Poisson's Ratio-->
		<xsd:attribute name="defaultPoissonRatioAxialTransverse" type="real64" default="-1" />
		<!--defaultPoissonRatioTransverse => Default Transverse Poisson's Ratio-->
		<xsd:attribute name="defaultPoissonRatioTransverse" type="real64" default="-1" />
		<!--defaultShearModulusAxialTransverse => Default Axial-Transverse Shear Modulus-->
		<xsd:attribute name="defaultShearModulusAxialTransverse" type="real64" default="-1" />
		<!--defaultYoungModulusAxial => Default Axial Young's Modulus-->
		<xsd:attribute name="defaultYoungModulusAxial" type="real64" default="-1" />
		<!--defaultYoungModulusTransverse => Default Transverse Young's Modulus-->
		<xsd:attribute name="defaultYoungModulusTransverse" type="real64" default="-1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ExponentialDecayPermeabilityType">
		<!--empiricalConstant => an empirical constant.-->
		<xsd:attribute name="empiricalConstant" type="real64" use="required" />
		<!--initialPermeability =>  initial permeability of the fracture.-->
		<xsd:attribute name="initialPermeability" type="R1Tensor" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ExtendedDruckerPragerType">
		<!--defaultBulkModulus => Default Bulk Modulus Parameter-->
		<xsd:attribute name="defaultBulkModulus" type="real64" default="-1" />
		<!--defaultCohesion => Initial cohesion-->
		<xsd:attribute name="defaultCohesion" type="real64" default="0" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultDilationRatio => Dilation ratio [0,1] (ratio = tan dilationAngle / tan frictionAngle)-->
		<xsd:attribute name="defaultDilationRatio" type="real64" default="1" />
		<!--defaultDrainedLinearTEC => Default Linear Thermal Expansion Coefficient of the Solid Rock Frame-->
		<xsd:attribute name="defaultDrainedLinearTEC" type="real64" default="0" />
		<!--defaultHardening => Hardening parameter (hardening rate is faster for smaller values)-->
		<xsd:attribute name="defaultHardening" type="real64" default="0" />
		<!--defaultInitialFrictionAngle => Initial friction angle (degrees)-->
		<xsd:attribute name="defaultInitialFrictionAngle" type="real64" default="30" />
		<!--defaultPoissonRatio => Default Poisson's Ratio-->
		<xsd:attribute name="defaultPoissonRatio" type="real64" default="-1" />
		<!--defaultResidualFrictionAngle => Residual friction angle (degrees)-->
		<xsd:attribute name="defaultResidualFrictionAngle" type="real64" default="30" />
		<!--defaultShearModulus => Default Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulus" type="real64" default="-1" />
		<!--defaultYoungModulus => Default Young's Modulus-->
		<xsd:attribute name="defaultYoungModulus" type="real64" default="-1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="FrictionlessContactType">
		<!--displacementJumpThreshold => A threshold valued to determine whether a fracture is open or not.-->
		<xsd:attribute name="displacementJumpThreshold" type="real64" default="2.22045e-16" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="HydraulicApertureTableType">
		<!--apertureTableName => Name of the aperture table-->
		<xsd:attribute name="apertureTableName" type="groupNameRef" use="required" />
		<!--apertureTolerance => Value to be used to avoid floating point errors in expressions involving aperture. For example in the case of dividing by the actual aperture (not the effective aperture that results from the aperture function) this value may be used to avoid the 1/0 error. Note that this value may have some physical significance in its usage, as it may be used to smooth out highly nonlinear behavior associated with 1/0 in addition to avoiding the 1/0 error.-->
		<xsd:attribute name="apertureTolerance" type="real64" default="1e-09" />
		<!--referenceAperture => Reference hydraulic aperture. It is the aperture at zero normal stress.-->
		<xsd:attribute name="referenceAperture" type="real64" default="1e-06" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="JFunctionCapillaryPressureType">
		<!--nonWettingIntermediateJFunctionTableName => J-function table (dimensionless) for the pair (non-wetting phase, intermediate phase)
Note that this input is only used for three-phase flow.
If you want to do a two-phase simulation, please use instead wettingNonWettingJFunctionTableName to specify the table names.-->
		<xsd:attribute name="nonWettingIntermediateJFunctionTableName" type="groupNameRef" default="" />
		<!--nonWettingIntermediateSurfaceTension => Surface tension [N/m] for the pair (non-wetting phase, intermediate phase)
If you have a value in [dyne/cm], divide it by 1000 to obtain the value in [N/m]
Note that this input is only used for three-phase flow.
If you want to do a two-phase simulation, please use instead wettingNonWettingSurfaceTension to specify the surface tensions.-->
		<xsd:attribute name="nonWettingIntermediateSurfaceTension" type="real64" default="0" />
		<!--permeabilityDirection => Permeability direction. Options are:
XY - use the average of the permeabilities in the x and y directions,
X - only use the permeability in the x direction,
Y - only use the permeability in the y direction,
Z - only use the permeability in the z direction.-->
		<xsd:attribute name="permeabilityDirection" type="geos_constitutive_JFunctionCapillaryPressure_PermeabilityDirection" use="required" />
		<!--permeabilityExponent => Permeability exponent-->
		<xsd:attribute name="permeabilityExponent" type="real64" default="0.5" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" use="required" />
		<!--porosityExponent => Porosity exponent-->
		<xsd:attribute name="porosityExponent" type="real64" default="0.5" />
		<!--wettingIntermediateJFunctionTableName => J-function table (dimensionless) for the pair (wetting phase, intermediate phase)
Note that this input is only used for three-phase flow.
If you want to do a two-phase simulation, please use instead wettingNonWettingJFunctionTableName to specify the table names.-->
		<xsd:attribute name="wettingIntermediateJFunctionTableName" type="groupNameRef" default="" />
		<!--wettingIntermediateSurfaceTension => Surface tension [N/m] for the pair (wetting phase, intermediate phase)
If you have a value in [dyne/cm], divide it by 1000 to obtain the value in [N/m]
Note that this input is only used for three-phase flow.
If you want to do a two-phase simulation, please use instead wettingNonWettingSurfaceTension to specify the surface tensions.-->
		<xsd:attribute name="wettingIntermediateSurfaceTension" type="real64" default="0" />
		<!--wettingNonWettingJFunctionTableName => J-function table (dimensionless) for the pair (wetting phase, non-wetting phase)
Note that this input is only used for two-phase flow.
If you want to do a three-phase simulation, please use instead wettingIntermediateJFunctionTableName and nonWettingIntermediateJFunctionTableName to specify the table names.-->
		<xsd:attribute name="wettingNonWettingJFunctionTableName" type="groupNameRef" default="" />
		<!--wettingNonWettingSurfaceTension => Surface tension [N/m] for the pair (wetting phase, non-wetting phase)
If you have a value in [dyne/cm], divide it by 1000 to obtain the value in [N/m]
Note that this input is only used for two-phase flow.
If you want to do a three-phase simulation, please use instead wettingIntermediateSurfaceTension and nonWettingIntermediateSurfaceTension to specify the surface tensions.-->
		<xsd:attribute name="wettingNonWettingSurfaceTension" type="real64" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_constitutive_JFunctionCapillaryPressure_PermeabilityDirection">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|XY|X|Y|Z" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="LinearIsotropicDispersionType">
		<!--longitudinalDispersivity => Longitudinal dispersivity [m]-->
		<xsd:attribute name="longitudinalDispersivity" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ModifiedCamClayType">
		<!--defaultCslSlope => Slope of the critical state line-->
		<xsd:attribute name="defaultCslSlope" type="real64" default="1" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultDrainedLinearTEC => Default Linear Thermal Expansion Coefficient of the Solid Rock Frame-->
		<xsd:attribute name="defaultDrainedLinearTEC" type="real64" default="0" />
		<!--defaultPreConsolidationPressure => Initial preconsolidation pressure-->
		<xsd:attribute name="defaultPreConsolidationPressure" type="real64" default="-1.5" />
		<!--defaultRecompressionIndex => Recompresion Index-->
		<xsd:attribute name="defaultRecompressionIndex" type="real64" default="0.002" />
		<!--defaultRefPressure => Reference Pressure-->
		<xsd:attribute name="defaultRefPressure" type="real64" default="-1" />
		<!--defaultRefStrainVol => Reference Volumetric Strain-->
		<xsd:attribute name="defaultRefStrainVol" type="real64" default="0" />
		<!--defaultShearModulus => Elastic Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulus" type="real64" default="-1" />
		<!--defaultVirginCompressionIndex => Virgin compression index-->
		<xsd:attribute name="defaultVirginCompressionIndex" type="real64" default="0.005" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="MultiPhaseConstantThermalConductivityType">
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" use="required" />
		<!--thermalConductivityComponents => xx, yy, and zz components of a diagonal thermal conductivity tensor [J/(s.m.K)]-->
		<xsd:attribute name="thermalConductivityComponents" type="R1Tensor" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="MultiPhaseVolumeWeightedThermalConductivityType">
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" use="required" />
		<!--phaseThermalConductivity => Phase thermal conductivity [W/(m.K)]-->
		<xsd:attribute name="phaseThermalConductivity" type="real64_array" use="required" />
		<!--rockThermalConductivityComponents => xx, yy, and zz components of a diagonal rock thermal conductivity tensor [W/(m.K)]-->
		<xsd:attribute name="rockThermalConductivityComponents" type="R1Tensor" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="NullModelType">
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ParallelPlatesPermeabilityType">
		<!--transversalPermeability => Default value of the permeability normal to the surface. If not specified the permeability is updated using the cubic law. -->
		<xsd:attribute name="transversalPermeability" type="real64" default="-1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ParticleFluidType">
		<!--collisionAlpha => Collision alpha coefficient-->
		<xsd:attribute name="collisionAlpha" type="real64" default="1.27" />
		<!--collisionBeta => Collision beta coefficient-->
		<xsd:attribute name="collisionBeta" type="real64" default="1.5" />
		<!--fluidViscosity => Fluid viscosity-->
		<xsd:attribute name="fluidViscosity" type="real64" default="0.001" />
		<!--hinderedSettlingCoefficient => Hindered settling coefficient-->
		<xsd:attribute name="hinderedSettlingCoefficient" type="real64" default="5.9" />
		<!--isCollisionalSlip => Whether the collisional component of the slip velocity is considered-->
		<xsd:attribute name="isCollisionalSlip" type="integer" default="0" />
		<!--maxProppantConcentration => Max proppant concentration-->
		<xsd:attribute name="maxProppantConcentration" type="real64" default="0.6" />
		<!--particleSettlingModel => Particle settling velocity model. Valid options:
* Stokes
* Intermediate
* Turbulence-->
		<xsd:attribute name="particleSettlingModel" type="geos_constitutive_ParticleSettlingModel" use="required" />
		<!--proppantDensity => Proppant density-->
		<xsd:attribute name="proppantDensity" type="real64" default="1400" />
		<!--proppantDiameter => Proppant diameter-->
		<xsd:attribute name="proppantDiameter" type="real64" default="0.0002" />
		<!--slipConcentration => Slip concentration-->
		<xsd:attribute name="slipConcentration" type="real64" default="0.1" />
		<!--sphericity => Sphericity-->
		<xsd:attribute name="sphericity" type="real64" default="1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_constitutive_ParticleSettlingModel">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|Stokes|Intermediate|Turbulence" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="PerfectlyPlasticType">
		<!--defaultBulkModulus => Default Bulk Modulus Parameter-->
		<xsd:attribute name="defaultBulkModulus" type="real64" default="-1" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultDrainedLinearTEC => Default Linear Thermal Expansion Coefficient of the Solid Rock Frame-->
		<xsd:attribute name="defaultDrainedLinearTEC" type="real64" default="0" />
		<!--defaultPoissonRatio => Default Poisson's Ratio-->
		<xsd:attribute name="defaultPoissonRatio" type="real64" default="-1" />
		<!--defaultShearModulus => Default Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulus" type="real64" default="-1" />
		<!--defaultYieldStress => Default yield stress-->
		<xsd:attribute name="defaultYieldStress" type="real64" default="1.79769e+308" />
		<!--defaultYoungModulus => Default Young's Modulus-->
		<xsd:attribute name="defaultYoungModulus" type="real64" default="-1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PorousDamageElasticIsotropicType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PorousDamageSpectralElasticIsotropicType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PorousDamageVolDevElasticIsotropicType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PorousDelftEggType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PorousDruckerPragerType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PorousElasticIsotropicType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PorousElasticOrthotropicType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PorousElasticTransverseIsotropicType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PorousExtendedDruckerPragerType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PorousModifiedCamClayType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PorousViscoDruckerPragerType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PorousViscoExtendedDruckerPragerType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PorousViscoModifiedCamClayType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PressurePermeabilityType">
		<!--maxPermeability => Max. permeability can be reached.-->
		<xsd:attribute name="maxPermeability" type="real64" default="1" />
		<!--pressureDependenceConstants => Pressure dependence coefficients for each permeability component.-->
		<xsd:attribute name="pressureDependenceConstants" type="R1Tensor" use="required" />
		<!--pressureModelType => Type of the pressure dependence model. -->
		<xsd:attribute name="pressureModelType" type="geos_constitutive_PressureModelType" default="Hyperbolic" />
		<!--referencePermeabilityComponents => Reference xx, yy and zz components of a diagonal permeability tensor.-->
		<xsd:attribute name="referencePermeabilityComponents" type="R1Tensor" use="required" />
		<!--referencePressure => Reference pressure for the pressure permeability model-->
		<xsd:attribute name="referencePressure" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_constitutive_PressureModelType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|Exponential|Hyperbolic" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="PressurePorosityType">
		<!--compressibility => Solid compressibility-->
		<xsd:attribute name="compressibility" type="real64" use="required" />
		<!--defaultReferencePorosity => Default value of the reference porosity-->
		<xsd:attribute name="defaultReferencePorosity" type="real64" use="required" />
		<!--referencePressure => Reference pressure for solid compressibility-->
		<xsd:attribute name="referencePressure" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ProppantPermeabilityType">
		<!--maxProppantConcentration => Maximum proppant concentration.-->
		<xsd:attribute name="maxProppantConcentration" type="real64" use="required" />
		<!--proppantDiameter => Proppant diameter.-->
		<xsd:attribute name="proppantDiameter" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ProppantPorosityType">
		<!--defaultReferencePorosity => Default value of the reference porosity-->
		<xsd:attribute name="defaultReferencePorosity" type="real64" use="required" />
		<!--maxProppantConcentration => Maximum proppant concentration -->
		<xsd:attribute name="maxProppantConcentration" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ProppantSlurryFluidType">
		<!--componentNames => List of fluid component names-->
		<xsd:attribute name="componentNames" type="string_array" default="{}" />
		<!--compressibility => Fluid compressibility-->
		<xsd:attribute name="compressibility" type="real64" default="0" />
		<!--defaultComponentDensity => Default value for the component density.-->
		<xsd:attribute name="defaultComponentDensity" type="real64_array" default="{0}" />
		<!--defaultComponentViscosity => Default value for the component viscosity.-->
		<xsd:attribute name="defaultComponentViscosity" type="real64_array" default="{0}" />
		<!--defaultCompressibility => Default value for the component compressibility.-->
		<xsd:attribute name="defaultCompressibility" type="real64_array" default="{0}" />
		<!--flowBehaviorIndex => Flow behavior index-->
		<xsd:attribute name="flowBehaviorIndex" type="real64_array" default="{0}" />
		<!--flowConsistencyIndex => Flow consistency index-->
		<xsd:attribute name="flowConsistencyIndex" type="real64_array" default="{0}" />
		<!--maxProppantConcentration => Maximum proppant concentration-->
		<xsd:attribute name="maxProppantConcentration" type="real64" default="0.6" />
		<!--referenceDensity => Reference fluid density-->
		<xsd:attribute name="referenceDensity" type="real64" default="1000" />
		<!--referencePressure => Reference pressure-->
		<xsd:attribute name="referencePressure" type="real64" default="100000" />
		<!--referenceProppantDensity => Reference proppant density-->
		<xsd:attribute name="referenceProppantDensity" type="real64" default="1400" />
		<!--referenceViscosity => Reference fluid viscosity-->
		<xsd:attribute name="referenceViscosity" type="real64" default="0.001" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ProppantSolidProppantPermeabilityType">
		<!--permeabilityModelName => Name of the permeability model.-->
		<xsd:attribute name="permeabilityModelName" type="groupNameRef" use="required" />
		<!--porosityModelName => Name of the porosity model.-->
		<xsd:attribute name="porosityModelName" type="groupNameRef" use="required" />
		<!--solidInternalEnergyModelName => Name of the solid internal energy model.-->
		<xsd:attribute name="solidInternalEnergyModelName" type="groupNameRef" default="" />
		<!--solidModelName => Name of the solid model.-->
		<xsd:attribute name="solidModelName" type="groupNameRef" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ReactiveBrineType">
		<!--checkPVTTablesRanges => Enable (1) or disable (0) an error when the input pressure or temperature of the PVT tables is out of range.-->
		<xsd:attribute name="checkPVTTablesRanges" type="integer" default="1" />
		<!--componentMolarWeight => Component molar weights-->
		<xsd:attribute name="componentMolarWeight" type="real64_array" default="{0}" />
		<!--componentNames => List of component names-->
		<xsd:attribute name="componentNames" type="string_array" default="{}" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" default="{}" />
		<!--phasePVTParaFiles => Names of the files defining the parameters of the viscosity and density models-->
		<xsd:attribute name="phasePVTParaFiles" type="path_array" use="required" />
		<!--writeCSV => Write PVT tables into a CSV file-->
		<xsd:attribute name="writeCSV" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ReactiveBrineThermalType">
		<!--checkPVTTablesRanges => Enable (1) or disable (0) an error when the input pressure or temperature of the PVT tables is out of range.-->
		<xsd:attribute name="checkPVTTablesRanges" type="integer" default="1" />
		<!--componentMolarWeight => Component molar weights-->
		<xsd:attribute name="componentMolarWeight" type="real64_array" default="{0}" />
		<!--componentNames => List of component names-->
		<xsd:attribute name="componentNames" type="string_array" default="{}" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" default="{}" />
		<!--phasePVTParaFiles => Names of the files defining the parameters of the viscosity and density models-->
		<xsd:attribute name="phasePVTParaFiles" type="path_array" use="required" />
		<!--writeCSV => Write PVT tables into a CSV file-->
		<xsd:attribute name="writeCSV" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhaseThermalConductivityType">
		<!--defaultThermalConductivityComponents => xx, yy, and zz diagonal components of the default thermal conductivity tensor [J/(s.m.K)]-->
		<xsd:attribute name="defaultThermalConductivityComponents" type="R1Tensor" use="required" />
		<!--referenceTemperature => The reference temperature at which the conductivity components are equal to the default values-->
		<xsd:attribute name="referenceTemperature" type="real64" default="0" />
		<!--thermalConductivityGradientComponents => xx, yy, and zz diagonal components of the thermal conductivity gradient tensor w.r.t. temperature [J/(s.m.K^2)]-->
		<xsd:attribute name="thermalConductivityGradientComponents" type="R1Tensor" default="{0,0,0}" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SlipDependentPermeabilityType">
		<!--initialPermeability =>  initial permeability of the fracture.-->
		<xsd:attribute name="initialPermeability" type="R1Tensor" use="required" />
		<!--maxPermMultiplier => Maximum permeability multiplier.-->
		<xsd:attribute name="maxPermMultiplier" type="real64" use="required" />
		<!--shearDispThreshold => Threshold of shear displacement.-->
		<xsd:attribute name="shearDispThreshold" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SolidInternalEnergyType">
		<!--dVolumetricHeatCapacity_dTemperature => Derivative of the solid volumetric heat capacity w.r.t. temperature [J/(m^3.K^2)]-->
		<xsd:attribute name="dVolumetricHeatCapacity_dTemperature" type="real64" default="0" />
		<!--referenceInternalEnergy => Internal energy at the reference temperature [J/kg]-->
		<xsd:attribute name="referenceInternalEnergy" type="real64" use="required" />
		<!--referenceTemperature => Reference temperature [K]-->
		<xsd:attribute name="referenceTemperature" type="real64" use="required" />
		<!--referenceVolumetricHeatCapacity => Reference solid volumetric heat capacity [J/(kg.K)]-->
		<xsd:attribute name="referenceVolumetricHeatCapacity" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="TableCapillaryPressureType">
		<!--nonWettingIntermediateCapPressureTableName => Capillary pressure table [Pa] for the pair (non-wetting phase, intermediate phase)
Note that this input is only used for three-phase flow.
If you want to do a two-phase simulation, please use instead wettingNonWettingCapPressureTableName to specify the table names-->
		<xsd:attribute name="nonWettingIntermediateCapPressureTableName" type="groupNameRef" default="" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" use="required" />
		<!--wettingIntermediateCapPressureTableName => Capillary pressure table [Pa] for the pair (wetting phase, intermediate phase)
Note that this input is only used for three-phase flow.
If you want to do a two-phase simulation, please use instead wettingNonWettingCapPressureTableName to specify the table names-->
		<xsd:attribute name="wettingIntermediateCapPressureTableName" type="groupNameRef" default="" />
		<!--wettingNonWettingCapPressureTableName => Capillary pressure table [Pa] for the pair (wetting phase, non-wetting phase)
Note that this input is only used for two-phase flow.
If you want to do a three-phase simulation, please use instead wettingIntermediateCapPressureTableName and nonWettingIntermediateCapPressureTableName to specify the table names-->
		<xsd:attribute name="wettingNonWettingCapPressureTableName" type="groupNameRef" default="" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="TableRelativePermeabilityType">
		<!--nonWettingIntermediateRelPermTableNames => List of relative permeability tables for the pair (non-wetting phase, intermediate phase)
The expected format is "{ nonWettingPhaseRelPermTableName, intermediatePhaseRelPermTableName }", in that order
Note that this input is only used for three-phase flow.
If you want to do a two-phase simulation, please use instead wettingNonWettingRelPermTableNames to specify the table names-->
		<xsd:attribute name="nonWettingIntermediateRelPermTableNames" type="groupNameRef_array" default="{}" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" use="required" />
		<!--threePhaseInterpolator => Type of Three phase interpolator.Valid options 
* BAKER
* STONEII-->
		<xsd:attribute name="threePhaseInterpolator" type="geos_constitutive_ThreePhaseInterpolator" default="BAKER" />
		<!--wettingIntermediateRelPermTableNames => List of relative permeability tables for the pair (wetting phase, intermediate phase)
The expected format is "{ wettingPhaseRelPermTableName, intermediatePhaseRelPermTableName }", in that order
Note that this input is only used for three-phase flow.
If you want to do a two-phase simulation, please use instead wettingNonWettingRelPermTableNames to specify the table names-->
		<xsd:attribute name="wettingIntermediateRelPermTableNames" type="groupNameRef_array" default="{}" />
		<!--wettingNonWettingRelPermTableNames => List of relative permeability tables for the pair (wetting phase, non-wetting phase)
The expected format is "{ wettingPhaseRelPermTableName, nonWettingPhaseRelPermTableName }", in that order
Note that this input is only used for two-phase flow.
If you want to do a three-phase simulation, please use instead wettingIntermediateRelPermTableNames and nonWettingIntermediateRelPermTableNames to specify the table names-->
		<xsd:attribute name="wettingNonWettingRelPermTableNames" type="groupNameRef_array" default="{}" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_constitutive_ThreePhaseInterpolator">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|BAKER|STONEII" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="TableRelativePermeabilityHysteresisType">
		<!--drainageNonWettingIntermediateRelPermTableNames => List of drainage relative permeability tables for the pair (non-wetting phase, intermediate phase)
The expected format is "{ nonWettingPhaseRelPermTableName, intermediatePhaseRelPermTableName }", in that order
Note that this input is only used for three-phase flow.
If you want to do a two-phase simulation, please use instead drainageWettingNonWettingRelPermTableNames to specify the table names-->
		<xsd:attribute name="drainageNonWettingIntermediateRelPermTableNames" type="groupNameRef_array" default="{}" />
		<!--drainageWettingIntermediateRelPermTableNames => List of drainage relative permeability tables for the pair (wetting phase, intermediate phase)
The expected format is "{ wettingPhaseRelPermTableName, intermediatePhaseRelPermTableName }", in that order
Note that this input is only used for three-phase flow.
If you want to do a two-phase simulation, please use instead drainageWettingNonWettingRelPermTableNames to specify the table names-->
		<xsd:attribute name="drainageWettingIntermediateRelPermTableNames" type="groupNameRef_array" default="{}" />
		<!--drainageWettingNonWettingRelPermTableNames => List of drainage relative permeability tables for the pair (wetting phase, non-wetting phase)
The expected format is "{ wettingPhaseRelPermTableName, nonWettingPhaseRelPermTableName }", in that order
Note that this input is only used for two-phase flow.
If you want to do a three-phase simulation, please use instead drainageWettingIntermediateRelPermTableNames and drainageNonWettingIntermediateRelPermTableNames to specify the table names-->
		<xsd:attribute name="drainageWettingNonWettingRelPermTableNames" type="groupNameRef_array" default="{}" />
		<!--imbibitionNonWettingRelPermTableName => Imbibition relative permeability table name for the non-wetting phase.
To neglect hysteresis on this phase, just use the same table name for the drainage and imbibition curves-->
		<xsd:attribute name="imbibitionNonWettingRelPermTableName" type="groupNameRef" default="" />
		<!--imbibitionWettingRelPermTableName => Imbibition relative permeability table name for the wetting phase.
To neglect hysteresis on this phase, just use the same table name for the drainage and imbibition curves-->
		<xsd:attribute name="imbibitionWettingRelPermTableName" type="groupNameRef" default="" />
		<!--jerauldParameterA => First parameter (modification parameter) introduced by Jerauld in the Land trapping model (see RTD documentation).-->
		<xsd:attribute name="jerauldParameterA" type="real64" default="0.1" />
		<!--jerauldParameterB => Second parameter introduced by Jerauld in the Land trapping model (see RTD documentation).-->
		<xsd:attribute name="jerauldParameterB" type="real64" default="0" />
		<!--killoughCurvatureParameter => Curvature parameter introduced by Killough for wetting-phase hysteresis (see RTD documentation).-->
		<xsd:attribute name="killoughCurvatureParameter" type="real64" default="1" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" use="required" />
		<!--threePhaseInterpolator => Type of Three phase interpolator.Valid options 
* BAKER
* STONEII-->
		<xsd:attribute name="threePhaseInterpolator" type="geos_constitutive_ThreePhaseInterpolator" default="BAKER" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ThermalCompressibleSinglePhaseFluidType">
		<!--compressibility => Fluid compressibility-->
		<xsd:attribute name="compressibility" type="real64" default="0" />
		<!--defaultDensity => Default value for density.-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultViscosity => Default value for viscosity.-->
		<xsd:attribute name="defaultViscosity" type="real64" use="required" />
		<!--densityModelType => Type of density model. Valid options:
* exponential
* linear
* quadratic-->
		<xsd:attribute name="densityModelType" type="geos_constitutive_ExponentApproximationType" default="linear" />
		<!--internalEnergyModelType => Type of internal energy model. Valid options:
* exponential
* linear
* quadratic-->
		<xsd:attribute name="internalEnergyModelType" type="geos_constitutive_ExponentApproximationType" default="linear" />
		<!--referenceDensity => Reference fluid density-->
		<xsd:attribute name="referenceDensity" type="real64" default="1000" />
		<!--referenceInternalEnergy => Reference fluid internal energy-->
		<xsd:attribute name="referenceInternalEnergy" type="real64" default="0.001" />
		<!--referencePressure => Reference pressure-->
		<xsd:attribute name="referencePressure" type="real64" default="0" />
		<!--referenceTemperature => Reference temperature-->
		<xsd:attribute name="referenceTemperature" type="real64" default="0" />
		<!--referenceViscosity => Reference fluid viscosity-->
		<xsd:attribute name="referenceViscosity" type="real64" default="0.001" />
		<!--specificHeatCapacity => Fluid heat capacity. Unit: J/kg/K-->
		<xsd:attribute name="specificHeatCapacity" type="real64" default="0" />
		<!--thermalExpansionCoeff => Fluid thermal expansion coefficient. Unit: 1/K-->
		<xsd:attribute name="thermalExpansionCoeff" type="real64" default="0" />
		<!--viscosibility => Fluid viscosity exponential coefficient-->
		<xsd:attribute name="viscosibility" type="real64" default="0" />
		<!--viscosityModelType => Type of viscosity model. Valid options:
* exponential
* linear
* quadratic-->
		<xsd:attribute name="viscosityModelType" type="geos_constitutive_ExponentApproximationType" default="linear" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="VanGenuchtenBakerRelativePermeabilityType">
		<!--gasOilRelPermExponentInv => Rel perm power law exponent inverse for the pair (gas phase, oil phase) at residual water saturation
The expected format is "{ gasExp, oilExp }", in that order-->
		<xsd:attribute name="gasOilRelPermExponentInv" type="real64_array" default="{0.5}" />
		<!--gasOilRelPermMaxValue => Maximum rel perm value for the pair (gas phase, oil phase) at residual water saturation
The expected format is "{ gasMax, oilMax }", in that order-->
		<xsd:attribute name="gasOilRelPermMaxValue" type="real64_array" default="{0}" />
		<!--phaseMinVolumeFraction => Minimum volume fraction value for each phase-->
		<xsd:attribute name="phaseMinVolumeFraction" type="real64_array" default="{0}" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" use="required" />
		<!--waterOilRelPermExponentInv => Rel perm power law exponent inverse for the pair (water phase, oil phase) at residual gas saturation
The expected format is "{ waterExp, oilExp }", in that order-->
		<xsd:attribute name="waterOilRelPermExponentInv" type="real64_array" default="{0.5}" />
		<!--waterOilRelPermMaxValue => Maximum rel perm value for the pair (water phase, oil phase) at residual gas saturation
The expected format is "{ waterMax, oilMax }", in that order-->
		<xsd:attribute name="waterOilRelPermMaxValue" type="real64_array" default="{0}" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="VanGenuchtenCapillaryPressureType">
		<!--capPressureEpsilon => Saturation at which the extremum capillary pressure is attained; used to avoid infinite capillary pressure values for saturations close to 0 and 1-->
		<xsd:attribute name="capPressureEpsilon" type="real64" default="1e-06" />
		<!--phaseCapPressureExponentInv => Inverse of capillary power law exponent for each phase-->
		<xsd:attribute name="phaseCapPressureExponentInv" type="real64_array" default="{0.5}" />
		<!--phaseCapPressureMultiplier => Entry pressure value for each phase-->
		<xsd:attribute name="phaseCapPressureMultiplier" type="real64_array" default="{1}" />
		<!--phaseMinVolumeFraction => Minimum volume fraction value for each phase-->
		<xsd:attribute name="phaseMinVolumeFraction" type="real64_array" default="{0}" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="VanGenuchtenStone2RelativePermeabilityType">
		<!--gasOilRelPermExponentInv => Rel perm power law exponent inverse for the pair (gas phase, oil phase) at residual water saturation
The expected format is "{ gasExp, oilExp }", in that order-->
		<xsd:attribute name="gasOilRelPermExponentInv" type="real64_array" default="{0.5}" />
		<!--gasOilRelPermMaxValue => Maximum rel perm value for the pair (gas phase, oil phase) at residual water saturation
The expected format is "{ gasMax, oilMax }", in that order-->
		<xsd:attribute name="gasOilRelPermMaxValue" type="real64_array" default="{0}" />
		<!--phaseMinVolumeFraction => Minimum volume fraction value for each phase-->
		<xsd:attribute name="phaseMinVolumeFraction" type="real64_array" default="{0}" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="groupNameRef_array" use="required" />
		<!--waterOilRelPermExponentInv => Rel perm power law exponent inverse for the pair (water phase, oil phase) at residual gas saturation
The expected format is "{ waterExp, oilExp }", in that order-->
		<xsd:attribute name="waterOilRelPermExponentInv" type="real64_array" default="{0.5}" />
		<!--waterOilRelPermMaxValue => Maximum rel perm value for the pair (water phase, oil phase) at residual gas saturation
The expected format is "{ waterMax, oilMax }", in that order-->
		<xsd:attribute name="waterOilRelPermMaxValue" type="real64_array" default="{0}" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ViscoDruckerPragerType">
		<!--defaultBulkModulus => Default Bulk Modulus Parameter-->
		<xsd:attribute name="defaultBulkModulus" type="real64" default="-1" />
		<!--defaultCohesion => Initial cohesion-->
		<xsd:attribute name="defaultCohesion" type="real64" default="0" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultDilationAngle => Dilation angle (degrees)-->
		<xsd:attribute name="defaultDilationAngle" type="real64" default="30" />
		<!--defaultDrainedLinearTEC => Default Linear Thermal Expansion Coefficient of the Solid Rock Frame-->
		<xsd:attribute name="defaultDrainedLinearTEC" type="real64" default="0" />
		<!--defaultFrictionAngle => Friction angle (degrees)-->
		<xsd:attribute name="defaultFrictionAngle" type="real64" default="30" />
		<!--defaultHardeningRate => Cohesion hardening/softening rate-->
		<xsd:attribute name="defaultHardeningRate" type="real64" default="0" />
		<!--defaultPoissonRatio => Default Poisson's Ratio-->
		<xsd:attribute name="defaultPoissonRatio" type="real64" default="-1" />
		<!--defaultShearModulus => Default Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulus" type="real64" default="-1" />
		<!--defaultYoungModulus => Default Young's Modulus-->
		<xsd:attribute name="defaultYoungModulus" type="real64" default="-1" />
		<!--relaxationTime => Relaxation time-->
		<xsd:attribute name="relaxationTime" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ViscoExtendedDruckerPragerType">
		<!--defaultBulkModulus => Default Bulk Modulus Parameter-->
		<xsd:attribute name="defaultBulkModulus" type="real64" default="-1" />
		<!--defaultCohesion => Initial cohesion-->
		<xsd:attribute name="defaultCohesion" type="real64" default="0" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultDilationRatio => Dilation ratio [0,1] (ratio = tan dilationAngle / tan frictionAngle)-->
		<xsd:attribute name="defaultDilationRatio" type="real64" default="1" />
		<!--defaultDrainedLinearTEC => Default Linear Thermal Expansion Coefficient of the Solid Rock Frame-->
		<xsd:attribute name="defaultDrainedLinearTEC" type="real64" default="0" />
		<!--defaultHardening => Hardening parameter (hardening rate is faster for smaller values)-->
		<xsd:attribute name="defaultHardening" type="real64" default="0" />
		<!--defaultInitialFrictionAngle => Initial friction angle (degrees)-->
		<xsd:attribute name="defaultInitialFrictionAngle" type="real64" default="30" />
		<!--defaultPoissonRatio => Default Poisson's Ratio-->
		<xsd:attribute name="defaultPoissonRatio" type="real64" default="-1" />
		<!--defaultResidualFrictionAngle => Residual friction angle (degrees)-->
		<xsd:attribute name="defaultResidualFrictionAngle" type="real64" default="30" />
		<!--defaultShearModulus => Default Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulus" type="real64" default="-1" />
		<!--defaultYoungModulus => Default Young's Modulus-->
		<xsd:attribute name="defaultYoungModulus" type="real64" default="-1" />
		<!--relaxationTime => Relaxation time-->
		<xsd:attribute name="relaxationTime" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ViscoModifiedCamClayType">
		<!--defaultCslSlope => Slope of the critical state line-->
		<xsd:attribute name="defaultCslSlope" type="real64" default="1" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultDrainedLinearTEC => Default Linear Thermal Expansion Coefficient of the Solid Rock Frame-->
		<xsd:attribute name="defaultDrainedLinearTEC" type="real64" default="0" />
		<!--defaultPreConsolidationPressure => Initial preconsolidation pressure-->
		<xsd:attribute name="defaultPreConsolidationPressure" type="real64" default="-1.5" />
		<!--defaultRecompressionIndex => Recompresion Index-->
		<xsd:attribute name="defaultRecompressionIndex" type="real64" default="0.002" />
		<!--defaultRefPressure => Reference Pressure-->
		<xsd:attribute name="defaultRefPressure" type="real64" default="-1" />
		<!--defaultRefStrainVol => Reference Volumetric Strain-->
		<xsd:attribute name="defaultRefStrainVol" type="real64" default="0" />
		<!--defaultShearModulus => Elastic Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulus" type="real64" default="-1" />
		<!--defaultVirginCompressionIndex => Virgin compression index-->
		<xsd:attribute name="defaultVirginCompressionIndex" type="real64" default="0.005" />
		<!--relaxationTime => Relaxation time-->
		<xsd:attribute name="relaxationTime" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="WillisRichardsPermeabilityType">
		<!--dilationCoefficient => Dilation coefficient (tan of dilation angle).-->
		<xsd:attribute name="dilationCoefficient" type="real64" use="required" />
		<!--maxFracAperture => Maximum fracture aperture at zero contact stress.-->
		<xsd:attribute name="maxFracAperture" type="real64" use="required" />
		<!--refClosureStress => Effective normal stress causes 90% reduction in aperture.-->
		<xsd:attribute name="refClosureStress" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ElementRegionsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="CellElementRegion" type="CellElementRegionType" />
			<xsd:element name="SurfaceElementRegion" type="SurfaceElementRegionType" />
			<xsd:element name="WellElementRegion" type="WellElementRegionType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="CellElementRegionType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded" />
		<!--cellBlocks => (no description available)-->
		<xsd:attribute name="cellBlocks" type="groupNameRef_array" use="required" />
		<!--coarseningRatio => (no description available)-->
		<xsd:attribute name="coarseningRatio" type="real64" default="0" />
		<!--materialList => List of materials present in this region-->
		<xsd:attribute name="materialList" type="groupNameRef_array" use="required" />
		<!--meshBody => Mesh body that contains this region-->
		<xsd:attribute name="meshBody" type="groupNameRef" default="" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SurfaceElementRegionType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded" />
		<!--defaultAperture => The default aperture of newly formed surface elements.-->
		<xsd:attribute name="defaultAperture" type="real64" use="required" />
		<!--faceBlock => The name of the face block in the mesh, or the embedded surface.-->
		<xsd:attribute name="faceBlock" type="groupNameRef" default="FractureSubRegion" />
		<!--materialList => List of materials present in this region-->
		<xsd:attribute name="materialList" type="groupNameRef_array" use="required" />
		<!--meshBody => Mesh body that contains this region-->
		<xsd:attribute name="meshBody" type="groupNameRef" default="" />
		<!--subRegionType => Type of surface element subregion. Valid options: {faceElement, embeddedElement}.-->
		<xsd:attribute name="subRegionType" type="geos_SurfaceElementRegion_SurfaceSubRegionType" default="faceElement" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geos_SurfaceElementRegion_SurfaceSubRegionType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|faceElement|embeddedElement" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="WellElementRegionType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded" />
		<!--materialList => List of materials present in this region-->
		<xsd:attribute name="materialList" type="groupNameRef_array" use="required" />
		<!--meshBody => Mesh body that contains this region-->
		<xsd:attribute name="meshBody" type="groupNameRef" default="" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ParticleRegionsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="ParticleRegion" type="ParticleRegionType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="ParticleRegionType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded" />
		<!--materialList => List of materials present in this region-->
		<xsd:attribute name="materialList" type="string_array" use="required" />
		<!--meshBody => Mesh body that contains this region-->
		<xsd:attribute name="meshBody" type="string" default="" />
		<!--particleBlocks => (no description available)-->
		<xsd:attribute name="particleBlocks" type="string_array" default="{}" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="IncludedType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="File" type="FileType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="FileType">
		<!--name => The relative file path.-->
		<xsd:attribute name="name" type="path" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ParametersType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Parameter" type="ParameterType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="ParameterType">
		<!--value => Input parameter definition for the preprocessor-->
		<xsd:attribute name="value" type="string" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="groupName" use="required" />
	</xsd:complexType>
	<xsd:complexType name="BenchmarksType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="crusher" type="crusherType" maxOccurs="1" />
			<xsd:element name="lassen" type="lassenType" maxOccurs="1" />
			<xsd:element name="quartz" type="quartzType" maxOccurs="1" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="crusherType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Run" type="RunType" maxOccurs="1" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="RunType">
		<!--args => Any extra command line arguments to pass to GEOSX.-->
		<xsd:attribute name="args" type="string" default="" />
		<!--autoPartition => May be 'Off' or 'On', if 'On' partitioning arguments are created automatically. Default is Off.-->
		<xsd:attribute name="autoPartition" type="string" default="" />
		<!--meshSizes => The target number of elements in the internal mesh (per-process for weak scaling, globally for strong scaling) default doesn't modify the internalMesh.-->
		<xsd:attribute name="meshSizes" type="integer_array" default="{0}" />
		<!--name => The name of this benchmark.-->
		<xsd:attribute name="name" type="string" use="required" />
		<!--nodes => The number of nodes needed to run the base benchmark, default is 1.-->
		<xsd:attribute name="nodes" type="integer" default="0" />
		<!--scaleList => The scales at which to run the problem ( scale * nodes * tasksPerNode ).-->
		<xsd:attribute name="scaleList" type="integer_array" default="{0}" />
		<!--scaling => Whether to run a scaling, and which type of scaling to run.-->
		<xsd:attribute name="scaling" type="string" default="" />
		<!--tasksPerNode => The number of tasks per node to run the benchmark with.-->
		<xsd:attribute name="tasksPerNode" type="integer" use="required" />
		<!--threadsPerTask => The number of threads per task to run the benchmark with.-->
		<xsd:attribute name="threadsPerTask" type="integer" default="0" />
		<!--timeLimit => The time limit of the benchmark.-->
		<xsd:attribute name="timeLimit" type="integer" default="0" />
	</xsd:complexType>
	<xsd:complexType name="lassenType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Run" type="RunType" maxOccurs="1" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="quartzType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Run" type="RunType" maxOccurs="1" />
		</xsd:choice>
	</xsd:complexType>
</xsd:schema>
