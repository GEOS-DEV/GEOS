/*
 * ------------------------------------------------------------------------------------------------------------
 * SPDX-License-Identifier: LGPL-2.1-only
 *
 * Copyright (c) 2018-2020 Lawrence Livermore National Security LLC
 * Copyright (c) 2018-2020 The Board of Trustees of the Leland Stanford Junior University
 * Copyright (c) 2018-2020 TotalEnergies
 * Copyright (c) 2019-     GEOSX Contributors
 * All rights reserved
 *
 * See top level LICENSE, COPYRIGHT, CONTRIBUTORS, NOTICE, and ACKNOWLEDGEMENTS files for details.
 * ------------------------------------------------------------------------------------------------------------
 */

/**
 * @file FlowProppantTransportSolver.cpp
 */

#include "FlowProppantTransportSolver.hpp"

#include "mesh/DomainPartition.hpp"
#include "fieldSpecification/FieldSpecificationManager.hpp"
#include "physicsSolvers/fluidFlow/FlowSolverBase.hpp"
#include "physicsSolvers/fluidFlow/proppantTransport/ProppantTransport.hpp"
#include "physicsSolvers/fluidFlow/SinglePhaseBase.hpp"
#include "physicsSolvers/multiphysics/HydrofractureSolver.hpp"
#include "physicsSolvers/multiphysics/SinglePhasePoromechanics.hpp"

namespace geos
{

using namespace dataRepository;
using namespace constitutive;

template<typename FlowSolver> 
struct FlowProppantTransportCatalogName
{};

template<> struct FlowProppantTransportCatalogName< HydrofractureSolver< SinglePhasePoromechanics< SinglePhaseBase > > >
{
  public:
    static string name() {return "HydroFractureProppantTransport";}
};

template<> struct FlowProppantTransportCatalogName<FlowSolverBase>
{
  public:
    static string name() {return "FlowProppantTransport";}
};

template<typename FlowSolver>
string 
FlowProppantTransportSolver< FlowSolver >::
catalogName()
{
  return FlowProppantTransportCatalogName< FlowSolver >().name();
}

template<typename FlowSolver>
FlowProppantTransportSolver<FlowSolver>::FlowProppantTransportSolver( const string & name,
                                                          Group * const parent ):
  Base( name, parent )
{}

template<typename FlowSolver>
void FlowProppantTransportSolver<FlowSolver>::preStepUpdate( real64 const & time_n,
                                                 real64 const & dt,
                                                 DomainPartition & domain )
{
  if( time_n <= 0.0 )
  {
    // We need resize composition array in fractures after they are generated by SurfaceGenerator solver
    this->forDiscretizationOnMeshTargets( domain.getMeshBodies(), [&]( string const &,
                                                                 MeshLevel & mesh,
                                                                 arrayView1d< string const > const & regionNames )
    {
      proppantTransportSolver()->resizeFractureFields( mesh, regionNames );
      // We need re-apply initial conditions to fractures after they are generated
      FieldSpecificationManager const & boundaryConditionManager = FieldSpecificationManager::getInstance();
      boundaryConditionManager.applyInitialConditions( mesh );
    } );
  }

  flowSolver()->setupSystem( domain,
                             flowSolver()->getDofManager(),
                             flowSolver()->getLocalMatrix(),
                             flowSolver()->getSystemRhs(),
                             flowSolver()->getSystemSolution() );


  flowSolver()->implicitStepSetup( time_n, dt, domain );

  proppantTransportSolver()->setupSystem( domain,
                                          proppantTransportSolver()->getDofManager(),
                                          proppantTransportSolver()->getLocalMatrix(),
                                          proppantTransportSolver()->getSystemRhs(),
                                          proppantTransportSolver()->getSystemSolution() );


  proppantTransportSolver()->implicitStepSetup( time_n, dt, domain );

  proppantTransportSolver()->preStepUpdate( time_n, dt, domain );
}

template<typename FlowSolver>
void FlowProppantTransportSolver<FlowSolver>::postStepUpdate( real64 const & time_n,
                                                  real64 const & dt,
                                                  DomainPartition & domain )
{
  flowSolver()->implicitStepComplete( time_n, dt, domain );
  proppantTransportSolver()->implicitStepComplete( time_n, dt, domain );
  proppantTransportSolver()->postStepUpdate( time_n, dt, domain );
}

template<typename FlowSolver>
real64 FlowProppantTransportSolver<FlowSolver>::sequentiallyCoupledSolverStep( real64 const & time_n,
                                                                   real64 const & dt,
                                                                   int const cycleNumber,
                                                                   DomainPartition & domain )
{
  real64 dtReturn = dt;
  real64 dtReturnTemporary;

  preStepUpdate( time_n, dt, domain );

  int iter = 0;
  while( iter < this->m_nonlinearSolverParameters.m_maxIterNewton )
  {
    if( iter == 0 )
    {
      // reset the states of all sub-solvers if any of them has been reset
      this->resetStateToBeginningOfStep( domain );
    }

    GEOS_LOG_LEVEL_RANK_0( 1, "  Iteration: " << iter+1  << ", FlowSolver: " );

    dtReturnTemporary = flowSolver()->nonlinearImplicitStep( time_n, dtReturn, cycleNumber, domain );

    if( dtReturnTemporary < dtReturn )
    {
      iter = 0;
      dtReturn = dtReturnTemporary;
      continue;
    }

    NonlinearSolverParameters const & fluidNonLinearParams = flowSolver()->getNonlinearSolverParameters();
    if( fluidNonLinearParams.m_numNewtonIterations <= this->m_nonlinearSolverParameters.m_minIterNewton && iter > 0 )
    {
      this->m_solverStatistics.logNonlinearIteration();
      GEOS_LOG_LEVEL_RANK_0( 1, GEOS_FMT( "***** The iterative coupling has converged in {} iterations *****", iter ) );
      break;
    }

    GEOS_LOG_LEVEL_RANK_0( 1, GEOS_FMT( "  Iteration: {}, Proppant Solver: ", iter+1 ) );

    dtReturnTemporary = proppantTransportSolver()->nonlinearImplicitStep( time_n, dtReturn, cycleNumber, domain );

    if( dtReturnTemporary < dtReturn )
    {
      iter = 0;
      dtReturn = dtReturnTemporary;
      continue;
    }

    ++iter;
  }

  postStepUpdate( time_n, dtReturn, domain );

  return dtReturn;
}

typedef FlowProppantTransportSolver< HydrofractureSolver< SinglePhasePoromechanics< SinglePhaseBase > > > HydrofracProppantTransportSolver;
REGISTER_CATALOG_ENTRY( SolverBase, HydrofracProppantTransportSolver, string const &, Group * const )

typedef FlowProppantTransportSolver< FlowSolverBase > SinglePhaseFlowProppantTransportSolver;
REGISTER_CATALOG_ENTRY( SolverBase, SinglePhaseFlowProppantTransportSolver, string const &, Group * const )
} /* namespace geos */
