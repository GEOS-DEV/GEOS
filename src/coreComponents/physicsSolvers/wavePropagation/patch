diff --git a/src/coreComponents/physicsSolvers/wavePropagation/ElasticWaveEquationSEM.cpp b/src/coreComponents/physicsSolvers/wavePropagation/ElasticWaveEquationSEM.cpp
index 6cb50b0d3..27b27256c 100644
--- a/src/coreComponents/physicsSolvers/wavePropagation/ElasticWaveEquationSEM.cpp
+++ b/src/coreComponents/physicsSolvers/wavePropagation/ElasticWaveEquationSEM.cpp
@@ -148,9 +148,9 @@ void ElasticWaveEquationSEM::registerDataOnMesh( Group & meshBodies )
                                elasticfields::StiffnessVectorz,
                                elasticfields::ElasticFreeSurfaceNodeIndicator >( getName() );
 
-    integer l = m_slsReferenceFrequencies.size( 0 );
-    if( l > 0 )
+    if( m_attenuationType == WaveSolverUtils::AttenuationType::sls )
     {
+      integer l = m_slsReferenceAngularFrequencies.size( 0 );
       nodeManager.registerField< elasticfields::DivPsix,
                                  elasticfields::DivPsiy,
                                  elasticfields::DivPsiz,
@@ -172,7 +172,7 @@ void ElasticWaveEquationSEM::registerDataOnMesh( Group & meshBodies )
       subRegion.registerField< elasticfields::ElasticVelocityVp >( getName() );
       subRegion.registerField< elasticfields::ElasticVelocityVs >( getName() );
       subRegion.registerField< elasticfields::ElasticDensity >( getName() );
-      if( l > 0 )
+      if( m_attenuationType == WaveSolverUtils::AttenuationType::sls )
       {
         subRegion.registerField< elasticfields::ElasticQualityFactorP >( getName() );
         subRegion.registerField< elasticfields::ElasticQualityFactorS >( getName() );
@@ -446,12 +446,53 @@ void ElasticWaveEquationSEM::initializePostInitialConditionsPreSubGroups()
                                                                              dampingz );
       } );
     } );
+
+    // check anelasticity coefficient and/or compute it if needed
+    if( m_attenuationType == WaveSolverUtils::AttenuationType::sls )
+    {
+      real32 minQVal = computeGlobalMinQFactor();
+      if ( m_slsAnelasticityCoefficients.size( 0 ) == 1 && m_slsAnelasticityCoefficients[ 0 ] < 0 )
+      {
+        m_slsAnelasticityCoefficients[ 0 ] = 2.0 * minQVal / ( minQVal - 1.0 );
+      }
+      // test if anelasticity is so high and artifacts could appear
+      real32 ySum = 0.0;
+      for( integer l = 0; l < m_slsAnelasticityCoefficients.size( 0 ); l++ )
+      {
+        ySum += m_slsAnelasticityCoefficients[ l ];
+      }
+      GEOS_WARNING_IF( ySum > minQVal, "The anelasticity parameters are too high for the given qiality factor. This could lead to solution artifacts such as zero-velocity waves." );
+    }
+
   } );
 
   WaveSolverUtils::initTrace( "seismoTraceReceiver", getName(), m_outputSeismoTrace, m_receiverConstants.size( 0 ), m_receiverIsLocal );
   WaveSolverUtils::initTrace( "dasTraceReceiver", getName(), m_outputSeismoTrace, m_linearDASGeometry.size( 0 ), m_receiverIsLocal );
 }
 
+real32 ElasticWaveEquationSEM::computeGlobalMinQFactor()
+{
+  RAJA::ReduceMin< ReducePolicy< EXEC_POLICY >, real32 > minQ( LvArray::NumericLimits< real32 >::max );
+  DomainPartition & domain = getGroupByPath< DomainPartition >( "/Problem/domain" );
+
+  forDiscretizationOnMeshTargets( domain.getMeshBodies(), [&] ( string const &,
+                                                                MeshLevel & mesh,
+                                                                arrayView1d< string const > const & regionNames )
+  {
+    mesh.getElemManager().forElementSubRegions< CellElementSubRegion >( regionNames, [&]( localIndex const,
+                                                                        CellElementSubRegion & elementSubRegion )
+    {
+      arrayView1d< real32 const > const qp = elementSubRegion.getField< elasticfields::ElasticQualityFactorP >();
+      arrayView1d< real32 const > const qs = elementSubRegion.getField< elasticfields::ElasticQualityFactorS >();
+      forAll< EXEC_POLICY >( elementSubRegion.size(), [=] GEOS_HOST_DEVICE ( localIndex const e ) {
+        minQ.min( qp[e] );
+        minQ.min( qs[e] );
+      } );
+    } );
+  } );
+  real32 minQVal = minQ.get();
+  return MpiWrapper::min< real32 >( minQVal );
+}
 
 void ElasticWaveEquationSEM::applyFreeSurfaceBC( real64 const time, DomainPartition & domain )
 {
@@ -584,7 +625,7 @@ void ElasticWaveEquationSEM::computeUnknowns( real64 const &,
   arrayView1d< real32 > const rhsy = nodeManager.getField< elasticfields::ForcingRHSy >();
   arrayView1d< real32 > const rhsz = nodeManager.getField< elasticfields::ForcingRHSz >();
 
-  if( m_slsReferenceFrequencies.size( 0 ) == 0 )
+  if( m_attenuationType == WaveSolverUtils::AttenuationType::sls )
   {
     auto kernelFactory = elasticWaveEquationSEMKernels::ExplicitElasticSEMFactory( dt ); 
     finiteElement::
@@ -612,16 +653,16 @@ void ElasticWaveEquationSEM::computeUnknowns( real64 const &,
   addSourceToRightHandSide( cycleNumber, rhsx, rhsy, rhsz );
 
   SortedArrayView< localIndex const > const solverTargetNodesSet = m_solverTargetNodesSet.toViewConst();
-  integer l = m_slsReferenceFrequencies.size( 0 );
-  if( l > 0 )
+  if( m_attenuationType == WaveSolverUtils::AttenuationType::sls )
   {
+    integer l = m_slsReferenceAngularFrequencies.size( 0 );
     arrayView1d< real32 > const stiffnessVectorAx = nodeManager.getField< elasticfields::StiffnessVectorAx >();
     arrayView1d< real32 > const stiffnessVectorAy = nodeManager.getField< elasticfields::StiffnessVectorAy >();
     arrayView1d< real32 > const stiffnessVectorAz = nodeManager.getField< elasticfields::StiffnessVectorAz >();
     arrayView2d< real32 > const divpsix = nodeManager.getField< elasticfields::DivPsix >();
     arrayView2d< real32 > const divpsiy = nodeManager.getField< elasticfields::DivPsiy >();
     arrayView2d< real32 > const divpsiz = nodeManager.getField< elasticfields::DivPsiz >();
-    arrayView1d< real32 > const referenceFrequencies = m_slsReferenceFrequencies.toView();
+    arrayView1d< real32 > const referenceFrequencies = m_slsReferenceAngularFrequencies.toView();
     arrayView1d< real32 > const anelasticityCoefficients = m_slsAnelasticityCoefficients.toView();
     ElasticTimeSchemeSEM::AttenuationLeapFrog( dt, ux_np1, ux_n, ux_nm1, uy_np1, uy_n, uy_nm1, uz_np1, uz_n, uz_nm1,
                                                divpsix, divpsiy, divpsiz,
@@ -659,7 +700,7 @@ void ElasticWaveEquationSEM::synchronizeUnknowns( real64 const & time_n,
   FieldIdentifiers fieldsToBeSync;
   fieldsToBeSync.addFields( FieldLocation::Node, { elasticfields::Displacementx_np1::key(), elasticfields::Displacementy_np1::key(), elasticfields::Displacementz_np1::key() } );
 
-  if( m_slsReferenceFrequencies.size( 0 ) > 0 )
+  if( m_slsReferenceAngularFrequencies.size( 0 ) > 0 )
   {
     fieldsToBeSync.addFields( FieldLocation::Node, { elasticfields::DivPsix::key(), elasticfields::DivPsiy::key(), elasticfields::DivPsiz::key() } );
   }
@@ -728,7 +769,7 @@ void ElasticWaveEquationSEM::prepareNextTimestep( MeshLevel & mesh )
     stiffnessVectorx[a] = stiffnessVectory[a] = stiffnessVectorz[a] = 0.0;
     rhsx[a] = rhsy[a] = rhsz[a] = 0.0;
   } );
-  if( m_slsReferenceFrequencies.size( 0 ) > 0 )
+  if( m_attenuationType == WaveSolverUtils::AttenuationType::sls )
   {
     arrayView1d< real32 > const stiffnessVectorAx = nodeManager.getField< elasticfields::StiffnessVectorAx >();
     arrayView1d< real32 > const stiffnessVectorAy = nodeManager.getField< elasticfields::StiffnessVectorAy >();
diff --git a/src/coreComponents/physicsSolvers/wavePropagation/ElasticWaveEquationSEM.hpp b/src/coreComponents/physicsSolvers/wavePropagation/ElasticWaveEquationSEM.hpp
index 74d58e3cf..3ac14d1da 100644
--- a/src/coreComponents/physicsSolvers/wavePropagation/ElasticWaveEquationSEM.hpp
+++ b/src/coreComponents/physicsSolvers/wavePropagation/ElasticWaveEquationSEM.hpp
@@ -152,6 +152,12 @@ public:
                             arrayView1d< string const > const & regionNames );
 
   void prepareNextTimestep( MeshLevel & mesh );
+
+ /**
+ * @brief Computes the minimum attenuation quality factor over all the mesh. This is useful for computing anelasticity coefficients, which are usually global parameters
+ */
+  real32 computeGlobalMinQFactor();
+
 protected:
 
   virtual void postProcessInput() override final;
diff --git a/src/coreComponents/physicsSolvers/wavePropagation/WaveSolverBase.cpp b/src/coreComponents/physicsSolvers/wavePropagation/WaveSolverBase.cpp
index 16ba95d29..658194ebe 100644
--- a/src/coreComponents/physicsSolvers/wavePropagation/WaveSolverBase.cpp
+++ b/src/coreComponents/physicsSolvers/wavePropagation/WaveSolverBase.cpp
@@ -130,7 +130,7 @@ WaveSolverBase::WaveSolverBase( const std::string & name,
   registerWrapper( viewKeyStruct::useDASString(), &m_useDAS ).
     setInputFlag( InputFlags::OPTIONAL ).
     setApplyDefaultValue( WaveSolverUtils::DASType::none ).
-    setDescription( "Flag to indicate if DAS data will be modeled, and which DAS type to use: 1 for strain integration, 2 for displacement difference" );
+    setDescription( "Flag to indicate if DAS data will be modeled, and which DAS type to use: \"none\" to deactivate DAS, \"strainIntegration\" for strain integration, \"dipole\" for displacement difference" );
 
   registerWrapper( viewKeyStruct::linearDASSamplesString(), &m_linearDASSamples ).
     setInputFlag( InputFlags::OPTIONAL ).
@@ -197,11 +197,11 @@ WaveSolverBase::WaveSolverBase( const std::string & name,
     setSizedFromParent( 0 ).
     setDescription( "Element containing the receivers" );
 
-  registerWrapper( viewKeyStruct::slsReferenceFrequenciesString(), &m_slsReferenceFrequencies ).
+  registerWrapper( viewKeyStruct::slsReferenceAngularFrequenciesString(), &m_slsReferenceAngularFrequencies ).
     setInputFlag( InputFlags::OPTIONAL ).
     setSizedFromParent( 0 ).
     setApplyDefaultValue( { } ).
-    setDescription( "Reference frequencies for the standard-linear-solid (SLS) anelasticity."
+    setDescription( "Reference angular frequencies (omega) for the standard-linear-solid (SLS) anelasticity."
                     "The default value is { }, corresponding to no attenuation. An array with the corresponding anelasticity coefficients must be provided." );
 
   registerWrapper( viewKeyStruct::slsAnelasticityCoefficientsString(), &m_slsAnelasticityCoefficients ).
@@ -210,6 +210,12 @@ WaveSolverBase::WaveSolverBase( const std::string & name,
     setApplyDefaultValue( { } ).
     setDescription( "Anelasticity coefficients for the standard-linear-solid (SLS) anelasticity."
                     "The default value is { }, corresponding to no attenuation. An array with the corresponding reference frequencies must be provided." );
+
+  registerWrapper( viewKeyStruct::useDASString(), &m_attenuationType ).
+    setInputFlag( InputFlags::OPTIONAL ).
+    setApplyDefaultValue( WaveSolverUtils::AttenuationType::none ).
+    setDescription( "Flag to indicate which attenuation model to use: \"none\" for no attenuation, \"sls\\"" for the standard-linear-solid (SLS) model (Fichtner, 2014)." );
+
 }
 
 WaveSolverBase::~WaveSolverBase()
@@ -323,6 +329,22 @@ void WaveSolverBase::postProcessInput()
     }
   }
 
+  if( m_attenuationType == WaveSolverUtils::AttenuationType::sls )
+  {
+    GEOS_THROW_IF( m_slsReferenceAngularFrequencies.size( 0 ) != m_slsAnelasticityCoefficients.size( 0 ),
+                   "The number of attenuation anelasticity coefficients for the SLS model must be equal to the number of reference angular frequencies",
+                   InputError );
+    if( m_slsReferenceAngularFrequencies.size( 0 ) == 0 || m_slsAnelasticityCoefficients.size( 0 ) == 0 )
+    {
+       m_slsReferenceAngularFrequencies.resize( 1 );
+       m_slsReferenceAngularFrequencies[ 0 ] = 2.0 * M_PI * m_timeSourceFrequency;
+       m_slsAnelasticityCoefficients.resize( 1 );
+       // set the coefficient to a negative value, so that it will be recomputed when the quality factor is available
+       m_slsAnelasticityCoefficients[ 0 ] = -1;
+    }
+  }
+
+
   GEOS_THROW_IF( m_sourceCoordinates.size( 0 ) > 0 && m_sourceCoordinates.size( 1 ) != 3,
                  "Invalid number of physical coordinates for the sources",
                  InputError );
@@ -331,11 +353,6 @@ void WaveSolverBase::postProcessInput()
                  "Invalid number of physical coordinates for the receivers",
                  InputError );
 
-  
-  GEOS_THROW_IF( m_slsReferenceFrequencies.size( 0 ) != m_slsAnelasticityCoefficients.size( 0 ),
-                 "The number of attenuation anelasticity coefficients must be equal to the bumber of reference frequencies",
-                 InputError );
-
   EventManager const & event = getGroupByPath< EventManager >( "/Problem/Events" );
   real64 const & maxTime = event.getReference< real64 >( EventManager::viewKeyStruct::maxTimeString() );
   real64 const & minTime = event.getReference< real64 >( EventManager::viewKeyStruct::minTimeString() );
diff --git a/src/coreComponents/physicsSolvers/wavePropagation/WaveSolverBase.hpp b/src/coreComponents/physicsSolvers/wavePropagation/WaveSolverBase.hpp
index 22bae87e3..34a9c2ec1 100644
--- a/src/coreComponents/physicsSolvers/wavePropagation/WaveSolverBase.hpp
+++ b/src/coreComponents/physicsSolvers/wavePropagation/WaveSolverBase.hpp
@@ -122,7 +122,7 @@ public:
     static constexpr char const * receiverRegionString() { return "receiverRegion"; }
     static constexpr char const * freeSurfaceString() { return "FreeSurface"; }
 
-    static constexpr char const * slsReferenceFrequenciesString() { return "attenuationReferenceFrequencies"; }
+    static constexpr char const * slsReferenceAngularFrequenciesString() { return "attenuationReferenceFrequencies"; }
     static constexpr char const * slsAnelasticityCoefficientsString() { return "attenuationAnelasticityCoefficients"; }
   };
  
@@ -273,7 +273,7 @@ protected:
   /// Amount of seismoTrace that will be recorded for each receiver
   localIndex m_nsamplesSeismoTrace;
 
-  /// Flag to indicate which DAS type  will be modeled
+  /// Flag to indicate which DAS type will be modeled
   WaveSolverUtils::DASType m_useDAS;
 
   /// Number of points used for strain integration for dipole DAS
@@ -291,8 +291,11 @@ protected:
   /// Z component of the linear DAS direction vector
   array1d< real32 > m_linearDASVectorZ;
 
+  /// Flag to indicate which attenuation type will be modeled
+  WaveSolverUtils::AttenuationType m_attenuationType;
+
   /// Vector containing the reference frequencies for the standard-linear-solid (SLS) anelasticity model.
-  array1d< real32 > m_slsReferenceFrequencies;
+  array1d< real32 > m_slsReferenceAngularFrequencies;
 
   /// Vector containing the anelasticity coefficients for the standard-linear-solid (SLS) anelasticity model.
   array1d< real32 > m_slsAnelasticityCoefficients;
diff --git a/src/coreComponents/physicsSolvers/wavePropagation/WaveSolverUtils.hpp b/src/coreComponents/physicsSolvers/wavePropagation/WaveSolverUtils.hpp
index 5b9e91dbc..ae1634a7c 100644
--- a/src/coreComponents/physicsSolvers/wavePropagation/WaveSolverUtils.hpp
+++ b/src/coreComponents/physicsSolvers/wavePropagation/WaveSolverUtils.hpp
@@ -41,6 +41,13 @@ struct WaveSolverUtils
     strainIntegration,  ///< use strain integration for DAS
   };
 
+  enum class AttenuationType : integer
+  {
+    none,               ///< deactivate attenuation (default)
+    sls,                ///< istandard-linear-solid description [Fichtner 2014]
+  };
+
+
   GEOS_HOST_DEVICE
   static real32 evaluateRicker( real64 const time_n, real32 const f0, real32 const t0, localIndex const order )
   {
@@ -371,6 +378,10 @@ ENUM_STRINGS( WaveSolverUtils::DASType,
               "dipole",
               "strainIntegration" );
 
+ENUM_STRINGS( WaveSolverUtils::AttenuationType,
+              "none",
+              "sls" );
+
 } /* namespace geos */
 
 #endif /* GEOS_PHYSICSSOLVERS_WAVEPROPAGATION_WAVESOLVERUTILS_HPP_ */

