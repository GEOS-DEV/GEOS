<?xml version="1.0"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
	<xsd:annotation>
		<xsd:documentation xml:lang="en">GEOSX Input Schema</xsd:documentation>
	</xsd:annotation>
	<xsd:simpleType name="string">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[a-zA-Z0-9_,\(\)+-/\*]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real32_array3d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[a-zA-Z0-9_,\(\)+-/\* \n]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="globalIndex_array3d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[a-zA-Z0-9_,\(\)+-/\* \n]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real64_array3d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[a-zA-Z0-9_,\(\)+-/\* \n]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="r2_array2d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[a-zA-Z0-9_,\(\)+-/\* \n]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="mapPair_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="(([a-zA-Z0-9_,\(\)+-/\*]*,? )*)?[a-zA-Z0-9_,\(\)+-/\*]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="integer_array3d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[a-zA-Z0-9_,\(\)+-/\* \n]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="r1_array2d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[a-zA-Z0-9_,\(\)+-/\* \n]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="string_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="(([a-zA-Z0-9_,\(\)+-/\*]*,? )*)?[a-zA-Z0-9_,\(\)+-/\*]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="localIndex_array3d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[a-zA-Z0-9_,\(\)+-/\* \n]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real64_array2d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[a-zA-Z0-9_,\(\)+-/\* \n]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="mapPair">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[a-zA-Z0-9_,\(\)+-/\*]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real32_array2d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[a-zA-Z0-9_,\(\)+-/\* \n]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="r2Sym_array2d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[a-zA-Z0-9_,\(\)+-/\* \n]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="globalIndex_array2d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[a-zA-Z0-9_,\(\)+-/\* \n]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="localIndex_array2d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[a-zA-Z0-9_,\(\)+-/\* \n]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="integer_array2d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[a-zA-Z0-9_,\(\)+-/\* \n]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="r2Sym_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="(([+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?; )*)?[+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="r1_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="(([+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?; )*)?[+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real32_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="(([+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? )*)?[+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="r2_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="(([+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?; )*)?[+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="globalIndex_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="(([+-]?[0-9]*,? )*)?[+-]?[0-9]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real64_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="(([+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? )*)?[+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="localIndex_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="(([+-]?[0-9]*,? )*)?[+-]?[0-9]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="integer_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="(([+-]?[0-9]*,? )*)?[+-]?[0-9]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="R2SymTensor">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="R2Tensor">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real64">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="R1Tensor">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?,? [+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="globalIndex">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[+-]?[0-9]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="localIndex">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[+-]?[0-9]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real32">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[+-]?[0-9]*\.?([0-9]*)?[eE]?[-+]?([0-9]*)?" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="integer">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[+-]?[0-9]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:element name="Problem" type="ProblemType" />
	<xsd:complexType name="ProblemType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Events" type="EventsType" minOccurs="1" maxOccurs="1" />
			<xsd:element name="FieldSpecifications" type="FieldSpecificationsType" maxOccurs="1" />
			<xsd:element name="Functions" type="FunctionsType" maxOccurs="1" />
			<xsd:element name="Geometry" type="GeometryType" maxOccurs="1" />
			<xsd:element name="Mesh" type="MeshType" minOccurs="1" maxOccurs="1" />
			<xsd:element name="NumericalMethods" type="NumericalMethodsType" maxOccurs="1" />
			<xsd:element name="Outputs" type="OutputsType" minOccurs="1" maxOccurs="1" />
			<xsd:element name="Solvers" type="SolversType" minOccurs="1" maxOccurs="1" />
			<xsd:element name="Constitutive" type="ConstitutiveType" maxOccurs="1" />
			<xsd:element name="ElementRegions" type="ElementRegionsType" maxOccurs="1" />
			<xsd:element name="Included" type="IncludedType" maxOccurs="1" />
			<xsd:element name="Parameters" type="ParametersType" maxOccurs="1" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="EventsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="HaltEvent" type="HaltEventType" />
			<xsd:element name="PeriodicEvent" type="PeriodicEventType" />
			<xsd:element name="SoloEvent" type="SoloEventType" />
		</xsd:choice>
		<!--maxTime => Maximum simulation time.-->
		<xsd:attribute name="maxTime" type="real64" default="-1" />
		<!--maxCycle => Maximum simulation cycle.-->
		<xsd:attribute name="maxCycle" type="integer" default="-1" />
		<!--verbosity => Maximum simulation time.-->
		<xsd:attribute name="verbosity" type="integer" default="0" />
	</xsd:complexType>
	<xsd:complexType name="HaltEventType" />
	<xsd:complexType name="PeriodicEventType" />
	<xsd:complexType name="SoloEventType" />
	<xsd:complexType name="FieldSpecificationsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Dirichlet" type="DirichletType" />
			<xsd:element name="FieldSpecification" type="FieldSpecificationType" />
			<xsd:element name="SourceFlux" type="SourceFluxType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="DirichletType" />
	<xsd:complexType name="FieldSpecificationType" />
	<xsd:complexType name="SourceFluxType" />
	<xsd:complexType name="FunctionsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="CompositeFunction" type="CompositeFunctionType" />
			<xsd:element name="SymbolicFunction" type="SymbolicFunctionType" />
			<xsd:element name="TableFunction" type="TableFunctionType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="CompositeFunctionType" />
	<xsd:complexType name="SymbolicFunctionType" />
	<xsd:complexType name="TableFunctionType" />
	<xsd:complexType name="GeometryType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Box" type="BoxType" />
			<xsd:element name="ThickPlane" type="ThickPlaneType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="BoxType" />
	<xsd:complexType name="ThickPlaneType" />
	<xsd:complexType name="MeshType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="InternalMesh" type="InternalMeshType" />
			<xsd:element name="MeshFile" type="MeshFileType" />
			<xsd:element name="PAMELAMeshGenerator" type="PAMELAMeshGeneratorType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="InternalMeshType" />
	<xsd:complexType name="MeshFileType" />
	<xsd:complexType name="PAMELAMeshGeneratorType" />
	<xsd:complexType name="NumericalMethodsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="BasisFunctions" type="BasisFunctionsType" maxOccurs="1" />
			<xsd:element name="FiniteElements" type="FiniteElementsType" maxOccurs="1" />
			<xsd:element name="FiniteVolume" type="FiniteVolumeType" maxOccurs="1" />
			<xsd:element name="QuadratureRules" type="QuadratureRulesType" maxOccurs="1" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="BasisFunctionsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LagrangeBasis1" type="LagrangeBasis1Type" />
			<xsd:element name="LagrangeBasis2" type="LagrangeBasis2Type" />
			<xsd:element name="LagrangeBasis3" type="LagrangeBasis3Type" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="LagrangeBasis1Type" />
	<xsd:complexType name="LagrangeBasis2Type" />
	<xsd:complexType name="LagrangeBasis3Type" />
	<xsd:complexType name="FiniteElementsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="FiniteElementSpace" type="FiniteElementSpaceType" />
			<xsd:element name="SystemSolverParameters" type="SystemSolverParametersType" maxOccurs="1" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="FiniteElementSpaceType" />
	<xsd:complexType name="SystemSolverParametersType" />
	<xsd:complexType name="FiniteVolumeType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="TwoPointFluxApproximation" type="TwoPointFluxApproximationType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="TwoPointFluxApproximationType" />
	<xsd:complexType name="QuadratureRulesType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="GaussQuadrature1" type="GaussQuadrature1Type" />
			<xsd:element name="GaussQuadrature2" type="GaussQuadrature2Type" />
			<xsd:element name="GaussQuadrature3" type="GaussQuadrature3Type" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="GaussQuadrature1Type" />
	<xsd:complexType name="GaussQuadrature2Type" />
	<xsd:complexType name="GaussQuadrature3Type" />
	<xsd:complexType name="OutputsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Blueprint" type="BlueprintType" />
			<xsd:element name="ChomboIO" type="ChomboIOType" />
			<xsd:element name="Restart" type="RestartType" />
			<xsd:element name="Silo" type="SiloType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="BlueprintType" />
	<xsd:complexType name="ChomboIOType" />
	<xsd:complexType name="RestartType" />
	<xsd:complexType name="SiloType" />
	<xsd:complexType name="SolversType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="CompositionalMultiphaseFlow" type="CompositionalMultiphaseFlowType" />
			<xsd:element name="DummySolver" type="DummySolverType" />
			<xsd:element name="Hydrofracture" type="HydrofractureType" />
			<xsd:element name="LaplaceFEM" type="LaplaceFEMType" />
			<xsd:element name="Poroelastic" type="PoroelasticType" />
			<xsd:element name="SinglePhaseFlow" type="SinglePhaseFlowType" />
			<xsd:element name="SolidMechanicsLagrangianSSLE" type="SolidMechanicsLagrangianSSLEType" />
			<xsd:element name="SolidMechanics_LagrangianFEM" type="SolidMechanics_LagrangianFEMType" />
			<xsd:element name="SurfaceGenerator" type="SurfaceGeneratorType" />
		</xsd:choice>
		<!--gravityVector => (no description available)-->
		<xsd:attribute name="gravityVector" type="R1Tensor" default="0 0 0" />
	</xsd:complexType>
	<xsd:complexType name="CompositionalMultiphaseFlowType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="SystemSolverParameters" type="SystemSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--verboseLevel => Verbosity level for this solver. Higher values will lead to more screen output. For non-debug  simulations, this should remain at 0.-->
		<xsd:attribute name="verboseLevel" type="integer" default="0" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object to use for this solver.-->
		<xsd:attribute name="discretization" type="string" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--gravityFlag => Flag that enables/disables gravity-->
		<xsd:attribute name="gravityFlag" type="integer" use="required" />
		<!--fluidName => Name of fluid constitutive object to use for this solver.-->
		<xsd:attribute name="fluidName" type="string" use="required" />
		<!--solidName => Name of solid constitutive object to use for this solver-->
		<xsd:attribute name="solidName" type="string" use="required" />
		<!--temperature => Temperature-->
		<xsd:attribute name="temperature" type="real64" use="required" />
		<!--useMass => Use mass formulation instead of molar-->
		<xsd:attribute name="useMass" type="integer" default="0" />
		<!--relPermName => Name of the relative permeability constitutive model to use-->
		<xsd:attribute name="relPermName" type="string" use="required" />
		<!--capPressureName => Name of the capillary pressure constitutive model to use-->
		<xsd:attribute name="capPressureName" type="string" default="" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="DummySolverType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="SystemSolverParameters" type="SystemSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--verboseLevel => Verbosity level for this solver. Higher values will lead to more screen output. For non-debug  simulations, this should remain at 0.-->
		<xsd:attribute name="verboseLevel" type="integer" default="0" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should bespecified.-->
		<xsd:attribute name="discretization" type="string" default="none" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--rand_scale => Scale for modifying requested dt-->
		<xsd:attribute name="rand_scale" type="real64" default="1e-09" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="HydrofractureType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="SystemSolverParameters" type="SystemSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--verboseLevel => Verbosity level for this solver. Higher values will lead to more screen output. For non-debug  simulations, this should remain at 0.-->
		<xsd:attribute name="verboseLevel" type="integer" default="0" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should bespecified.-->
		<xsd:attribute name="discretization" type="string" default="none" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--solidSolverName => Name of the solid mechanics solver to use in the poroelastic solver-->
		<xsd:attribute name="solidSolverName" type="string" use="required" />
		<!--fluidSolverName => Name of the fluid mechanics solver to use in the poroelastic solver-->
		<xsd:attribute name="fluidSolverName" type="string" use="required" />
		<!--couplingTypeOption => Coupling option: (FixedStress, TightlyCoupled)-->
		<xsd:attribute name="couplingTypeOption" type="string" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="LaplaceFEMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="SystemSolverParameters" type="SystemSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--verboseLevel => Verbosity level for this solver. Higher values will lead to more screen output. For non-debug  simulations, this should remain at 0.-->
		<xsd:attribute name="verboseLevel" type="integer" default="0" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should bespecified.-->
		<xsd:attribute name="discretization" type="string" default="none" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--timeIntegrationOption => option for default time integration method-->
		<xsd:attribute name="timeIntegrationOption" type="string" use="required" />
		<!--fieldName => name of field variable-->
		<xsd:attribute name="fieldName" type="string" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PoroelasticType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="SystemSolverParameters" type="SystemSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--verboseLevel => Verbosity level for this solver. Higher values will lead to more screen output. For non-debug  simulations, this should remain at 0.-->
		<xsd:attribute name="verboseLevel" type="integer" default="0" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should bespecified.-->
		<xsd:attribute name="discretization" type="string" default="none" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--solidSolverName => Name of the solid mechanics solver to use in the poroelastic solver-->
		<xsd:attribute name="solidSolverName" type="string" use="required" />
		<!--fluidSolverName => Name of the fluid mechanics solver to use in the poroelastic solver-->
		<xsd:attribute name="fluidSolverName" type="string" use="required" />
		<!--couplingTypeOption => Coupling option: (FixedStress, TightlyCoupled)-->
		<xsd:attribute name="couplingTypeOption" type="string" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhaseFlowType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="SystemSolverParameters" type="SystemSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--verboseLevel => Verbosity level for this solver. Higher values will lead to more screen output. For non-debug  simulations, this should remain at 0.-->
		<xsd:attribute name="verboseLevel" type="integer" default="0" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object to use for this solver.-->
		<xsd:attribute name="discretization" type="string" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--gravityFlag => Flag that enables/disables gravity-->
		<xsd:attribute name="gravityFlag" type="integer" use="required" />
		<!--fluidName => Name of fluid constitutive object to use for this solver.-->
		<xsd:attribute name="fluidName" type="string" use="required" />
		<!--solidName => Name of solid constitutive object to use for this solver-->
		<xsd:attribute name="solidName" type="string" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SolidMechanicsLagrangianSSLEType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="SystemSolverParameters" type="SystemSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--verboseLevel => Verbosity level for this solver. Higher values will lead to more screen output. For non-debug  simulations, this should remain at 0.-->
		<xsd:attribute name="verboseLevel" type="integer" default="0" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should bespecified.-->
		<xsd:attribute name="discretization" type="string" default="none" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--newmarkGamma => Value of :math:`\gamma` in the Newmark Method for Implicit Dynamic time integration option-->
		<xsd:attribute name="newmarkGamma" type="real64" default="0.5" />
		<!--newmarkBeta => Value of :math:`\beta` in the Newmark Method for Implicit Dynamic time integration option. This should be pow(newmarkGamma+0.5,2.0)/4.0 unless you know what you are doing.-->
		<xsd:attribute name="newmarkBeta" type="real64" default="0.25" />
		<!--massDamping => Value of mass based damping coefficient. -->
		<xsd:attribute name="massDamping" type="real64" default="0" />
		<!--stiffnessDamping => Value of stiffness based damping coefficient. -->
		<xsd:attribute name="stiffnessDamping" type="real64" default="0" />
		<!--timeIntegrationOption => Time integration method. Options are: 
 QuasiStatic 
 ImplicitDynamic 
 ExplicitDynamic-->
		<xsd:attribute name="timeIntegrationOption" type="string" default="" />
		<!--useVelocityForQS => Flag to indicate the use of the incremental displacement from the previous step as an initial estimate for the incremental displacement of the current step.-->
		<xsd:attribute name="useVelocityForQS" type="integer" default="0" />
		<!--maxNumResolves => Value to indicate how many resolves may be executed after some other event is executed. For example, if a SurfaceGenerator is specified, it will be executed after the mechanics solve. However if a new surface is generated, then the mechanics solve must be executed again due to the change in topology.-->
		<xsd:attribute name="maxNumResolves" type="integer" default="10" />
		<!--strainTheory => Indicates whether or not to use `Infinitesimal Strain Theory <https://en.wikipedia.org/wiki/Infinitesimal_strain_theory>`_, or `Finite Strain Theory <https://en.wikipedia.org/wiki/Finite_strain_theory>`_. Valid Inputs are:
 0 - Infinitesimal Strain 
 1 - Finite Strain-->
		<xsd:attribute name="strainTheory" type="integer" default="0" />
		<!--solidMaterialName => The name of the material that should be used in the constitutive updates-->
		<xsd:attribute name="solidMaterialName" type="string" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SolidMechanics_LagrangianFEMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="SystemSolverParameters" type="SystemSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--verboseLevel => Verbosity level for this solver. Higher values will lead to more screen output. For non-debug  simulations, this should remain at 0.-->
		<xsd:attribute name="verboseLevel" type="integer" default="0" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should bespecified.-->
		<xsd:attribute name="discretization" type="string" default="none" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--newmarkGamma => Value of :math:`\gamma` in the Newmark Method for Implicit Dynamic time integration option-->
		<xsd:attribute name="newmarkGamma" type="real64" default="0.5" />
		<!--newmarkBeta => Value of :math:`\beta` in the Newmark Method for Implicit Dynamic time integration option. This should be pow(newmarkGamma+0.5,2.0)/4.0 unless you know what you are doing.-->
		<xsd:attribute name="newmarkBeta" type="real64" default="0.25" />
		<!--massDamping => Value of mass based damping coefficient. -->
		<xsd:attribute name="massDamping" type="real64" default="0" />
		<!--stiffnessDamping => Value of stiffness based damping coefficient. -->
		<xsd:attribute name="stiffnessDamping" type="real64" default="0" />
		<!--timeIntegrationOption => Time integration method. Options are: 
 QuasiStatic 
 ImplicitDynamic 
 ExplicitDynamic-->
		<xsd:attribute name="timeIntegrationOption" type="string" default="" />
		<!--useVelocityForQS => Flag to indicate the use of the incremental displacement from the previous step as an initial estimate for the incremental displacement of the current step.-->
		<xsd:attribute name="useVelocityForQS" type="integer" default="0" />
		<!--maxNumResolves => Value to indicate how many resolves may be executed after some other event is executed. For example, if a SurfaceGenerator is specified, it will be executed after the mechanics solve. However if a new surface is generated, then the mechanics solve must be executed again due to the change in topology.-->
		<xsd:attribute name="maxNumResolves" type="integer" default="10" />
		<!--strainTheory => Indicates whether or not to use `Infinitesimal Strain Theory <https://en.wikipedia.org/wiki/Infinitesimal_strain_theory>`_, or `Finite Strain Theory <https://en.wikipedia.org/wiki/Finite_strain_theory>`_. Valid Inputs are:
 0 - Infinitesimal Strain 
 1 - Finite Strain-->
		<xsd:attribute name="strainTheory" type="integer" default="0" />
		<!--solidMaterialName => The name of the material that should be used in the constitutive updates-->
		<xsd:attribute name="solidMaterialName" type="string" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SurfaceGeneratorType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="SystemSolverParameters" type="SystemSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--verboseLevel => Verbosity level for this solver. Higher values will lead to more screen output. For non-debug  simulations, this should remain at 0.-->
		<xsd:attribute name="verboseLevel" type="integer" default="0" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should bespecified.-->
		<xsd:attribute name="discretization" type="string" default="none" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--fractureRegion => (no description available)-->
		<xsd:attribute name="fractureRegion" type="string" default="FractureRegion" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ConstitutiveType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="BlackOilFluid" type="BlackOilFluidType" />
			<xsd:element name="BrooksCoreyBakerRelativePermeability" type="BrooksCoreyBakerRelativePermeabilityType" />
			<xsd:element name="BrooksCoreyCapillaryPressure" type="BrooksCoreyCapillaryPressureType" />
			<xsd:element name="BrooksCoreyRelativePermeability" type="BrooksCoreyRelativePermeabilityType" />
			<xsd:element name="CompositionalMultiphaseFluid" type="CompositionalMultiphaseFluidType" />
			<xsd:element name="CompressibleSinglePhaseFluid" type="CompressibleSinglePhaseFluidType" />
			<xsd:element name="LinearElasticAnisotropic" type="LinearElasticAnisotropicType" />
			<xsd:element name="LinearElasticIsotropic" type="LinearElasticIsotropicType" />
			<xsd:element name="PoreVolumeCompressibleSolid" type="PoreVolumeCompressibleSolidType" />
			<xsd:element name="PoroLinearElasticAnisotropic" type="PoroLinearElasticAnisotropicType" />
			<xsd:element name="PoroLinearElasticIsotropic" type="PoroLinearElasticIsotropicType" />
			<xsd:element name="VanGenuchtenBakerRelativePermeability" type="VanGenuchtenBakerRelativePermeabilityType" />
			<xsd:element name="VanGenuchtenCapillaryPressure" type="VanGenuchtenCapillaryPressureType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="BlackOilFluidType" />
	<xsd:complexType name="BrooksCoreyBakerRelativePermeabilityType" />
	<xsd:complexType name="BrooksCoreyCapillaryPressureType" />
	<xsd:complexType name="BrooksCoreyRelativePermeabilityType" />
	<xsd:complexType name="CompositionalMultiphaseFluidType" />
	<xsd:complexType name="CompressibleSinglePhaseFluidType" />
	<xsd:complexType name="LinearElasticAnisotropicType" />
	<xsd:complexType name="LinearElasticIsotropicType" />
	<xsd:complexType name="PoreVolumeCompressibleSolidType" />
	<xsd:complexType name="PoroLinearElasticAnisotropicType" />
	<xsd:complexType name="PoroLinearElasticIsotropicType" />
	<xsd:complexType name="VanGenuchtenBakerRelativePermeabilityType" />
	<xsd:complexType name="VanGenuchtenCapillaryPressureType" />
	<xsd:complexType name="ElementRegionsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="ElementRegion" type="ElementRegionType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="ElementRegionType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded" />
		<!--materialList => List of materials present in this region-->
		<xsd:attribute name="materialList" type="string_array" use="required" />
		<!--cellBlocks => (no description available)-->
		<xsd:attribute name="cellBlocks" type="string_array" default="" />
		<!--coarseningRatio => (no description available)-->
		<xsd:attribute name="coarseningRatio" type="real64" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="IncludedType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="File" type="FileType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="FileType" />
	<xsd:complexType name="ParametersType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Parameter" type="ParameterType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="ParameterType" />
</xsd:schema>
