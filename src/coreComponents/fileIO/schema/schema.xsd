<?xml version="1.0"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
	<xsd:annotation>
		<xsd:documentation xml:lang="en">GEOSX Input Schema</xsd:documentation>
	</xsd:annotation>
	<xsd:simpleType name="R1Tensor">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\s*([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*){2}[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geosx_dataRepository_PlotLevel">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|[+-]?[\d]+" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="globalIndex">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|[+-]?[\d]+" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="globalIndex_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\}" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="globalIndex_array2d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\{\s*(\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\},\s*)*\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\}\s*\}" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="globalIndex_array3d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\{\s*(\{\s*(\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\},\s*)*\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\}\s*\},\s*)*\{\s*(\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\},\s*)*\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\}\s*\}\s*\}" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="integer">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|[+-]?[\d]+" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="integer_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\}" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="integer_array2d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\{\s*(\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\},\s*)*\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\}\s*\}" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="integer_array3d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\{\s*(\{\s*(\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\},\s*)*\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\}\s*\},\s*)*\{\s*(\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\},\s*)*\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\}\s*\}\s*\}" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="localIndex">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|[+-]?[\d]+" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="localIndex_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\}" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="localIndex_array2d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\{\s*(\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\},\s*)*\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\}\s*\}" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="localIndex_array3d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\{\s*(\{\s*(\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\},\s*)*\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\}\s*\},\s*)*\{\s*(\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\},\s*)*\{\s*(([+-]?[\d]+,\s*)*[+-]?[\d]+)?\s*\}\s*\}\s*\}" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="mapPair">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|[^,\{\}]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="mapPair_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\{\s*(([^,\{\}]*,\s*)*[^,\{\}]*)?\s*\}" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="path">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|[^,\{\}]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="path_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\{\s*(([^,\{\}]*,\s*)*[^,\{\}]*)?\s*\}" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="r1_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\{\s*((\s*([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*){2}[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*)*\s*([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*){2}[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*))?\s*\}" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="r1_array2d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\{\s*(\{\s*((\s*([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*){2}[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*)*\s*([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*){2}[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*))?\s*\},\s*)*\{\s*((\s*([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*){2}[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*)*\s*([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*){2}[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*))?\s*\}\s*\}" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real32">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real32_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*))?\s*\}" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real32_array2d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\{\s*(\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*))?\s*\},\s*)*\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*))?\s*\}\s*\}" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real32_array3d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\{\s*(\{\s*(\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*))?\s*\},\s*)*\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*))?\s*\}\s*\},\s*)*\{\s*(\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*))?\s*\},\s*)*\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*))?\s*\}\s*\}\s*\}" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real64">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*)" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real64_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*))?\s*\}" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real64_array2d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\{\s*(\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*))?\s*\},\s*)*\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*))?\s*\}\s*\}" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="real64_array3d">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\{\s*(\{\s*(\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*))?\s*\},\s*)*\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*))?\s*\}\s*\},\s*)*\{\s*(\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*))?\s*\},\s*)*\{\s*(([+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*),\s*)*[+-]?[\d]*([\d]\.?|\.[\d])[\d]*([eE][-+]?[\d]+|\s*))?\s*\}\s*\}\s*\}" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="string">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|[^,\{\}]*" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="string_array">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|\{\s*(([^,\{\}]*,\s*)*[^,\{\}]*)?\s*\}" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:element name="Problem" type="ProblemType" />
	<xsd:complexType name="ProblemType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Events" type="EventsType" minOccurs="1" maxOccurs="1" />
			<xsd:element name="FieldSpecifications" type="FieldSpecificationsType" maxOccurs="1" />
			<xsd:element name="Functions" type="FunctionsType" maxOccurs="1" />
			<xsd:element name="Geometry" type="GeometryType" maxOccurs="1" />
			<xsd:element name="Mesh" type="MeshType" minOccurs="1" maxOccurs="1" />
			<xsd:element name="NumericalMethods" type="NumericalMethodsType" maxOccurs="1" />
			<xsd:element name="Outputs" type="OutputsType" minOccurs="1" maxOccurs="1" />
			<xsd:element name="Solvers" type="SolversType" minOccurs="1" maxOccurs="1" />
			<xsd:element name="Tasks" type="TasksType" maxOccurs="1" />
			<xsd:element name="Constitutive" type="ConstitutiveType" maxOccurs="1" />
			<xsd:element name="ElementRegions" type="ElementRegionsType" maxOccurs="1" />
			<xsd:element name="Included" type="IncludedType" maxOccurs="1" />
			<xsd:element name="Parameters" type="ParametersType" maxOccurs="1" />
			<xsd:element name="Benchmarks" type="BenchmarksType" maxOccurs="1" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="EventsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="HaltEvent" type="HaltEventType" />
			<xsd:element name="PeriodicEvent" type="PeriodicEventType" />
			<xsd:element name="SoloEvent" type="SoloEventType" />
		</xsd:choice>
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxCycle => Maximum simulation cycle for the global event loop.-->
		<xsd:attribute name="maxCycle" type="integer" default="2147483647" />
		<!--maxTime => Maximum simulation time for the global event loop.-->
		<xsd:attribute name="maxTime" type="real64" default="1.79769e+308" />
	</xsd:complexType>
	<xsd:complexType name="HaltEventType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="HaltEvent" type="HaltEventType" />
			<xsd:element name="PeriodicEvent" type="PeriodicEventType" />
			<xsd:element name="SoloEvent" type="SoloEventType" />
		</xsd:choice>
		<!--beginTime => Start time of this event.-->
		<xsd:attribute name="beginTime" type="real64" default="0" />
		<!--endTime => End time of this event.-->
		<xsd:attribute name="endTime" type="real64" default="1e+100" />
		<!--finalDtStretch => Allow the final dt request for this event to grow by this percentage to match the endTime exactly.-->
		<xsd:attribute name="finalDtStretch" type="real64" default="0.001" />
		<!--forceDt => While active, this event will request this timestep value (ignoring any children/targets requests).-->
		<xsd:attribute name="forceDt" type="real64" default="-1" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxEventDt => While active, this event will request a timestep <= this value (depending upon any child/target requests).-->
		<xsd:attribute name="maxEventDt" type="real64" default="-1" />
		<!--maxRuntime => The maximum allowable runtime for the job.-->
		<xsd:attribute name="maxRuntime" type="real64" use="required" />
		<!--target => Name of the object to be executed when the event criteria are met.-->
		<xsd:attribute name="target" type="string" default="" />
		<!--targetExactStartStop => If this option is set, the event will reduce its timestep requests to match any specified beginTime/endTimes exactly.-->
		<xsd:attribute name="targetExactStartStop" type="integer" default="1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PeriodicEventType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="HaltEvent" type="HaltEventType" />
			<xsd:element name="PeriodicEvent" type="PeriodicEventType" />
			<xsd:element name="SoloEvent" type="SoloEventType" />
		</xsd:choice>
		<!--beginTime => Start time of this event.-->
		<xsd:attribute name="beginTime" type="real64" default="0" />
		<!--cycleFrequency => Event application frequency (cycle, default)-->
		<xsd:attribute name="cycleFrequency" type="integer" default="1" />
		<!--endTime => End time of this event.-->
		<xsd:attribute name="endTime" type="real64" default="1e+100" />
		<!--finalDtStretch => Allow the final dt request for this event to grow by this percentage to match the endTime exactly.-->
		<xsd:attribute name="finalDtStretch" type="real64" default="0.001" />
		<!--forceDt => While active, this event will request this timestep value (ignoring any children/targets requests).-->
		<xsd:attribute name="forceDt" type="real64" default="-1" />
		<!--function => Name of an optional function to evaluate when the time/cycle criteria are met.If the result is greater than the specified eventThreshold, the function will continue to execute.-->
		<xsd:attribute name="function" type="string" default="" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxEventDt => While active, this event will request a timestep <= this value (depending upon any child/target requests).-->
		<xsd:attribute name="maxEventDt" type="real64" default="-1" />
		<!--object => If the optional function requires an object as an input, specify its path here.-->
		<xsd:attribute name="object" type="string" default="" />
		<!--set => If the optional function is applied to an object, specify the setname to evaluate (default = everything).-->
		<xsd:attribute name="set" type="string" default="" />
		<!--stat => If the optional function is applied to an object, specify the statistic to compare to the eventThreshold.The current options include: min, avg, and max.-->
		<xsd:attribute name="stat" type="integer" default="0" />
		<!--target => Name of the object to be executed when the event criteria are met.-->
		<xsd:attribute name="target" type="string" default="" />
		<!--targetExactStartStop => If this option is set, the event will reduce its timestep requests to match any specified beginTime/endTimes exactly.-->
		<xsd:attribute name="targetExactStartStop" type="integer" default="1" />
		<!--targetExactTimestep => If this option is set, the event will reduce its timestep requests to match the specified timeFrequency perfectly: dt_request = min(dt_request, t_last + time_frequency - time)).-->
		<xsd:attribute name="targetExactTimestep" type="integer" default="1" />
		<!--threshold => If the optional function is used, the event will execute if the value returned by the function exceeds this threshold.-->
		<xsd:attribute name="threshold" type="real64" default="0" />
		<!--timeFrequency => Event application frequency (time).  Note: if this value is specified, it will override any cycle-based behavior.-->
		<xsd:attribute name="timeFrequency" type="real64" default="-1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SoloEventType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="HaltEvent" type="HaltEventType" />
			<xsd:element name="PeriodicEvent" type="PeriodicEventType" />
			<xsd:element name="SoloEvent" type="SoloEventType" />
		</xsd:choice>
		<!--beginTime => Start time of this event.-->
		<xsd:attribute name="beginTime" type="real64" default="0" />
		<!--endTime => End time of this event.-->
		<xsd:attribute name="endTime" type="real64" default="1e+100" />
		<!--finalDtStretch => Allow the final dt request for this event to grow by this percentage to match the endTime exactly.-->
		<xsd:attribute name="finalDtStretch" type="real64" default="0.001" />
		<!--forceDt => While active, this event will request this timestep value (ignoring any children/targets requests).-->
		<xsd:attribute name="forceDt" type="real64" default="-1" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxEventDt => While active, this event will request a timestep <= this value (depending upon any child/target requests).-->
		<xsd:attribute name="maxEventDt" type="real64" default="-1" />
		<!--target => Name of the object to be executed when the event criteria are met.-->
		<xsd:attribute name="target" type="string" default="" />
		<!--targetCycle => Targeted cycle to execute the event.-->
		<xsd:attribute name="targetCycle" type="integer" default="-1" />
		<!--targetExactStartStop => If this option is set, the event will reduce its timestep requests to match any specified beginTime/endTimes exactly.-->
		<xsd:attribute name="targetExactStartStop" type="integer" default="1" />
		<!--targetExactTimestep => If this option is set, the event will reduce its timestep requests to match the specified execution time exactly: dt_request = min(dt_request, t_target - time)).-->
		<xsd:attribute name="targetExactTimestep" type="integer" default="1" />
		<!--targetTime => Targeted time to execute the event.-->
		<xsd:attribute name="targetTime" type="real64" default="-1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="FieldSpecificationsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Dirichlet" type="DirichletType" />
			<xsd:element name="FieldSpecification" type="FieldSpecificationType" />
			<xsd:element name="SourceFlux" type="SourceFluxType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="DirichletType">
		<!--bcApplicationTableName => Name of table that specifies the on/off application of the bc.-->
		<xsd:attribute name="bcApplicationTableName" type="string" default="" />
		<!--beginTime => time at which BC will start being applied.-->
		<xsd:attribute name="beginTime" type="real64" default="-1e+99" />
		<!--component => Component of field (if tensor) to apply boundary condition to-->
		<xsd:attribute name="component" type="integer" default="0" />
		<!--direction => Direction to apply boundary condition to-->
		<xsd:attribute name="direction" type="R1Tensor" default="0,0,0" />
		<!--endTime => time at which bc will stop being applied-->
		<xsd:attribute name="endTime" type="real64" default="1e+99" />
		<!--fieldName => Name of field that boundary condition is applied to.-->
		<xsd:attribute name="fieldName" type="string" default="" />
		<!--functionName => Name of function that specifies variation of the BC-->
		<xsd:attribute name="functionName" type="string" default="" />
		<!--initialCondition => BC is applied as an initial condition.-->
		<xsd:attribute name="initialCondition" type="integer" default="0" />
		<!--objectPath => Path to the target field-->
		<xsd:attribute name="objectPath" type="string" default="" />
		<!--scale => Scale factor for value of BC.-->
		<xsd:attribute name="scale" type="real64" default="0" />
		<!--setNames => Name of sets that boundary condition is applied to.-->
		<xsd:attribute name="setNames" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="FieldSpecificationType">
		<!--bcApplicationTableName => Name of table that specifies the on/off application of the bc.-->
		<xsd:attribute name="bcApplicationTableName" type="string" default="" />
		<!--beginTime => time at which BC will start being applied.-->
		<xsd:attribute name="beginTime" type="real64" default="-1e+99" />
		<!--component => Component of field (if tensor) to apply boundary condition to-->
		<xsd:attribute name="component" type="integer" default="0" />
		<!--direction => Direction to apply boundary condition to-->
		<xsd:attribute name="direction" type="R1Tensor" default="0,0,0" />
		<!--endTime => time at which bc will stop being applied-->
		<xsd:attribute name="endTime" type="real64" default="1e+99" />
		<!--fieldName => Name of field that boundary condition is applied to.-->
		<xsd:attribute name="fieldName" type="string" default="" />
		<!--functionName => Name of function that specifies variation of the BC-->
		<xsd:attribute name="functionName" type="string" default="" />
		<!--initialCondition => BC is applied as an initial condition.-->
		<xsd:attribute name="initialCondition" type="integer" default="0" />
		<!--objectPath => Path to the target field-->
		<xsd:attribute name="objectPath" type="string" default="" />
		<!--scale => Scale factor for value of BC.-->
		<xsd:attribute name="scale" type="real64" default="0" />
		<!--setNames => Name of sets that boundary condition is applied to.-->
		<xsd:attribute name="setNames" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SourceFluxType">
		<!--bcApplicationTableName => Name of table that specifies the on/off application of the bc.-->
		<xsd:attribute name="bcApplicationTableName" type="string" default="" />
		<!--beginTime => time at which BC will start being applied.-->
		<xsd:attribute name="beginTime" type="real64" default="-1e+99" />
		<!--component => Component of field (if tensor) to apply boundary condition to-->
		<xsd:attribute name="component" type="integer" default="0" />
		<!--direction => Direction to apply boundary condition to-->
		<xsd:attribute name="direction" type="R1Tensor" default="0,0,0" />
		<!--endTime => time at which bc will stop being applied-->
		<xsd:attribute name="endTime" type="real64" default="1e+99" />
		<!--fieldName => Name of field that boundary condition is applied to.-->
		<xsd:attribute name="fieldName" type="string" default="" />
		<!--functionName => Name of function that specifies variation of the BC-->
		<xsd:attribute name="functionName" type="string" default="" />
		<!--initialCondition => BC is applied as an initial condition.-->
		<xsd:attribute name="initialCondition" type="integer" default="0" />
		<!--objectPath => Path to the target field-->
		<xsd:attribute name="objectPath" type="string" default="" />
		<!--scale => Scale factor for value of BC.-->
		<xsd:attribute name="scale" type="real64" default="0" />
		<!--setNames => Name of sets that boundary condition is applied to.-->
		<xsd:attribute name="setNames" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="FunctionsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="CompositeFunction" type="CompositeFunctionType" />
			<xsd:element name="SymbolicFunction" type="SymbolicFunctionType" />
			<xsd:element name="TableFunction" type="TableFunctionType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="CompositeFunctionType">
		<!--expression => Composite math expression-->
		<xsd:attribute name="expression" type="string" default="" />
		<!--functionNames => List of source functions. The order must match the variableNames argument.-->
		<xsd:attribute name="functionNames" type="string_array" default="{}" />
		<!--inputVarNames => Name of fields are input to function.-->
		<xsd:attribute name="inputVarNames" type="string_array" default="{}" />
		<!--variableNames => List of variables in expression-->
		<xsd:attribute name="variableNames" type="string_array" default="{}" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SymbolicFunctionType">
		<!--expression => Symbolic math expression-->
		<xsd:attribute name="expression" type="string" use="required" />
		<!--inputVarNames => Name of fields are input to function.-->
		<xsd:attribute name="inputVarNames" type="string_array" default="{}" />
		<!--variableNames => List of variables in expression.  The order must match the evaluate argument-->
		<xsd:attribute name="variableNames" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="TableFunctionType">
		<!--coordinateFiles => List of coordinate file names for ND Table-->
		<xsd:attribute name="coordinateFiles" type="path_array" default="{}" />
		<!--coordinates => Coordinates inputs for 1D tables-->
		<xsd:attribute name="coordinates" type="real64_array" default="{0}" />
		<!--inputVarNames => Name of fields are input to function.-->
		<xsd:attribute name="inputVarNames" type="string_array" default="{}" />
		<!--interpolation => Interpolation method. Valid options:
* linear
* nearest
* upper
* lower-->
		<xsd:attribute name="interpolation" type="geosx_TableFunction_InterpolationType" default="linear" />
		<!--values => Values for 1D tables-->
		<xsd:attribute name="values" type="real64_array" default="{0}" />
		<!--voxelFile => Voxel file name for ND Table-->
		<xsd:attribute name="voxelFile" type="path" default="" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geosx_TableFunction_InterpolationType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|linear|nearest|upper|lower" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="GeometryType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="BoundedPlane" type="BoundedPlaneType" />
			<xsd:element name="Box" type="BoxType" />
			<xsd:element name="Cylinder" type="CylinderType" />
			<xsd:element name="ThickPlane" type="ThickPlaneType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="BoundedPlaneType">
		<!--dimensions => Length and width of the bounded plane-->
		<xsd:attribute name="dimensions" type="real64_array" use="required" />
		<!--lengthVector => Tangent vector defining the orthonormal basis along with the normal.-->
		<xsd:attribute name="lengthVector" type="R1Tensor" use="required" />
		<!--normal => Normal (n_x,n_y,n_z) to the plane (will be normalized automatically)-->
		<xsd:attribute name="normal" type="R1Tensor" use="required" />
		<!--origin => Origin point (x,y,z) of the plane (basically, any point on the plane)-->
		<xsd:attribute name="origin" type="R1Tensor" use="required" />
		<!--widthVector => Tangent vector defining the orthonormal basis along with the normal.-->
		<xsd:attribute name="widthVector" type="R1Tensor" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="BoxType">
		<!--strike => The strike angle of the box-->
		<xsd:attribute name="strike" type="real64" default="-90" />
		<!--xMax => Maximum (x,y,z) coordinates of the box-->
		<xsd:attribute name="xMax" type="R1Tensor" use="required" />
		<!--xMin => Minimum (x,y,z) coordinates of the box-->
		<xsd:attribute name="xMin" type="R1Tensor" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CylinderType">
		<!--point1 => Center point of one (upper or lower) face of the cylinder-->
		<xsd:attribute name="point1" type="R1Tensor" use="required" />
		<!--point2 => Center point of the other face of the cylinder-->
		<xsd:attribute name="point2" type="R1Tensor" use="required" />
		<!--radius => Radius of the cylinder-->
		<xsd:attribute name="radius" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ThickPlaneType">
		<!--normal => Normal (n_x,n_y,n_z) to the plane (will be normalized automatically)-->
		<xsd:attribute name="normal" type="R1Tensor" use="required" />
		<!--origin => Origin point (x,y,z) of the plane (basically, any point on the plane)-->
		<xsd:attribute name="origin" type="R1Tensor" use="required" />
		<!--thickness => The total thickness of the plane (with half to each side)-->
		<xsd:attribute name="thickness" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="MeshType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="InternalMesh" type="InternalMeshType" />
			<xsd:element name="InternalWell" type="InternalWellType" />
			<xsd:element name="PAMELAMeshGenerator" type="PAMELAMeshGeneratorType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="InternalMeshType">
		<!--cellBlockNames => names of each mesh block-->
		<xsd:attribute name="cellBlockNames" type="string_array" use="required" />
		<!--elementTypes => element types of each mesh block-->
		<xsd:attribute name="elementTypes" type="string_array" use="required" />
		<!--nx => number of elements in the x-direction within each mesh block-->
		<xsd:attribute name="nx" type="integer_array" use="required" />
		<!--ny => number of elements in the y-direction within each mesh block-->
		<xsd:attribute name="ny" type="integer_array" use="required" />
		<!--nz => number of elements in the z-direction within each mesh block-->
		<xsd:attribute name="nz" type="integer_array" use="required" />
		<!--trianglePattern => pattern by which to decompose the hex mesh into prisms (more explanation required)-->
		<xsd:attribute name="trianglePattern" type="integer" default="0" />
		<!--xBias => bias of element sizes in the x-direction within each mesh block (dx_left=(1+b)*L/N, dx_right=(1-b)*L/N)-->
		<xsd:attribute name="xBias" type="real64_array" default="{1}" />
		<!--xCoords => x-coordinates of each mesh block vertex-->
		<xsd:attribute name="xCoords" type="real64_array" use="required" />
		<!--yBias => bias of element sizes in the y-direction within each mesh block (dy_left=(1+b)*L/N, dx_right=(1-b)*L/N)-->
		<xsd:attribute name="yBias" type="real64_array" default="{1}" />
		<!--yCoords => y-coordinates of each mesh block vertex-->
		<xsd:attribute name="yCoords" type="real64_array" use="required" />
		<!--zBias => bias of element sizes in the z-direction within each mesh block (dz_left=(1+b)*L/N, dz_right=(1-b)*L/N)-->
		<xsd:attribute name="zBias" type="real64_array" default="{1}" />
		<!--zCoords => z-coordinates of each mesh block vertex-->
		<xsd:attribute name="zCoords" type="real64_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="InternalWellType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Perforation" type="PerforationType" />
		</xsd:choice>
		<!--meshName => Name of the reservoir mesh associated with this well-->
		<xsd:attribute name="meshName" type="string" use="required" />
		<!--numElementsPerSegment => Number of well elements per polyline segment-->
		<xsd:attribute name="numElementsPerSegment" type="integer" use="required" />
		<!--polylineNodeCoords => Physical coordinates of the well polyline nodes-->
		<xsd:attribute name="polylineNodeCoords" type="real64_array2d" use="required" />
		<!--polylineSegmentConn => Connectivity of the polyline segments-->
		<xsd:attribute name="polylineSegmentConn" type="globalIndex_array2d" use="required" />
		<!--radius => Radius of the well-->
		<xsd:attribute name="radius" type="real64" use="required" />
		<!--wellControlsName => Name of the set of constraints associated with this well-->
		<xsd:attribute name="wellControlsName" type="string" use="required" />
		<!--wellRegionName => Name of the well element region-->
		<xsd:attribute name="wellRegionName" type="string" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PerforationType">
		<!--distanceFromHead => Linear distance from well head to the perforation-->
		<xsd:attribute name="distanceFromHead" type="real64" use="required" />
		<!--transmissibility => Perforation transmissibility-->
		<xsd:attribute name="transmissibility" type="real64" default="-1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PAMELAMeshGeneratorType">
		<!--fieldNamesInGEOSX => Name of the fields within GEOSX-->
		<xsd:attribute name="fieldNamesInGEOSX" type="string_array" default="{}" />
		<!--fieldsToImport => Fields to be imported from the external mesh file-->
		<xsd:attribute name="fieldsToImport" type="string_array" default="{}" />
		<!--file => path to the mesh file-->
		<xsd:attribute name="file" type="path" use="required" />
		<!--reverseZ => 0 : Z coordinate is upward, 1 : Z coordinate is downward-->
		<xsd:attribute name="reverseZ" type="integer" default="0" />
		<!--scale => Scale the coordinates of the vertices-->
		<xsd:attribute name="scale" type="real64" default="1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="NumericalMethodsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="FiniteElements" type="FiniteElementsType" maxOccurs="1" />
			<xsd:element name="FiniteVolume" type="FiniteVolumeType" maxOccurs="1" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="FiniteElementsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="FiniteElementSpace" type="FiniteElementSpaceType" />
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="FiniteElementSpaceType">
		<!--formulation => Specifier to indicate any specialized formuations. For instance, one of the many enhanced assumed strain methods of the Hexahedron parent shape would be indicated here-->
		<xsd:attribute name="formulation" type="string" default="default" />
		<!--order => The order of the finite element basis.-->
		<xsd:attribute name="order" type="integer" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="LinearSolverParametersType">
		<!--amgCoarseSolver => AMG coarsest level solver/smoother type
Available options are: jacobi, gaussSeidel, blockGaussSeidel, chebyshev, direct-->
		<xsd:attribute name="amgCoarseSolver" type="string" default="direct" />
		<!--amgNullSpaceType => AMG near null space approximation-->
		<xsd:attribute name="amgNullSpaceType" type="string" default="constantModes" />
		<!--amgNumSweeps => AMG smoother sweeps-->
		<xsd:attribute name="amgNumSweeps" type="integer" default="2" />
		<!--amgSmootherType => AMG smoother type
Available options are: jacobi, blockJacobi, gaussSeidel, blockGaussSeidel, chebyshev, icc, ilu, ilut-->
		<xsd:attribute name="amgSmootherType" type="string" default="gaussSeidel" />
		<!--amgThreshold => AMG strength-of-connection threshold-->
		<xsd:attribute name="amgThreshold" type="real64" default="0" />
		<!--directCheckResidual => Whether to check the linear system solution residual-->
		<xsd:attribute name="directCheckResidual" type="integer" default="0" />
		<!--directColPerm => How to permute the columns. Available options are:
* none
* MMD_AtplusA
* MMD_AtA
* colAMD
* metis
* parmetis-->
		<xsd:attribute name="directColPerm" type="geosx_LinearSolverParameters_Direct_ColPerm" default="metis" />
		<!--directEquil => Whether to scale the rows and columns of the matrix-->
		<xsd:attribute name="directEquil" type="integer" default="1" />
		<!--directIterRef => Whether to perform iterative refinement-->
		<xsd:attribute name="directIterRef" type="integer" default="1" />
		<!--directParallel => Whether to use a parallel solver (instead of a serial one)-->
		<xsd:attribute name="directParallel" type="integer" default="1" />
		<!--directReplTinyPivot => Whether to replace tiny pivots by sqrt(epsilon)*norm(A)-->
		<xsd:attribute name="directReplTinyPivot" type="integer" default="1" />
		<!--directRowPerm => How to permute the rows. Available options are:
* none
* mc64-->
		<xsd:attribute name="directRowPerm" type="geosx_LinearSolverParameters_Direct_RowPerm" default="mc64" />
		<!--iluFill => ILU(K) fill factor-->
		<xsd:attribute name="iluFill" type="integer" default="0" />
		<!--iluThreshold => ILU(T) threshold factor-->
		<xsd:attribute name="iluThreshold" type="real64" default="0" />
		<!--krylovAdaptiveTol => Use Eisenstat-Walker adaptive linear tolerance-->
		<xsd:attribute name="krylovAdaptiveTol" type="integer" default="0" />
		<!--krylovMaxIter => Maximum iterations allowed for an iterative solver-->
		<xsd:attribute name="krylovMaxIter" type="integer" default="200" />
		<!--krylovMaxRestart => Maximum iterations before restart (GMRES only)-->
		<xsd:attribute name="krylovMaxRestart" type="integer" default="200" />
		<!--krylovTol => Relative convergence tolerance of the iterative method
If the method converges, the iterative solution :math:`\mathsf{x}_k` is such that
the relative residual norm satisfies:
:math:`\left\lVert \mathsf{b} - \mathsf{A} \mathsf{x}_k \right\rVert_2` < ``krylovTol`` * :math:`\left\lVert\mathsf{b}\right\rVert_2`-->
		<xsd:attribute name="krylovTol" type="real64" default="1e-06" />
		<!--krylovWeakestTol => Weakest-allowed tolerance for adaptive method-->
		<xsd:attribute name="krylovWeakestTol" type="real64" default="0.001" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--preconditionerType => Preconditioner type. Available options are:
* none
* jacobi
* gs
* sgs
* iluk
* ilut
* icc
* ict
* amg
* mgr
* block-->
		<xsd:attribute name="preconditionerType" type="geosx_LinearSolverParameters_PreconditionerType" default="iluk" />
		<!--solverType => Linear solver type. Available options are:
* direct
* cg
* gmres
* fgmres
* bicgstab
* preconditioner-->
		<xsd:attribute name="solverType" type="geosx_LinearSolverParameters_SolverType" default="direct" />
		<!--stopIfError => Whether to stop the simulation if the linear solver reports an error-->
		<xsd:attribute name="stopIfError" type="integer" default="1" />
	</xsd:complexType>
	<xsd:simpleType name="geosx_LinearSolverParameters_Direct_ColPerm">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|none|MMD_AtplusA|MMD_AtA|colAMD|metis|parmetis" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geosx_LinearSolverParameters_Direct_RowPerm">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|none|mc64" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geosx_LinearSolverParameters_PreconditionerType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|none|jacobi|gs|sgs|iluk|ilut|icc|ict|amg|mgr|block" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geosx_LinearSolverParameters_SolverType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|direct|cg|gmres|fgmres|bicgstab|preconditioner" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="NonlinearSolverParametersType">
		<!--allowNonConverged => Allow non-converged solution to be accepted. (i.e. exit from the Newton loop without achieving the desired tolerance)-->
		<xsd:attribute name="allowNonConverged" type="integer" default="0" />
		<!--dtCutIterLimit => Fraction of the Max Newton iterations above which the solver asks for the time-step to be cut for the next dt.-->
		<xsd:attribute name="dtCutIterLimit" type="real64" default="0.7" />
		<!--dtIncIterLimit => Fraction of the Max Newton iterations below which the solver asks for the time-step to be doubled for the next dt.-->
		<xsd:attribute name="dtIncIterLimit" type="real64" default="0.4" />
		<!--lineSearchAction => How the line search is to be used. Options are: 
 * None    - Do not use line search.
* Attempt - Use line search. Allow exit from line search without achieving smaller residual than starting residual.
* Require - Use line search. If smaller residual than starting resdual is not achieved, cut time step.-->
		<xsd:attribute name="lineSearchAction" type="geosx_NonlinearSolverParameters_LineSearchAction" default="Attempt" />
		<!--lineSearchCutFactor => Line search cut factor. For instance, a value of 0.5 will result in the effective application of the last solution by a factor of (0.5, 0.25, 0.125, ...)-->
		<xsd:attribute name="lineSearchCutFactor" type="real64" default="0.5" />
		<!--lineSearchMaxCuts => Maximum number of line search cuts.-->
		<xsd:attribute name="lineSearchMaxCuts" type="integer" default="4" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxSubSteps => Maximum number of time sub-steps allowed for the solver-->
		<xsd:attribute name="maxSubSteps" type="integer" default="10" />
		<!--maxTimeStepCuts => Max number of time step cuts-->
		<xsd:attribute name="maxTimeStepCuts" type="integer" default="2" />
		<!--newtonMaxIter => Maximum number of iterations that are allowed in a Newton loop.-->
		<xsd:attribute name="newtonMaxIter" type="integer" default="5" />
		<!--newtonMinIter => Minimum number of iterations that are required before exiting the Newton loop.-->
		<xsd:attribute name="newtonMinIter" type="integer" default="1" />
		<!--newtonTol => The required tolerance in order to exit the Newton iteration loop.-->
		<xsd:attribute name="newtonTol" type="real64" default="1e-06" />
		<!--timestepCutFactor => Factor by which the time step will be cut if a timestep cut is required.-->
		<xsd:attribute name="timestepCutFactor" type="real64" default="0.5" />
	</xsd:complexType>
	<xsd:simpleType name="geosx_NonlinearSolverParameters_LineSearchAction">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|None|Attempt|Require" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="FiniteVolumeType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="HybridMimeticDiscretization" type="HybridMimeticDiscretizationType" />
			<xsd:element name="TwoPointFluxApproximation" type="TwoPointFluxApproximationType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="HybridMimeticDiscretizationType">
		<!--coefficientName => Name of coefficient field-->
		<xsd:attribute name="coefficientName" type="string" use="required" />
		<!--innerProductType => Type of inner product used in the hybrid FVM solver-->
		<xsd:attribute name="innerProductType" type="string" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="TwoPointFluxApproximationType">
		<!--areaRelTol => Relative tolerance for area calculations.-->
		<xsd:attribute name="areaRelTol" type="real64" default="1e-08" />
		<!--coefficientName => Name of coefficient field-->
		<xsd:attribute name="coefficientName" type="string" use="required" />
		<!--fieldName => Name of primary solution field-->
		<xsd:attribute name="fieldName" type="string" use="required" />
		<!--targetRegions => List of regions to build the stencil for-->
		<xsd:attribute name="targetRegions" type="string_array" default="{}" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="OutputsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Blueprint" type="BlueprintType" />
			<xsd:element name="ChomboIO" type="ChomboIOType" />
			<xsd:element name="Restart" type="RestartType" />
			<xsd:element name="Silo" type="SiloType" />
			<xsd:element name="TimeHistory" type="TimeHistoryType" />
			<xsd:element name="VTK" type="VTKType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="BlueprintType">
		<!--childDirectory => Child directory path-->
		<xsd:attribute name="childDirectory" type="string" default="" />
		<!--outputFullQuadratureData => If true writes out data associated with every quadrature point.-->
		<xsd:attribute name="outputFullQuadratureData" type="integer" default="0" />
		<!--parallelThreads => Number of plot files.-->
		<xsd:attribute name="parallelThreads" type="integer" default="1" />
		<!--plotLevel => Determines which fields to write.-->
		<xsd:attribute name="plotLevel" type="geosx_dataRepository_PlotLevel" default="1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ChomboIOType">
		<!--beginCycle => Cycle at which the coupling will commence.-->
		<xsd:attribute name="beginCycle" type="real64" use="required" />
		<!--childDirectory => Child directory path-->
		<xsd:attribute name="childDirectory" type="string" default="" />
		<!--inputPath => Path at which the chombo to geosx file will be written.-->
		<xsd:attribute name="inputPath" type="string" default="/INVALID_INPUT_PATH" />
		<!--outputPath => Path at which the geosx to chombo file will be written.-->
		<xsd:attribute name="outputPath" type="string" use="required" />
		<!--parallelThreads => Number of plot files.-->
		<xsd:attribute name="parallelThreads" type="integer" default="1" />
		<!--useChomboPressures => True iff geosx should use the pressures chombo writes out.-->
		<xsd:attribute name="useChomboPressures" type="integer" default="0" />
		<!--waitForInput => True iff geosx should wait for chombo to write out a file. When true the inputPath must be set.-->
		<xsd:attribute name="waitForInput" type="integer" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="RestartType">
		<!--childDirectory => Child directory path-->
		<xsd:attribute name="childDirectory" type="string" default="" />
		<!--parallelThreads => Number of plot files.-->
		<xsd:attribute name="parallelThreads" type="integer" default="1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SiloType">
		<!--childDirectory => Child directory path-->
		<xsd:attribute name="childDirectory" type="string" default="" />
		<!--parallelThreads => Number of plot files.-->
		<xsd:attribute name="parallelThreads" type="integer" default="1" />
		<!--plotFileRoot => (no description available)-->
		<xsd:attribute name="plotFileRoot" type="string" default="plot" />
		<!--plotLevel => (no description available)-->
		<xsd:attribute name="plotLevel" type="integer" default="1" />
		<!--writeCellElementMesh => (no description available)-->
		<xsd:attribute name="writeCellElementMesh" type="integer" default="1" />
		<!--writeEdgeMesh => (no description available)-->
		<xsd:attribute name="writeEdgeMesh" type="integer" default="0" />
		<!--writeFEMFaces => (no description available)-->
		<xsd:attribute name="writeFEMFaces" type="integer" default="0" />
		<!--writeFaceElementMesh => (no description available)-->
		<xsd:attribute name="writeFaceElementMesh" type="integer" default="1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="TimeHistoryType">
		<!--childDirectory => Child directory path-->
		<xsd:attribute name="childDirectory" type="string" default="" />
		<!--filename => The filename to which to write time history output.-->
		<xsd:attribute name="filename" type="string" default="TimeHistory" />
		<!--format => The output file format for time history output.-->
		<xsd:attribute name="format" type="string" default="hdf" />
		<!--parallelThreads => Number of plot files.-->
		<xsd:attribute name="parallelThreads" type="integer" default="1" />
		<!--sources => A list of collectors from which to collect and output time history information.-->
		<xsd:attribute name="sources" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="VTKType">
		<!--childDirectory => Child directory path-->
		<xsd:attribute name="childDirectory" type="string" default="" />
		<!--parallelThreads => Number of plot files.-->
		<xsd:attribute name="parallelThreads" type="integer" default="1" />
		<!--plotFileRoot => (no description available)-->
		<xsd:attribute name="plotFileRoot" type="string" default="" />
		<!--plotLevel => (no description available)-->
		<xsd:attribute name="plotLevel" type="integer" default="1" />
		<!--writeBinaryData => Output the data in binary format-->
		<xsd:attribute name="writeBinaryData" type="integer" default="1" />
		<!--writeFEMFaces => (no description available)-->
		<xsd:attribute name="writeFEMFaces" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SolversType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="CompositionalMultiphaseFVM" type="CompositionalMultiphaseFVMType" />
			<xsd:element name="CompositionalMultiphaseHybridFVM" type="CompositionalMultiphaseHybridFVMType" />
			<xsd:element name="CompositionalMultiphaseReservoir" type="CompositionalMultiphaseReservoirType" />
			<xsd:element name="CompositionalMultiphaseWell" type="CompositionalMultiphaseWellType" />
			<xsd:element name="EmbeddedSurfaceGenerator" type="EmbeddedSurfaceGeneratorType" />
			<xsd:element name="FlowProppantTransport" type="FlowProppantTransportType" />
			<xsd:element name="Hydrofracture" type="HydrofractureType" />
			<xsd:element name="LagrangianContact" type="LagrangianContactType" />
			<xsd:element name="LaplaceFEM" type="LaplaceFEMType" />
			<xsd:element name="PhaseFieldDamageFEM" type="PhaseFieldDamageFEMType" />
			<xsd:element name="PhaseFieldFracture" type="PhaseFieldFractureType" />
			<xsd:element name="Poroelastic" type="PoroelasticType" />
			<xsd:element name="ProppantTransport" type="ProppantTransportType" />
			<xsd:element name="SinglePhaseFVM" type="SinglePhaseFVMType" />
			<xsd:element name="SinglePhaseHybridFVM" type="SinglePhaseHybridFVMType" />
			<xsd:element name="SinglePhaseProppantFVM" type="SinglePhaseProppantFVMType" />
			<xsd:element name="SinglePhaseReservoir" type="SinglePhaseReservoirType" />
			<xsd:element name="SinglePhaseWell" type="SinglePhaseWellType" />
			<xsd:element name="SolidMechanicsEmbeddedFractures" type="SolidMechanicsEmbeddedFracturesType" />
			<xsd:element name="SolidMechanicsLagrangianSSLE" type="SolidMechanicsLagrangianSSLEType" />
			<xsd:element name="SolidMechanics_LagrangianFEM" type="SolidMechanics_LagrangianFEMType" />
			<xsd:element name="SurfaceGenerator" type="SurfaceGeneratorType" />
		</xsd:choice>
		<!--gravityVector => Gravity vector used in the physics solvers-->
		<xsd:attribute name="gravityVector" type="R1Tensor" default="0,0,-9.81" />
	</xsd:complexType>
	<xsd:complexType name="CompositionalMultiphaseFVMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--allowLocalCompDensityChopping => Flag indicating whether local (cell-wise) chopping of negative compositions is allowed-->
		<xsd:attribute name="allowLocalCompDensityChopping" type="integer" default="1" />
		<!--capPressureNames => Name of the capillary pressure constitutive model to use-->
		<xsd:attribute name="capPressureNames" type="string_array" default="{}" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object to use for this solver.-->
		<xsd:attribute name="discretization" type="string" use="required" />
		<!--fluidNames => Names of fluid constitutive models for each region.-->
		<xsd:attribute name="fluidNames" type="string_array" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--inputFluxEstimate => Initial estimate of the input flux used only for residual scaling. This should be essentially equivalent to the input flux * dt.-->
		<xsd:attribute name="inputFluxEstimate" type="real64" default="1" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxCompFractionChange => Maximum (absolute) change in a component fraction between two Newton iterations-->
		<xsd:attribute name="maxCompFractionChange" type="real64" default="1" />
		<!--meanPermCoeff => Coefficient to move between harmonic mean (1.0) and arithmetic mean (0.0) for the calculation of permeability between elements.-->
		<xsd:attribute name="meanPermCoeff" type="real64" default="1" />
		<!--relPermNames => Name of the relative permeability constitutive model to use-->
		<xsd:attribute name="relPermNames" type="string_array" use="required" />
		<!--solidNames => Names of solid constitutive models for each region.-->
		<xsd:attribute name="solidNames" type="string_array" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--temperature => Temperature-->
		<xsd:attribute name="temperature" type="real64" use="required" />
		<!--useMass => Use mass formulation instead of molar-->
		<xsd:attribute name="useMass" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CompositionalMultiphaseHybridFVMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--allowLocalCompDensityChopping => Flag indicating whether local (cell-wise) chopping of negative compositions is allowed-->
		<xsd:attribute name="allowLocalCompDensityChopping" type="integer" default="1" />
		<!--capPressureNames => Name of the capillary pressure constitutive model to use-->
		<xsd:attribute name="capPressureNames" type="string_array" default="{}" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object to use for this solver.-->
		<xsd:attribute name="discretization" type="string" use="required" />
		<!--fluidNames => Names of fluid constitutive models for each region.-->
		<xsd:attribute name="fluidNames" type="string_array" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--inputFluxEstimate => Initial estimate of the input flux used only for residual scaling. This should be essentially equivalent to the input flux * dt.-->
		<xsd:attribute name="inputFluxEstimate" type="real64" default="1" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxCompFractionChange => Maximum (absolute) change in a component fraction between two Newton iterations-->
		<xsd:attribute name="maxCompFractionChange" type="real64" default="1" />
		<!--maxRelativePressureChange => Maximum (relative) change in (face) pressure between two Newton iterations-->
		<xsd:attribute name="maxRelativePressureChange" type="real64" default="1" />
		<!--meanPermCoeff => Coefficient to move between harmonic mean (1.0) and arithmetic mean (0.0) for the calculation of permeability between elements.-->
		<xsd:attribute name="meanPermCoeff" type="real64" default="1" />
		<!--relPermNames => Name of the relative permeability constitutive model to use-->
		<xsd:attribute name="relPermNames" type="string_array" use="required" />
		<!--solidNames => Names of solid constitutive models for each region.-->
		<xsd:attribute name="solidNames" type="string_array" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--temperature => Temperature-->
		<xsd:attribute name="temperature" type="real64" use="required" />
		<!--useMass => Use mass formulation instead of molar-->
		<xsd:attribute name="useMass" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CompositionalMultiphaseReservoirType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--flowSolverName => Name of the flow solver to use in the reservoir-well system solver-->
		<xsd:attribute name="flowSolverName" type="string" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--wellSolverName => Name of the well solver to use in the reservoir-well system solver-->
		<xsd:attribute name="wellSolverName" type="string" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CompositionalMultiphaseWellType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="WellControls" type="WellControlsType" />
		</xsd:choice>
		<!--allowLocalCompDensityChopping => Flag indicating whether local (cell-wise) chopping of negative compositions is allowed-->
		<xsd:attribute name="allowLocalCompDensityChopping" type="integer" default="1" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--fluidNames => Name of fluid constitutive object to use for this solver.-->
		<xsd:attribute name="fluidNames" type="string_array" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxCompFractionChange => Maximum (absolute) change in a component fraction between two Newton iterations-->
		<xsd:attribute name="maxCompFractionChange" type="real64" default="1" />
		<!--relPermNames => Names of relative permeability constitutive models to use-->
		<xsd:attribute name="relPermNames" type="string_array" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--useMass => Use mass formulation instead of molar-->
		<xsd:attribute name="useMass" type="integer" default="0" />
		<!--wellTemperature => Temperature-->
		<xsd:attribute name="wellTemperature" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="WellControlsType">
		<!--control => Well control. Valid options:
* BHP
* gasRate
* oilRate
* waterRate
* liquidRate-->
		<xsd:attribute name="control" type="geosx_WellControls_Control" use="required" />
		<!--injectionStream => Global component densities for the injection stream-->
		<xsd:attribute name="injectionStream" type="real64_array" default="{-1}" />
		<!--targetBHP => Target bottom-hole pressure-->
		<xsd:attribute name="targetBHP" type="real64" use="required" />
		<!--targetRate => Target rate-->
		<xsd:attribute name="targetRate" type="real64" use="required" />
		<!--type => Well type. Valid options:
* producer
* injector-->
		<xsd:attribute name="type" type="geosx_WellControls_Type" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geosx_WellControls_Control">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|BHP|gasRate|oilRate|waterRate|liquidRate" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="geosx_WellControls_Type">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|producer|injector" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="EmbeddedSurfaceGeneratorType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--fractureRegion => (no description available)-->
		<xsd:attribute name="fractureRegion" type="string" default="FractureRegion" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--solidMaterialNames => Name of the solid material used in solid mechanic solver-->
		<xsd:attribute name="solidMaterialNames" type="string_array" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="FlowProppantTransportType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--flowSolverName => Name of the flow solver to use in the flowProppantTransport solver-->
		<xsd:attribute name="flowSolverName" type="string" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--proppantSolverName => Name of the proppant transport solver to use in the flowProppantTransport solver-->
		<xsd:attribute name="proppantSolverName" type="string" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="HydrofractureType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--contactRelationName => Name of contact relation to enforce constraints on fracture boundary.-->
		<xsd:attribute name="contactRelationName" type="string" use="required" />
		<!--couplingTypeOption => Coupling method. Valid options:
* FIM
* SIM_FixedStress-->
		<xsd:attribute name="couplingTypeOption" type="geosx_HydrofractureSolver_CouplingTypeOption" use="required" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="string" use="required" />
		<!--fluidSolverName => Name of the fluid mechanics solver to use in the poroelastic solver-->
		<xsd:attribute name="fluidSolverName" type="string" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxNumResolves => Value to indicate how many resolves may be executed to perform surface generation after the execution of flow and mechanics solver. -->
		<xsd:attribute name="maxNumResolves" type="integer" default="10" />
		<!--solidSolverName => Name of the solid mechanics solver to use in the poroelastic solver-->
		<xsd:attribute name="solidSolverName" type="string" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geosx_HydrofractureSolver_CouplingTypeOption">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|FIM|SIM_FixedStress" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="LagrangianContactType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--activeSetMaxIter => Maximum number of iteration for the active set strategy in the lagrangian contact solver-->
		<xsd:attribute name="activeSetMaxIter" type="integer" default="10" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--contactRelationName => Name of the constitutive law used for fracture elements-->
		<xsd:attribute name="contactRelationName" type="string" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--solidSolverName => Name of the solid mechanics solver to use in the lagrangian contact solver-->
		<xsd:attribute name="solidSolverName" type="string" use="required" />
		<!--stabilizationName => Name of the stabilization to use in the lagrangian contact solver-->
		<xsd:attribute name="stabilizationName" type="string" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="LaplaceFEMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="string" use="required" />
		<!--fieldName => Name of field variable-->
		<xsd:attribute name="fieldName" type="string" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--timeIntegrationOption => Time integration method. Options are:
* SteadyState
* ImplicitTransient
* ExplicitTransient-->
		<xsd:attribute name="timeIntegrationOption" type="geosx_LaplaceFEM_TimeIntegrationOption" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geosx_LaplaceFEM_TimeIntegrationOption">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|SteadyState|ImplicitTransient|ExplicitTransient" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="PhaseFieldDamageFEMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="string" use="required" />
		<!--fieldName => name of field variable-->
		<xsd:attribute name="fieldName" type="string" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--localDissipation => Type of local dissipation function. Can be Linear or Quadratic-->
		<xsd:attribute name="localDissipation" type="string" use="required" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--solidMaterialNames => name of solid constitutive model-->
		<xsd:attribute name="solidMaterialNames" type="string_array" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--timeIntegrationOption => option for default time integration method-->
		<xsd:attribute name="timeIntegrationOption" type="string" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PhaseFieldFractureType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--couplingTypeOption => Coupling option. Valid options:
* FixedStress
* TightlyCoupled-->
		<xsd:attribute name="couplingTypeOption" type="geosx_PhaseFieldFractureSolver_CouplingTypeOption" use="required" />
		<!--damageSolverName => Name of the damage mechanics solver to use in the PhaseFieldFracture solver-->
		<xsd:attribute name="damageSolverName" type="string" use="required" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="string" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--solidSolverName => Name of the solid mechanics solver to use in the PhaseFieldFracture solver-->
		<xsd:attribute name="solidSolverName" type="string" use="required" />
		<!--subcycling => turn on subcycling on each load step-->
		<xsd:attribute name="subcycling" type="integer" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geosx_PhaseFieldFractureSolver_CouplingTypeOption">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|FixedStress|TightlyCoupled" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="PoroelasticType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--couplingTypeOption => Coupling method. Valid options:
* FIM
* SIM_FixedStress-->
		<xsd:attribute name="couplingTypeOption" type="geosx_PoroelasticSolver_CouplingTypeOption" use="required" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="string" use="required" />
		<!--fluidSolverName => Name of the fluid mechanics solver to use in the poroelastic solver-->
		<xsd:attribute name="fluidSolverName" type="string" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--solidSolverName => Name of the solid mechanics solver to use in the poroelastic solver-->
		<xsd:attribute name="solidSolverName" type="string" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geosx_PoroelasticSolver_CouplingTypeOption">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|FIM|SIM_FixedStress" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="ProppantTransportType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--bridgingFactor => Bridging factor used for bridging/screen-out calculation-->
		<xsd:attribute name="bridgingFactor" type="real64" default="0" />
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--criticalShieldsNumber => Critical Shields number-->
		<xsd:attribute name="criticalShieldsNumber" type="real64" default="0" />
		<!--discretization => Name of discretization object to use for this solver.-->
		<xsd:attribute name="discretization" type="string" use="required" />
		<!--fluidNames => Names of fluid constitutive models for each region.-->
		<xsd:attribute name="fluidNames" type="string_array" use="required" />
		<!--frictionCoefficient => Friction coefficient-->
		<xsd:attribute name="frictionCoefficient" type="real64" default="0.03" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--inputFluxEstimate => Initial estimate of the input flux used only for residual scaling. This should be essentially equivalent to the input flux * dt.-->
		<xsd:attribute name="inputFluxEstimate" type="real64" default="1" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--maxProppantConcentration => Maximum proppant concentration-->
		<xsd:attribute name="maxProppantConcentration" type="real64" default="0.6" />
		<!--meanPermCoeff => Coefficient to move between harmonic mean (1.0) and arithmetic mean (0.0) for the calculation of permeability between elements.-->
		<xsd:attribute name="meanPermCoeff" type="real64" default="1" />
		<!--proppantDensity => Proppant density-->
		<xsd:attribute name="proppantDensity" type="real64" default="2500" />
		<!--proppantDiameter => Proppant diameter-->
		<xsd:attribute name="proppantDiameter" type="real64" default="0.0004" />
		<!--proppantNames => Name of proppant constitutive object to use for this solver.-->
		<xsd:attribute name="proppantNames" type="string_array" use="required" />
		<!--solidNames => Names of solid constitutive models for each region.-->
		<xsd:attribute name="solidNames" type="string_array" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--updateProppantPacking => Flag that enables/disables proppant-packing update-->
		<xsd:attribute name="updateProppantPacking" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhaseFVMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object to use for this solver.-->
		<xsd:attribute name="discretization" type="string" use="required" />
		<!--fluidNames => Names of fluid constitutive models for each region.-->
		<xsd:attribute name="fluidNames" type="string_array" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--inputFluxEstimate => Initial estimate of the input flux used only for residual scaling. This should be essentially equivalent to the input flux * dt.-->
		<xsd:attribute name="inputFluxEstimate" type="real64" default="1" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--meanPermCoeff => Coefficient to move between harmonic mean (1.0) and arithmetic mean (0.0) for the calculation of permeability between elements.-->
		<xsd:attribute name="meanPermCoeff" type="real64" default="1" />
		<!--solidNames => Names of solid constitutive models for each region.-->
		<xsd:attribute name="solidNames" type="string_array" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhaseHybridFVMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object to use for this solver.-->
		<xsd:attribute name="discretization" type="string" use="required" />
		<!--fluidNames => Names of fluid constitutive models for each region.-->
		<xsd:attribute name="fluidNames" type="string_array" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--inputFluxEstimate => Initial estimate of the input flux used only for residual scaling. This should be essentially equivalent to the input flux * dt.-->
		<xsd:attribute name="inputFluxEstimate" type="real64" default="1" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--meanPermCoeff => Coefficient to move between harmonic mean (1.0) and arithmetic mean (0.0) for the calculation of permeability between elements.-->
		<xsd:attribute name="meanPermCoeff" type="real64" default="1" />
		<!--solidNames => Names of solid constitutive models for each region.-->
		<xsd:attribute name="solidNames" type="string_array" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhaseProppantFVMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--discretization => Name of discretization object to use for this solver.-->
		<xsd:attribute name="discretization" type="string" use="required" />
		<!--fluidNames => Names of fluid constitutive models for each region.-->
		<xsd:attribute name="fluidNames" type="string_array" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--inputFluxEstimate => Initial estimate of the input flux used only for residual scaling. This should be essentially equivalent to the input flux * dt.-->
		<xsd:attribute name="inputFluxEstimate" type="real64" default="1" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--meanPermCoeff => Coefficient to move between harmonic mean (1.0) and arithmetic mean (0.0) for the calculation of permeability between elements.-->
		<xsd:attribute name="meanPermCoeff" type="real64" default="1" />
		<!--solidNames => Names of solid constitutive models for each region.-->
		<xsd:attribute name="solidNames" type="string_array" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhaseReservoirType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--flowSolverName => Name of the flow solver to use in the reservoir-well system solver-->
		<xsd:attribute name="flowSolverName" type="string" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--wellSolverName => Name of the well solver to use in the reservoir-well system solver-->
		<xsd:attribute name="wellSolverName" type="string" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SinglePhaseWellType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="WellControls" type="WellControlsType" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--fluidNames => Name of fluid constitutive object to use for this solver.-->
		<xsd:attribute name="fluidNames" type="string_array" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SolidMechanicsEmbeddedFracturesType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--contactRelationName => Name of contact relation to enforce constraints on fracture boundary.-->
		<xsd:attribute name="contactRelationName" type="string" use="required" />
		<!--fractureRegionName => Name of the fracture region.-->
		<xsd:attribute name="fractureRegionName" type="string" use="required" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--solidSolverName => Name of the solid mechanics solver in the rock matrix-->
		<xsd:attribute name="solidSolverName" type="string" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SolidMechanicsLagrangianSSLEType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--contactRelationName => Name of contact relation to enforce constraints on fracture boundary.-->
		<xsd:attribute name="contactRelationName" type="string" default="NOCONTACT" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="string" use="required" />
		<!--effectiveStress => Apply fluid pressure to produce effective stress when integrating stress.-->
		<xsd:attribute name="effectiveStress" type="integer" default="0" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--massDamping => Value of mass based damping coefficient. -->
		<xsd:attribute name="massDamping" type="real64" default="0" />
		<!--maxNumResolves => Value to indicate how many resolves may be executed after some other event is executed. For example, if a SurfaceGenerator is specified, it will be executed after the mechanics solve. However if a new surface is generated, then the mechanics solve must be executed again due to the change in topology.-->
		<xsd:attribute name="maxNumResolves" type="integer" default="10" />
		<!--newmarkBeta => Value of :math:`\beta` in the Newmark Method for Implicit Dynamic time integration option. This should be pow(newmarkGamma+0.5,2.0)/4.0 unless you know what you are doing.-->
		<xsd:attribute name="newmarkBeta" type="real64" default="0.25" />
		<!--newmarkGamma => Value of :math:`\gamma` in the Newmark Method for Implicit Dynamic time integration option-->
		<xsd:attribute name="newmarkGamma" type="real64" default="0.5" />
		<!--solidMaterialNames => The name of the material that should be used in the constitutive updates-->
		<xsd:attribute name="solidMaterialNames" type="string_array" use="required" />
		<!--stiffnessDamping => Value of stiffness based damping coefficient. -->
		<xsd:attribute name="stiffnessDamping" type="real64" default="0" />
		<!--strainTheory => Indicates whether or not to use `Infinitesimal Strain Theory <https://en.wikipedia.org/wiki/Infinitesimal_strain_theory>`_, or `Finite Strain Theory <https://en.wikipedia.org/wiki/Finite_strain_theory>`_. Valid Inputs are:
 0 - Infinitesimal Strain 
 1 - Finite Strain-->
		<xsd:attribute name="strainTheory" type="integer" default="0" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--timeIntegrationOption => Time integration method. Options are:
* QuasiStatic
* ImplicitDynamic
* ExplicitDynamic-->
		<xsd:attribute name="timeIntegrationOption" type="geosx_SolidMechanicsLagrangianFEM_TimeIntegrationOption" default="ExplicitDynamic" />
		<!--useVelocityForQS => Flag to indicate the use of the incremental displacement from the previous step as an initial estimate for the incremental displacement of the current step.-->
		<xsd:attribute name="useVelocityForQS" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geosx_SolidMechanicsLagrangianFEM_TimeIntegrationOption">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|QuasiStatic|ImplicitDynamic|ExplicitDynamic" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="SolidMechanics_LagrangianFEMType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--contactRelationName => Name of contact relation to enforce constraints on fracture boundary.-->
		<xsd:attribute name="contactRelationName" type="string" default="NOCONTACT" />
		<!--discretization => Name of discretization object (defined in the :ref:`NumericalMethodsManager`) to use for this solver. For instance, if this is a Finite Element Solver, the name of a :ref:`FiniteElement` should be specified. If this is a Finite Volume Method, the name of a :ref:`FiniteVolume` discretization should be specified.-->
		<xsd:attribute name="discretization" type="string" use="required" />
		<!--effectiveStress => Apply fluid pressure to produce effective stress when integrating stress.-->
		<xsd:attribute name="effectiveStress" type="integer" default="0" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--massDamping => Value of mass based damping coefficient. -->
		<xsd:attribute name="massDamping" type="real64" default="0" />
		<!--maxNumResolves => Value to indicate how many resolves may be executed after some other event is executed. For example, if a SurfaceGenerator is specified, it will be executed after the mechanics solve. However if a new surface is generated, then the mechanics solve must be executed again due to the change in topology.-->
		<xsd:attribute name="maxNumResolves" type="integer" default="10" />
		<!--newmarkBeta => Value of :math:`\beta` in the Newmark Method for Implicit Dynamic time integration option. This should be pow(newmarkGamma+0.5,2.0)/4.0 unless you know what you are doing.-->
		<xsd:attribute name="newmarkBeta" type="real64" default="0.25" />
		<!--newmarkGamma => Value of :math:`\gamma` in the Newmark Method for Implicit Dynamic time integration option-->
		<xsd:attribute name="newmarkGamma" type="real64" default="0.5" />
		<!--solidMaterialNames => The name of the material that should be used in the constitutive updates-->
		<xsd:attribute name="solidMaterialNames" type="string_array" use="required" />
		<!--stiffnessDamping => Value of stiffness based damping coefficient. -->
		<xsd:attribute name="stiffnessDamping" type="real64" default="0" />
		<!--strainTheory => Indicates whether or not to use `Infinitesimal Strain Theory <https://en.wikipedia.org/wiki/Infinitesimal_strain_theory>`_, or `Finite Strain Theory <https://en.wikipedia.org/wiki/Finite_strain_theory>`_. Valid Inputs are:
 0 - Infinitesimal Strain 
 1 - Finite Strain-->
		<xsd:attribute name="strainTheory" type="integer" default="0" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--timeIntegrationOption => Time integration method. Options are:
* QuasiStatic
* ImplicitDynamic
* ExplicitDynamic-->
		<xsd:attribute name="timeIntegrationOption" type="geosx_SolidMechanicsLagrangianFEM_TimeIntegrationOption" default="ExplicitDynamic" />
		<!--useVelocityForQS => Flag to indicate the use of the incremental displacement from the previous step as an initial estimate for the incremental displacement of the current step.-->
		<xsd:attribute name="useVelocityForQS" type="integer" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SurfaceGeneratorType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="LinearSolverParameters" type="LinearSolverParametersType" maxOccurs="1" />
			<xsd:element name="NonlinearSolverParameters" type="NonlinearSolverParametersType" maxOccurs="1" />
		</xsd:choice>
		<!--cflFactor => Factor to apply to the `CFL condition <http://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition>`_ when calculating the maximum allowable time step. Values should be in the interval (0,1] -->
		<xsd:attribute name="cflFactor" type="real64" default="0.5" />
		<!--fractureRegion => (no description available)-->
		<xsd:attribute name="fractureRegion" type="string" default="Fracture" />
		<!--initialDt => Initial time-step value required by the solver to the event manager.-->
		<xsd:attribute name="initialDt" type="real64" default="1e+99" />
		<!--logLevel => Log level-->
		<xsd:attribute name="logLevel" type="integer" default="0" />
		<!--mpiCommOrder => Flag to enable MPI consistent communication ordering-->
		<xsd:attribute name="mpiCommOrder" type="integer" default="0" />
		<!--nodeBasedSIF => Rock toughness of the solid material-->
		<xsd:attribute name="nodeBasedSIF" type="integer" default="0" />
		<!--rockToughness => Rock toughness of the solid material-->
		<xsd:attribute name="rockToughness" type="real64" use="required" />
		<!--solidMaterialNames => Name of the solid material used in solid mechanic solver-->
		<xsd:attribute name="solidMaterialNames" type="string_array" use="required" />
		<!--targetRegions => Allowable regions that the solver may be applied to. Note that this does not indicate that the solver will be applied to these regions, only that allocation will occur such that the solver may be applied to these regions. The decision about what regions this solver will beapplied to rests in the EventManager.-->
		<xsd:attribute name="targetRegions" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="TasksType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="PackCollection" type="PackCollectionType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="PackCollectionType">
		<!--fieldName => The name of the (packable) field associated with the specified object to retrieve data from-->
		<xsd:attribute name="fieldName" type="string" use="required" />
		<!--minSetSize => The minimum size of the set(s) to be collected (use for sets that expand during the simulation).-->
		<xsd:attribute name="minSetSize" type="localIndex" default="-1" />
		<!--objectPath => The name of the object from which to retrieve field values.-->
		<xsd:attribute name="objectPath" type="string" use="required" />
		<!--setNames => The set(s) for which to retrieve data.-->
		<xsd:attribute name="setNames" type="string_array" default="{}" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ConstitutiveType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="BlackOilFluid" type="BlackOilFluidType" />
			<xsd:element name="BrooksCoreyBakerRelativePermeability" type="BrooksCoreyBakerRelativePermeabilityType" />
			<xsd:element name="BrooksCoreyCapillaryPressure" type="BrooksCoreyCapillaryPressureType" />
			<xsd:element name="BrooksCoreyRelativePermeability" type="BrooksCoreyRelativePermeabilityType" />
			<xsd:element name="CompositionalMultiphaseFluid" type="CompositionalMultiphaseFluidType" />
			<xsd:element name="CompressibleSinglePhaseFluid" type="CompressibleSinglePhaseFluidType" />
			<xsd:element name="Contact" type="ContactType" />
			<xsd:element name="Coulomb" type="CoulombType" />
			<xsd:element name="DamageLinearElasticIsotropic" type="DamageLinearElasticIsotropicType" />
			<xsd:element name="DamageSpectralLinearElasticIsotropic" type="DamageSpectralLinearElasticIsotropicType" />
			<xsd:element name="DamageVolDevLinearElasticIsotropic" type="DamageVolDevLinearElasticIsotropicType" />
			<xsd:element name="LinearElasticAnisotropic" type="LinearElasticAnisotropicType" />
			<xsd:element name="LinearElasticIsotropic" type="LinearElasticIsotropicType" />
			<xsd:element name="LinearElasticTransverseIsotropic" type="LinearElasticTransverseIsotropicType" />
			<xsd:element name="MultiPhaseMultiComponentFluid" type="MultiPhaseMultiComponentFluidType" />
			<xsd:element name="NullModel" type="NullModelType" />
			<xsd:element name="ParticleFluid" type="ParticleFluidType" />
			<xsd:element name="PoreVolumeCompressibleSolid" type="PoreVolumeCompressibleSolidType" />
			<xsd:element name="PoroLinearElasticAnisotropic" type="PoroLinearElasticAnisotropicType" />
			<xsd:element name="PoroLinearElasticIsotropic" type="PoroLinearElasticIsotropicType" />
			<xsd:element name="PoroLinearElasticTransverseIsotropic" type="PoroLinearElasticTransverseIsotropicType" />
			<xsd:element name="ProppantSlurryFluid" type="ProppantSlurryFluidType" />
			<xsd:element name="VanGenuchtenBakerRelativePermeability" type="VanGenuchtenBakerRelativePermeabilityType" />
			<xsd:element name="VanGenuchtenCapillaryPressure" type="VanGenuchtenCapillaryPressureType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="BlackOilFluidType">
		<!--componentMolarWeight => Component molar weights-->
		<xsd:attribute name="componentMolarWeight" type="real64_array" use="required" />
		<!--componentNames => List of component names-->
		<xsd:attribute name="componentNames" type="string_array" default="{}" />
		<!--fluidType => Type of black-oil fluid. Valid options:
* DeadOil
* LiveOil-->
		<xsd:attribute name="fluidType" type="geosx_constitutive_BlackOilFluid_FluidType" use="required" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="string_array" use="required" />
		<!--surfaceDensities => List of surface densities for each phase-->
		<xsd:attribute name="surfaceDensities" type="real64_array" use="required" />
		<!--tableFiles => List of filenames with input PVT tables-->
		<xsd:attribute name="tableFiles" type="path_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geosx_constitutive_BlackOilFluid_FluidType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|DeadOil|LiveOil" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="BrooksCoreyBakerRelativePermeabilityType">
		<!--gasOilRelPermExponent => Rel perm power law exponent for the pair (gas phase, oil phase) at residual water saturation-->
		<xsd:attribute name="gasOilRelPermExponent" type="real64_array" default="{1}" />
		<!--gasOilRelPermMaxValue => Maximum rel perm value for the pair (gas phase, oil phase) at residual water saturation-->
		<xsd:attribute name="gasOilRelPermMaxValue" type="real64_array" default="{0}" />
		<!--phaseMinVolumeFraction => Minimum volume fraction value for each phase-->
		<xsd:attribute name="phaseMinVolumeFraction" type="real64_array" default="{0}" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="string_array" use="required" />
		<!--waterOilRelPermExponent => Rel perm power law exponent for the pair (water phase, oil phase) at residual gas saturation-->
		<xsd:attribute name="waterOilRelPermExponent" type="real64_array" default="{1}" />
		<!--waterOilRelPermMaxValue => Maximum rel perm value for the pair (water phase, oil phase) at residual gas saturation-->
		<xsd:attribute name="waterOilRelPermMaxValue" type="real64_array" default="{0}" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="BrooksCoreyCapillaryPressureType">
		<!--capPressureEpsilon => Wetting-phase saturation at which the max cap. pressure is attained; used to avoid infinite cap. pressure values for saturations close to zero-->
		<xsd:attribute name="capPressureEpsilon" type="real64" default="1e-06" />
		<!--phaseCapPressureExponentInv => Inverse of capillary power law exponent for each phase-->
		<xsd:attribute name="phaseCapPressureExponentInv" type="real64_array" default="{2}" />
		<!--phaseEntryPressure => Entry pressure value for each phase-->
		<xsd:attribute name="phaseEntryPressure" type="real64_array" default="{1}" />
		<!--phaseMinVolumeFraction => Minimum volume fraction value for each phase-->
		<xsd:attribute name="phaseMinVolumeFraction" type="real64_array" default="{0}" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="BrooksCoreyRelativePermeabilityType">
		<!--phaseMinVolumeFraction => Minimum volume fraction value for each phase-->
		<xsd:attribute name="phaseMinVolumeFraction" type="real64_array" default="{0}" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="string_array" use="required" />
		<!--phaseRelPermExponent => MinimumRel perm power law exponent for each phase-->
		<xsd:attribute name="phaseRelPermExponent" type="real64_array" default="{1}" />
		<!--phaseRelPermMaxValue => Maximum rel perm value for each phase-->
		<xsd:attribute name="phaseRelPermMaxValue" type="real64_array" default="{0}" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CompositionalMultiphaseFluidType">
		<!--componentAcentricFactor => Component acentric factors-->
		<xsd:attribute name="componentAcentricFactor" type="real64_array" use="required" />
		<!--componentBinaryCoeff => Table of binary interaction coefficients-->
		<xsd:attribute name="componentBinaryCoeff" type="real64_array2d" default="{{0}}" />
		<!--componentCriticalPressure => Component critical pressures-->
		<xsd:attribute name="componentCriticalPressure" type="real64_array" use="required" />
		<!--componentCriticalTemperature => Component critical temperatures-->
		<xsd:attribute name="componentCriticalTemperature" type="real64_array" use="required" />
		<!--componentMolarWeight => Component molar weights-->
		<xsd:attribute name="componentMolarWeight" type="real64_array" use="required" />
		<!--componentNames => List of component names-->
		<xsd:attribute name="componentNames" type="string_array" use="required" />
		<!--componentVolumeShift => Component volume shifts-->
		<xsd:attribute name="componentVolumeShift" type="real64_array" default="{0}" />
		<!--equationsOfState => List of equation of state types for each phase-->
		<xsd:attribute name="equationsOfState" type="string_array" use="required" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CompressibleSinglePhaseFluidType">
		<!--compressibility => Fluid compressibility-->
		<xsd:attribute name="compressibility" type="real64" default="0" />
		<!--defaultDensity => Default value for density.-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultViscosity => Default value for viscosity.-->
		<xsd:attribute name="defaultViscosity" type="real64" use="required" />
		<!--densityModelType => Type of density model. Valid options:
* exponential
* linear
* quadratic-->
		<xsd:attribute name="densityModelType" type="geosx_constitutive_ExponentApproximationType" default="linear" />
		<!--referenceDensity => Reference fluid density-->
		<xsd:attribute name="referenceDensity" type="real64" default="1000" />
		<!--referencePressure => Reference pressure-->
		<xsd:attribute name="referencePressure" type="real64" default="0" />
		<!--referenceViscosity => Reference fluid viscosity-->
		<xsd:attribute name="referenceViscosity" type="real64" default="0.001" />
		<!--viscosibility => Fluid viscosity exponential coefficient-->
		<xsd:attribute name="viscosibility" type="real64" default="0" />
		<!--viscosityModelType => Type of viscosity model. Valid options:
* exponential
* linear
* quadratic-->
		<xsd:attribute name="viscosityModelType" type="geosx_constitutive_ExponentApproximationType" default="linear" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geosx_constitutive_ExponentApproximationType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|exponential|linear|quadratic" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="ContactType">
		<xsd:choice minOccurs="0" maxOccurs="1">
			<xsd:element name="TableFunction" type="TableFunctionType" />
		</xsd:choice>
		<!--apertureTolerance => Value to be used to avoid floating point errors in expressions involving aperture. For example in the case of dividing by the actual aperture (not the effective aperture that results from the aperture function) this value may be used to avoid 1/0 errors. Note that this value may have some physical significance in its usage, as it may be used to smooth out highly nonlinear behavior associated with 1/0 in addition to avoiding the 1/0 error.-->
		<xsd:attribute name="apertureTolerance" type="real64" default="1e-09" />
		<!--penaltyStiffness => Value of the penetration penalty stiffness. Units of Pressure/length-->
		<xsd:attribute name="penaltyStiffness" type="real64" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="CoulombType">
		<xsd:choice minOccurs="0" maxOccurs="1">
			<xsd:element name="TableFunction" type="TableFunctionType" />
		</xsd:choice>
		<!--apertureTolerance => Value to be used to avoid floating point errors in expressions involving aperture. For example in the case of dividing by the actual aperture (not the effective aperture that results from the aperture function) this value may be used to avoid 1/0 errors. Note that this value may have some physical significance in its usage, as it may be used to smooth out highly nonlinear behavior associated with 1/0 in addition to avoiding the 1/0 error.-->
		<xsd:attribute name="apertureTolerance" type="real64" default="1e-09" />
		<!--cohesion => Cohesion-->
		<xsd:attribute name="cohesion" type="real64" use="required" />
		<!--frictionAngle => Friction Angle (in radians)-->
		<xsd:attribute name="frictionAngle" type="real64" default="-1" />
		<!--frictionCoefficient => Friction Coefficient-->
		<xsd:attribute name="frictionCoefficient" type="real64" default="-1" />
		<!--penaltyStiffness => Value of the penetration penalty stiffness. Units of Pressure/length-->
		<xsd:attribute name="penaltyStiffness" type="real64" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="DamageLinearElasticIsotropicType">
		<!--criticalFractureEnergy => critical fracture energy-->
		<xsd:attribute name="criticalFractureEnergy" type="real64" use="required" />
		<!--criticalStrainEnergy => material critical stress in a 1d tension test-->
		<xsd:attribute name="criticalStrainEnergy" type="real64" use="required" />
		<!--defaultBulkModulus => Elastic Bulk Modulus Parameter-->
		<xsd:attribute name="defaultBulkModulus" type="real64" default="-1" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultPoissonRatio => Poisson's ratio-->
		<xsd:attribute name="defaultPoissonRatio" type="real64" default="-1" />
		<!--defaultShearModulus => Elastic Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulus" type="real64" default="-1" />
		<!--defaultYoungsModulus => Elastic Young's Modulus.-->
		<xsd:attribute name="defaultYoungsModulus" type="real64" default="-1" />
		<!--lengthScale => lenght scale l in the phase-field equation-->
		<xsd:attribute name="lengthScale" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="DamageSpectralLinearElasticIsotropicType">
		<!--criticalFractureEnergy => critical fracture energy-->
		<xsd:attribute name="criticalFractureEnergy" type="real64" use="required" />
		<!--criticalStrainEnergy => material critical stress in a 1d tension test-->
		<xsd:attribute name="criticalStrainEnergy" type="real64" use="required" />
		<!--defaultBulkModulus => Elastic Bulk Modulus Parameter-->
		<xsd:attribute name="defaultBulkModulus" type="real64" default="-1" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultPoissonRatio => Poisson's ratio-->
		<xsd:attribute name="defaultPoissonRatio" type="real64" default="-1" />
		<!--defaultShearModulus => Elastic Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulus" type="real64" default="-1" />
		<!--defaultYoungsModulus => Elastic Young's Modulus.-->
		<xsd:attribute name="defaultYoungsModulus" type="real64" default="-1" />
		<!--lengthScale => lenght scale l in the phase-field equation-->
		<xsd:attribute name="lengthScale" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="DamageVolDevLinearElasticIsotropicType">
		<!--criticalFractureEnergy => critical fracture energy-->
		<xsd:attribute name="criticalFractureEnergy" type="real64" use="required" />
		<!--criticalStrainEnergy => material critical stress in a 1d tension test-->
		<xsd:attribute name="criticalStrainEnergy" type="real64" use="required" />
		<!--defaultBulkModulus => Elastic Bulk Modulus Parameter-->
		<xsd:attribute name="defaultBulkModulus" type="real64" default="-1" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultPoissonRatio => Poisson's ratio-->
		<xsd:attribute name="defaultPoissonRatio" type="real64" default="-1" />
		<!--defaultShearModulus => Elastic Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulus" type="real64" default="-1" />
		<!--defaultYoungsModulus => Elastic Young's Modulus.-->
		<xsd:attribute name="defaultYoungsModulus" type="real64" default="-1" />
		<!--lengthScale => lenght scale l in the phase-field equation-->
		<xsd:attribute name="lengthScale" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="LinearElasticAnisotropicType">
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultStiffness => Default Elastic Stiffness Tensor in Voigt notation (6x6 matrix)-->
		<xsd:attribute name="defaultStiffness" type="real64_array2d" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="LinearElasticIsotropicType">
		<!--defaultBulkModulus => Elastic Bulk Modulus Parameter-->
		<xsd:attribute name="defaultBulkModulus" type="real64" default="-1" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultPoissonRatio => Poisson's ratio-->
		<xsd:attribute name="defaultPoissonRatio" type="real64" default="-1" />
		<!--defaultShearModulus => Elastic Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulus" type="real64" default="-1" />
		<!--defaultYoungsModulus => Elastic Young's Modulus.-->
		<xsd:attribute name="defaultYoungsModulus" type="real64" default="-1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="LinearElasticTransverseIsotropicType">
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultPoissonRatioAxialTransverse => Elastic Shear Modulus Parameter-->
		<xsd:attribute name="defaultPoissonRatioAxialTransverse" type="real64" default="-1" />
		<!--defaultPoissonRatioTransverse => Elastic Shear Modulus Parameter-->
		<xsd:attribute name="defaultPoissonRatioTransverse" type="real64" default="-1" />
		<!--defaultShearModulusAxialTransverse => Elastic Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulusAxialTransverse" type="real64" default="-1" />
		<!--defaultYoungsModulusAxial => Elastic Shear Modulus Parameter-->
		<xsd:attribute name="defaultYoungsModulusAxial" type="real64" default="-1" />
		<!--defaultYoungsModulusTransverse => Elastic Bulk Modulus Parameter-->
		<xsd:attribute name="defaultYoungsModulusTransverse" type="real64" default="-1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="MultiPhaseMultiComponentFluidType">
		<!--componentMolarWeight => Component molar weights-->
		<xsd:attribute name="componentMolarWeight" type="real64_array" default="{0}" />
		<!--componentNames => List of component names-->
		<xsd:attribute name="componentNames" type="string_array" default="{}" />
		<!--flashModelParaFile => name of the filen including flash calculation function parameters-->
		<xsd:attribute name="flashModelParaFile" type="path" use="required" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="string_array" default="{}" />
		<!--phasePVTParaFiles => List of the names of the files including PVT function parameters-->
		<xsd:attribute name="phasePVTParaFiles" type="path_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="NullModelType">
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ParticleFluidType">
		<!--collisionAlpha => Collision alpha coefficient-->
		<xsd:attribute name="collisionAlpha" type="real64" default="1.27" />
		<!--collisionBeta => Collision beta coefficient-->
		<xsd:attribute name="collisionBeta" type="real64" default="1.5" />
		<!--fluidViscosity => Fluid viscosity-->
		<xsd:attribute name="fluidViscosity" type="real64" default="0.001" />
		<!--hinderedSettlingCoefficient => Hindered settling coefficient-->
		<xsd:attribute name="hinderedSettlingCoefficient" type="real64" default="5.9" />
		<!--isCollisionalSlip => Whether the collisional component of the slip velocity is considered-->
		<xsd:attribute name="isCollisionalSlip" type="integer" default="0" />
		<!--maxProppantConcentration => Max proppant concentration-->
		<xsd:attribute name="maxProppantConcentration" type="real64" default="0.6" />
		<!--particleSettlingModel => Particle settling velocity model. Valid options:
* Stokes
* Intermediate
* Turbulence-->
		<xsd:attribute name="particleSettlingModel" type="geosx_constitutive_ParticleSettlingModel" use="required" />
		<!--proppantDensity => Proppant density-->
		<xsd:attribute name="proppantDensity" type="real64" default="1400" />
		<!--proppantDiameter => Proppant diameter-->
		<xsd:attribute name="proppantDiameter" type="real64" default="0.0002" />
		<!--slipConcentration => Slip concentration-->
		<xsd:attribute name="slipConcentration" type="real64" default="0.1" />
		<!--sphericity => Sphericity-->
		<xsd:attribute name="sphericity" type="real64" default="1" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geosx_constitutive_ParticleSettlingModel">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|Stokes|Intermediate|Turbulence" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="PoreVolumeCompressibleSolidType">
		<!--compressibility => Solid compressibility-->
		<xsd:attribute name="compressibility" type="real64" use="required" />
		<!--referencePressure => Reference pressure for fluid compressibility-->
		<xsd:attribute name="referencePressure" type="real64" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PoroLinearElasticAnisotropicType">
		<!--BiotCoefficient => Biot's coefficient-->
		<xsd:attribute name="BiotCoefficient" type="real64" default="1" />
		<!--compressibility => Pore volume compressibilty-->
		<xsd:attribute name="compressibility" type="real64" default="0" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultStiffness => Default Elastic Stiffness Tensor in Voigt notation (6x6 matrix)-->
		<xsd:attribute name="defaultStiffness" type="real64_array2d" use="required" />
		<!--referencePressure => ReferencePressure-->
		<xsd:attribute name="referencePressure" type="real64" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PoroLinearElasticIsotropicType">
		<!--BiotCoefficient => Biot's coefficient-->
		<xsd:attribute name="BiotCoefficient" type="real64" default="1" />
		<!--compressibility => Pore volume compressibilty-->
		<xsd:attribute name="compressibility" type="real64" default="0" />
		<!--defaultBulkModulus => Elastic Bulk Modulus Parameter-->
		<xsd:attribute name="defaultBulkModulus" type="real64" default="-1" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultPoissonRatio => Poisson's ratio-->
		<xsd:attribute name="defaultPoissonRatio" type="real64" default="-1" />
		<!--defaultShearModulus => Elastic Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulus" type="real64" default="-1" />
		<!--defaultYoungsModulus => Elastic Young's Modulus.-->
		<xsd:attribute name="defaultYoungsModulus" type="real64" default="-1" />
		<!--referencePressure => ReferencePressure-->
		<xsd:attribute name="referencePressure" type="real64" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="PoroLinearElasticTransverseIsotropicType">
		<!--BiotCoefficient => Biot's coefficient-->
		<xsd:attribute name="BiotCoefficient" type="real64" default="1" />
		<!--compressibility => Pore volume compressibilty-->
		<xsd:attribute name="compressibility" type="real64" default="0" />
		<!--defaultDensity => Default Material Density-->
		<xsd:attribute name="defaultDensity" type="real64" use="required" />
		<!--defaultPoissonRatioAxialTransverse => Elastic Shear Modulus Parameter-->
		<xsd:attribute name="defaultPoissonRatioAxialTransverse" type="real64" default="-1" />
		<!--defaultPoissonRatioTransverse => Elastic Shear Modulus Parameter-->
		<xsd:attribute name="defaultPoissonRatioTransverse" type="real64" default="-1" />
		<!--defaultShearModulusAxialTransverse => Elastic Shear Modulus Parameter-->
		<xsd:attribute name="defaultShearModulusAxialTransverse" type="real64" default="-1" />
		<!--defaultYoungsModulusAxial => Elastic Shear Modulus Parameter-->
		<xsd:attribute name="defaultYoungsModulusAxial" type="real64" default="-1" />
		<!--defaultYoungsModulusTransverse => Elastic Bulk Modulus Parameter-->
		<xsd:attribute name="defaultYoungsModulusTransverse" type="real64" default="-1" />
		<!--referencePressure => ReferencePressure-->
		<xsd:attribute name="referencePressure" type="real64" default="0" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ProppantSlurryFluidType">
		<!--componentNames => List of fluid component names-->
		<xsd:attribute name="componentNames" type="string_array" default="{}" />
		<!--compressibility => Fluid compressibility-->
		<xsd:attribute name="compressibility" type="real64" default="0" />
		<!--defaultCompressibility => Default value for compressibility.-->
		<xsd:attribute name="defaultCompressibility" type="real64_array" default="{0}" />
		<!--defaultDensity => Default value for density.-->
		<xsd:attribute name="defaultDensity" type="real64_array" default="{0}" />
		<!--defaultViscosity => Default value for viscosity.-->
		<xsd:attribute name="defaultViscosity" type="real64_array" default="{0}" />
		<!--flowBehaviorIndex => Flow behavior index-->
		<xsd:attribute name="flowBehaviorIndex" type="real64_array" default="{0}" />
		<!--flowConsistencyIndex => Flow consistency index-->
		<xsd:attribute name="flowConsistencyIndex" type="real64_array" default="{0}" />
		<!--maxProppantConcentration => Maximum proppant concentration-->
		<xsd:attribute name="maxProppantConcentration" type="real64" default="0.6" />
		<!--referenceDensity => Reference fluid density-->
		<xsd:attribute name="referenceDensity" type="real64" default="1000" />
		<!--referencePressure => Reference pressure-->
		<xsd:attribute name="referencePressure" type="real64" default="100000" />
		<!--referenceProppantDensity => Reference proppant density-->
		<xsd:attribute name="referenceProppantDensity" type="real64" default="1400" />
		<!--referenceViscosity => Reference fluid viscosity-->
		<xsd:attribute name="referenceViscosity" type="real64" default="0.001" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="VanGenuchtenBakerRelativePermeabilityType">
		<!--gasOilRelPermExponentInv => Rel perm power law exponent inverse for the pair (gas phase, oil phase) at residual water saturation-->
		<xsd:attribute name="gasOilRelPermExponentInv" type="real64_array" default="{0.5}" />
		<!--gasOilRelPermMaxValue => Maximum rel perm value for the pair (gas phase, oil phase) at residual water saturation-->
		<xsd:attribute name="gasOilRelPermMaxValue" type="real64_array" default="{0}" />
		<!--phaseMinVolumeFraction => Minimum volume fraction value for each phase-->
		<xsd:attribute name="phaseMinVolumeFraction" type="real64_array" default="{0}" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="string_array" use="required" />
		<!--waterOilRelPermExponentInv => Rel perm power law exponent inverse for the pair (water phase, oil phase) at residual gas saturation-->
		<xsd:attribute name="waterOilRelPermExponentInv" type="real64_array" default="{0.5}" />
		<!--waterOilRelPermMaxValue => Maximum rel perm value for the pair (water phase, oil phase) at residual gas saturation-->
		<xsd:attribute name="waterOilRelPermMaxValue" type="real64_array" default="{0}" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="VanGenuchtenCapillaryPressureType">
		<!--capPressureEpsilon => Saturation at which the extremum capillary pressure is attained; used to avoid infinite capillary pressure values for saturations close to 0 and 1-->
		<xsd:attribute name="capPressureEpsilon" type="real64" default="1e-06" />
		<!--phaseCapPressureExponentInv => Inverse of capillary power law exponent for each phase-->
		<xsd:attribute name="phaseCapPressureExponentInv" type="real64_array" default="{0.5}" />
		<!--phaseCapPressureMultiplier => Entry pressure value for each phase-->
		<xsd:attribute name="phaseCapPressureMultiplier" type="real64_array" default="{1}" />
		<!--phaseMinVolumeFraction => Minimum volume fraction value for each phase-->
		<xsd:attribute name="phaseMinVolumeFraction" type="real64_array" default="{0}" />
		<!--phaseNames => List of fluid phases-->
		<xsd:attribute name="phaseNames" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ElementRegionsType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="CellElementRegion" type="CellElementRegionType" />
			<xsd:element name="SurfaceElementRegion" type="SurfaceElementRegionType" />
			<xsd:element name="WellElementRegion" type="WellElementRegionType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="CellElementRegionType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded" />
		<!--cellBlocks => (no description available)-->
		<xsd:attribute name="cellBlocks" type="string_array" default="{}" />
		<!--coarseningRatio => (no description available)-->
		<xsd:attribute name="coarseningRatio" type="real64" default="0" />
		<!--materialList => List of materials present in this region-->
		<xsd:attribute name="materialList" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="SurfaceElementRegionType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded" />
		<!--defaultAperture => The default aperture of newly formed surface elements.-->
		<xsd:attribute name="defaultAperture" type="real64" use="required" />
		<!--materialList => List of materials present in this region-->
		<xsd:attribute name="materialList" type="string_array" use="required" />
		<!--subRegionType => Type of surface element subregion. Valid options:
* faceElement
* embeddedElement-->
		<xsd:attribute name="subRegionType" type="geosx_SurfaceElementRegion_SurfaceSubRegionType" default="faceElement" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:simpleType name="geosx_SurfaceElementRegion_SurfaceSubRegionType">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value=".*[\[\]`$].*|faceElement|embeddedElement" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="WellElementRegionType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded" />
		<!--materialList => List of materials present in this region-->
		<xsd:attribute name="materialList" type="string_array" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="IncludedType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="File" type="FileType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="FileType">
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="ParametersType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Parameter" type="ParameterType" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="ParameterType">
		<!--value => Input parameter definition for the preprocessor-->
		<xsd:attribute name="value" type="string" use="required" />
		<!--name => A name is required for any non-unique nodes-->
		<xsd:attribute name="name" type="string" use="required" />
	</xsd:complexType>
	<xsd:complexType name="BenchmarksType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="lassen" type="lassenType" maxOccurs="1" />
			<xsd:element name="quartz" type="quartzType" maxOccurs="1" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="lassenType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Run" type="RunType" maxOccurs="1" />
		</xsd:choice>
	</xsd:complexType>
	<xsd:complexType name="RunType">
		<!--args => Any extra command line arguments to pass to GEOSX.-->
		<xsd:attribute name="args" type="string" default="" />
		<!--autoPartition => May be 'Off' or 'On', if 'On' partitioning arguments are created automatically. Default is Off.-->
		<xsd:attribute name="autoPartition" type="string" default="" />
		<!--name => The name of this benchmark.-->
		<xsd:attribute name="name" type="string" use="required" />
		<!--nodes => The number of nodes needed to run the benchmark.-->
		<xsd:attribute name="nodes" type="integer" use="required" />
		<!--strongScaling => Repeat the benchmark N times, scaling the number of nodes in the benchmark by these values.-->
		<xsd:attribute name="strongScaling" type="integer_array" default="{0}" />
		<!--tasksPerNode => The number of tasks per node to run the benchmark with.-->
		<xsd:attribute name="tasksPerNode" type="integer" use="required" />
		<!--threadsPerTask => The number of threads per task to run the benchmark with.-->
		<xsd:attribute name="threadsPerTask" type="integer" default="0" />
		<!--timeLimit => The time limit of the benchmark.-->
		<xsd:attribute name="timeLimit" type="integer" default="0" />
	</xsd:complexType>
	<xsd:complexType name="quartzType">
		<xsd:choice minOccurs="0" maxOccurs="unbounded">
			<xsd:element name="Run" type="RunType" maxOccurs="1" />
		</xsd:choice>
	</xsd:complexType>
</xsd:schema>
